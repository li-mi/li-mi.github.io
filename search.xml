<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Êù®Ê∞èÁü©Èòµ&Èí©Â≠êÂÖ¨Âºè]]></title>
    <url>%2F2018%2F11%2F26%2F%E6%9D%A8%E6%B0%8F%E7%9F%A9%E9%98%B5%26%E9%92%A9%E5%AD%90%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Êù®Ê∞èÁü©ÈòµÊòØËøôÊ†∑‰∏Ä‰∏™Áü©ÈòµÔºåÊª°Ë∂≥Êù°‰ª∂Ôºö(1)Â¶ÇÊûúÊ†ºÂ≠ê(i,j)Ê≤°ÊúâÂÖÉÁ¥†ÔºåÂàôÂÆÉÂè≥ËæπÂíå‰∏äËæπÁöÑÁõ∏ÈÇªÊ†ºÂ≠ê‰πü‰∏ÄÂÆöÊ≤°ÊúâÂÖÉÁ¥†„ÄÇ(2)Â¶ÇÊûúÊ†ºÂ≠ê(i,j)ÊúâÂÖÉÁ¥†a[i][j]ÔºåÂàôÂÆÉÂè≥ËæπÂíå‰∏äËæπÁöÑÁõ∏ÈÇªÊ†ºÂ≠êË¶Å‰πàÊ≤°ÊúâÂÖÉÁ¥†ÔºåË¶Å‰πàÊúâÂÖÉÁ¥†‰∏îÊØîa[i][j]Â§ß„ÄÇ$F[1]=1,F[2]=2,F[n]=F[n-1]+(n-1)*F[n-2] (n&gt;2)$ Èí©Â≠êÂÖ¨ÂºèÔºöÂØπ‰∫éÁªôÂÆöÂΩ¢Áä∂Ôºå‰∏çÂêåÁöÑÊù®Ê∞èÁü©ÈòµÁöÑ‰∏™Êï∞‰∏∫Ôºön!Èô§‰ª•ÊØè‰∏™Ê†ºÂ≠êÁöÑÈí©Â≠êÈïøÂ∫¶Âä†1ÁöÑÁßØ„ÄÇÂÖ∂‰∏≠Èí©Â≠êÈïøÂ∫¶ÂÆö‰πâ‰∏∫ËØ•Ê†ºÂ≠êÂè≥ËæπÁöÑÊ†ºÂ≠êÊï∞ÂíåÂÆÉ‰∏äËæπÁöÑÊ†ºÂ≠êÊï∞‰πãÂíå„ÄÇ]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ËÄÉËØïÂÆâÊéí]]></title>
    <url>%2F2018%2F11%2F09%2F%E8%80%83%E8%AF%95%E5%AE%89%E6%8E%92%2F</url>
    <content type="text"><![CDATA[ÂÖàÂÆâË£ÖÊúÄÊñ∞ÁâàÊú¨devÁºñËØëÊó∂Âä†ÂÖ•‰ª•‰∏ãÂëΩ‰ª§Ôºö-Wall -Wl,‚Äìstack=1000000000 -std=c++11ÔºàÊúÄÂêéÊîπÊàê03ÁºñËØëÔºÅÔºÅÔºâ-O2Áî®‰∫éÊâìË°®ÊâæËßÑÂæã Â≠ó‰ΩìÔºöConsolasÈ¢ÑËÆæÔºöObsidian ÂèñÊ∂à‰ª£Á†ÅË°•ÂÖ®„ÄÅÁ¨¶Âè∑ÂåπÈÖç ÂºÄÂßãÂÜôÊ®°Êùø123456789101112131415#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;int main()&#123; return 0;&#125; ÂÜôÂÆåÂä†ÂÖ•Âà∞Áº∫ÁúÅÊ∫ê ÁÑ∂ÂêéÂª∫Êñá‰ª∂Â§π ÁÑ∂ÂêéÂÜôÁîüÊàê123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;timeb tim;mt19937 mt;inline int ra()&#123; return mt()&gt;&gt;1;//mt()ÊòØunsigned int &#125;inline LL rall()&#123; return (1ll*ra()&lt;&lt;30)+ra();&#125;int main()&#123; freopen(&quot;1.in&quot;,&quot;w&quot;,stdout); ftime(&amp;tim); mt.seed(tim.time*1000+tim.millitm); return 0;&#125; ÁÑ∂ÂêéÂÜôduipai.batÔºàÂíåbfÊãçÔºâÂíåpai.batÔºàÊµãÊûÅÈôêÊï∞ÊçÆÁöÑÊó∂Èó¥Ôºâ ÊúÄÂêéÊää‰∏úË•øÂ§çÂà∂Âà∞ÂêÑ‰∏™Êñá‰ª∂Â§πÂ∞±Ë°å‰∫ÜÂ§ö‰ΩôÁöÑÊó∂Èó¥ÊâìÊâìksmÔºåadd_ans,add_edge,(fx treap)]]></content>
      <tags>
        <tag>ÂøÉÊÉÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄêÂ≠¶‰π†Á¨îËÆ∞„Äë‰∏ªÂ∏≠Ê†ë]]></title>
    <url>%2F2018%2F11%2F08%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[‰∏ªÂ∏≠Ê†ëÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶ÔºöO(nlogn)‰∏ªÂ∏≠Ê†ëÁöÑÁ©∫Èó¥Â§çÊùÇÂ∫¶ÔºöO(nlogn)ÔºàÂºÄ2lognÊØîËæÉÂ•ΩÔºâ‰∏ªÂ∏≠Ê†ëÁöÑÊèíÂÖ•Ë¶ÅÁî®ÂºïÁî®ÔºÅ ‰∏ªÂ∏≠Ê†ëÁöÑ‰∏ª‰ΩìÔºö123456int rt[N],tot;struct president_tree&#123; int ls,rs,sz; LL sum; /* more*/&#125;tr[N*150];//ËÉΩÂºÄÂ§öÂ§ßÂºÄÂ§öÂ§ß ‰∏ªÂ∏≠Ê†ëÊòØÂä®ÊÄÅÂºÄÁÇπÊùÉÂÄºÁ∫øÊÆµÊ†ëÔºåÊ≥®ÊÑè‰∏ä‰∏ãÁïåÁöÑËÆæÁΩÆÔºàÊ≥®ÊÑèinfÁöÑËÆæÁΩÆÂíå0/1ÁöÑËÆæÁΩÆÔºâÂõ†‰∏∫‰∏ªÂ∏≠Ê†ëÊòØ‰∏çÊîØÊåÅ‰øÆÊîπÁöÑÔºåÊâÄ‰ª•‰∏ÄËà¨ÈÉΩÊòØ‰∏ÄÂºÄÂßãÂ∞±ÊääÊ†ëÂª∫Â•ΩÊèíÂÖ•Ôºö123456789101112131415inline void update(int &amp;t,int l,int r,int val)&#123; tr[++tot]=tr[t]; ++tr[tot].sz; tr[tot].sum+=val;//ÂÖà‰∫ßÁîü‰∏Ä‰∏™Êñ∞ÁÇπ t=tot;//ÂÜçËµãÂÄº if(l==r) return; int mid=l+(r-l)/2;//ÂèØËÉΩ‰ºöÁàÜint if(val&lt;=mid) update(tr[t].ls,l,mid,val); else update(tr[t].rs,mid+1,r,val);&#125;for(int i=1;i&lt;=n;++i)&#123; rt[i]=rt[i-1]; update(rt[i],1,inf,a[i]);&#125; ËØ¢ÈóÆÂáΩÊï∞ÂèØ‰ª•ÊúâËøîÂõûÂÄºÔºå‰πüÂèØ‰ª•Ê≤°ÊúâÔºåËÄå‰ΩøÁî®‰∏Ä‰∏™ÂÖ®Â±ÄÂèòÈáèËÆ∞ÂΩïÁ≠îÊ°àËØ¢ÈóÆÔºö12345678910111213141516171819LL tmp;inline void query(int t1,int t2,int l,int r,int num)&#123; if(!num) return; if(tr[t2].sz-tr[t1].sz&lt;=num)&#123; tmp+=tr[t2].sum-tr[t1].sum; return; &#125; if(l==r)&#123; tmp+=1ll*num*l; return; &#125; int mid=l+(r-l)/2,t=tr[tr[t2].rs].sz-tr[tr[t1].rs].sz; if(num&lt;=t) query(tr[t1].rs,tr[t2].rs,mid+1,r,num); else&#123; tmp+=tr[tr[t2].rs].sum-tr[tr[t1].rs].sum; query(tr[t1].ls,tr[t2].ls,l,mid,num-t); &#125;&#125; Ê∏ÖÁ©∫‰∏ªÂ∏≠Ê†ëÔºö12tot=0;//rt[]Âíåtr[]ÈáåÁöÑ‰∏úË•øÈÉΩ‰ºöÈáçÊñ∞Âä†]]></content>
      <tags>
        <tag>‰∏ªÂ∏≠Ê†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄêÂ≠¶‰π†Á¨îËÆ∞„Äëfx treap]]></title>
    <url>%2F2018%2F11%2F08%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91fx%20treap%2F</url>
    <content type="text"><![CDATA[treapÊúâÁÇπÈöæÂÜôÂïäfx treapÂ•ΩÔºÅÔºàÊ≤°ÊúâÂºïÁî®ÔºÅÔºâÈÇ£‰πàÂ∏∏Êï∞Â§ß‰πüÊ≤°‰ªÄ‰πàÂäûÊ≥ï„ÄÇ„ÄÇ fx treapÁöÑ‰∏ª‰ΩìÔºö1234int rt,tot;struct node&#123; int ls,rs,val,pri,sz;&#125;fx[N]; ÔºàÂÅáÂ¶ÇË¶ÅÂÜôÂ§öÈ¢óÂπ≥Ë°°Ê†ëÔºåÊääËøô‰∏™‰∏úË•øÂ∞ÅË£Ö‰∏Ä‰∏ãÂ∞±Â•Ω‰∫ÜÔºârtÔºöËøôÈ¢óÊ†ëÁöÑÊ†πÁöÑÁºñÂè∑totÔºöÊÄªÁÇπÊï∞ÔºàÂà†Èô§ÁöÑÁÇπ‰∏ç‰ºöÊ∂àÂ§±ÔºåÂè™ÊòØÂÆÉÁöÑÁºñÂè∑‰∏çÂÜçË¢´‰ΩøÁî®‰∫ÜÔºâlsÔºöÂ∑¶Â≠©Â≠êrsÔºöÂè≥Â≠©Â≠êvalÔºöÂÖ≥ÈîÆÁ†ÅÔºàÂπ≥Ë°°Ê†ëÂ≠òÁöÑÂÄºÔºâpriÔºöÈöèÊú∫ÁöÑ‰ºòÂÖàÁ∫ßÊØîËæÉÂÄºszÔºöÁÇπÊï∞ÔºàÁõ∏ÂêåÁöÑÂÄºÂπ∂Ê≤°ÊúâÂêàÂπ∂Âà∞‰∏ÄËµ∑Ôºâ Âä†ÂÖ•‰∏Ä‰∏™Êñ∞ÁöÑÁÇπÔºö123456789101112131415int seed=233;inline int ra()//ÂèØ‰ª•‰∏çÈáçÂ§çÁöÑÁîüÊàê1~INT_MAX-1ÁöÑÊØè‰∏Ä‰∏™Êï∞&#123; seed=48271ll*seed%INT_MAX; return seed;&#125;inline int new_node(int x)&#123; ++tot; fx[tot].sz=1; fx[tot].val=x; fx[tot].pri=ra(); fx[tot].ls=fx[tot].rs=0; return tot;&#125; Êõ¥Êñ∞ËäÇÁÇπÁöÑ‰ø°ÊÅØÔºöÔºàÊõ¥Êîπ‰∫ÜÊ†ëÁöÑÁªìÊûÑÁöÑÊó∂ÂÄôÈúÄË¶ÅÊõ¥Êñ∞Ôºåfx treapÈúÄË¶ÅÂú®mergeÂíåsplitÁöÑÊó∂ÂÄôÊõ¥Êñ∞Ôºâ12345inline void pushup(int x)&#123; fx[x].sz=fx[fx[x].ls].sz+fx[fx[x].rs].sz+1; /* more */&#125; ÂêàÂπ∂(merge)‰∏§È¢ófxÔºåË¶ÅÊ±ÇÂ∑¶ËæπÁöÑfxÁöÑÊØè‰∏™ÁÇπÁöÑÂÖ≥ÈîÆÁ†ÅÂ∞è‰∫éÂè≥ËæπÁöÑfxÁöÑÊØè‰∏™ÁÇπÁöÑÂÖ≥ÈîÆÁ†Å1234567891011121314inline int merge(int x,int y)&#123; if(!x||!y) return x+y; if(fx[x].pri&lt;fx[y].pri)&#123; fx[x].rs=merge(fx[x].rs,y); pushup(x); return x; &#125; else&#123; fx[y].ls=merge(x,fx[y].ls); pushup(y); return y; &#125;&#125; ÂàÜË£Ç(split)‰∏ÄÈ¢ófxÔºåÂèØ‰ª•ÊåâÂÄºÂàÜË£ÇÔºå‰πüÂèØ‰ª•ÊåâÊéíÂêçÂàÜË£ÇÔºåËøôÈáåÂ∞ÜÈîÆÂÄº&lt;=xÁöÑÂàÜÊàêÂ∑¶Ê†ëÔºåÂÖ∂‰ΩôÂàÜÊàêÂè≥Ê†ësplitÊìç‰Ωú‰ºöÂæóÂà∞‰∏§‰∏™ÂÄºÔºårt_lË°®Á§∫Â∑¶Ê†ëÁöÑÊ†πÁöÑÁºñÂè∑Ôºårt_rË°®Á§∫Âè≥Ê†ëÁöÑÊ†πÁöÑÁºñÂè∑ÔºàËøôÊ†∑ÂÜôÊ≤°ÊúâËøîÂõûÂÄºÔºåÊ≥®ÊÑèËøô‰∏§‰∏™ÂÄºÁöÑÂèòÂåñÔºåË¶ÅÂç≥Êó∂ÁöÑÊääÂÄºÂ≠ò‰∏ãÊù•ÔºåÊØèÊ¨°split‰πãÂêé‰ªñ‰ª¨ÁöÑÂÄºÂ∞±Âèò‰∫ÜÔºâ12345678910111213141516171819int rt_l,rt_r;inline void split(int rt,int x)&#123; if(!rt)&#123; rt_l=rt_r=0; return; &#125; if(fx[rt].val&gt;x)&#123; split(fx[rt].ls,x); fx[rt].ls=rt_r; rt_r=rt; &#125; else&#123; split(fx[rt].rs,x); fx[rt].rs=rt_l; rt_l=rt; &#125; pushup(rt);&#125; Êã•Êúâ‰∫ÜmergeÂíåsplitÁöÑfx treapÔºå‰ªçÁÑ∂Êã•ÊúâtreapÁöÑ‰∏ÄÂàáÊÄßË¥®Ôºå‰ªçÁÑ∂ÂèØ‰ª•‰ΩøÁî®treapÁöÑ‰∏ÄÂàáÂáΩÊï∞fx treapÁã¨Áâπ‰πãÂ§ÑÂú®‰∫éÔºåÂÆÉÊäõÂºÉ‰∫ÜÊóãËΩ¨Êìç‰ΩúÔºåÈÇ£‰πàtreapÁöÑinsertÂíådeleteÂ∞±‰∏çÈÄÇÁî®‰∫éfx treap‰∫ÜÔºàÂè™ÊúâËøô‰∏§‰∏™Êìç‰ΩúÊòØÈúÄË¶ÅzagÂíåzigÁöÑÔºâÊèíÂÖ•Ôºö12345inline void inser(int x)&#123; split(rt,x); rt=merge(merge(rt_l,new_node(x)),rt_r);&#125; Âà†Èô§Ôºö1234567inline void delet(int x)&#123; split(rt,x); int tmp=rt_r; split(rt_l,x-1); rt=merge(merge(rt_l,merge(fx[rt_r].ls,fx[rt_r].rs)),tmp);&#125; Áü≠Â∞èÁ≤æÊÇçÔºåÈÇ£‰πàÂÖ∂‰ªñÊìç‰Ωú‰πüÂèØ‰ª•ËÄÉËôëÁî®fxÁâπÊúâÁöÑmergeÂíåsplitÊù•ÂÆåÊàêÔºàÂ∏∏Êï∞Â§ßÔºâÊ±ÇÈîÆÂÄº‰∏∫xÁöÑÊúÄÂ∞èÊéíÂêçÔºàÁõ∏ÂêåÁöÑ‰∏çÁÆóÔºâÔºö1234567inline int rank(int x)//rankÂú®c++11‰∏≠ÊòØÂÖ≥ÈîÆÂ≠ó&#123; split(rt,x-1); int ans=fx[rt_l].sz+1; rt=merge(rt_l,rt_r); return ans; &#125; Ê±ÇÊéíÂêçÁ¨¨kÁöÑÈîÆÂÄºÔºö//Âπ∂‰∏çËÉΩ‰ºòÂåñËøô‰∏™ËøáÁ®ã„ÄÇ„ÄÇ1234567891011121314inline int kth(int rt,int k)&#123; if(k&gt;fx[rt].sz) return -1; while(1)&#123; if(k==fx[fx[rt].ls].sz+1) return rt; if(k&lt;=fx[fx[rt].ls].sz)&#123; rt=fx[rt].ls; &#125; else&#123; k-=fx[fx[rt].ls].sz+1; rt=fx[rt].rs; &#125; &#125;&#125; Ê±ÇÂâçÈ©±ÂêéÁªßÔºö1234567891011121314151617181920212223242526inline int get_pre(int x)&#123; int ans; split(rt,x-1); if(!rt_l)&#123; ans=-INT_MAX; &#125; else&#123; ans=fx[kth(rt_l,fx[rt_l].sz)].val; &#125; rt=merge(rt_l,rt_r); return ans;&#125;inline int get_nxt(int x)&#123; int ans; split(rt,x); if(!rt_r)&#123; ans=INT_MAX; &#125; else&#123; ans=fx[kth(rt_r,1)].val; &#125; rt=merge(rt_l,rt_r); return ans;&#125; Ê∏ÖÁ©∫Ôºö1rt=tot=0;]]></content>
      <tags>
        <tag>Âπ≥Ë°°Ê†ë</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F23%2F18-10-23%E5%AD%A6%E6%A0%A1%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[18-10-23Â≠¶Ê†°Ê®°ÊãüËµõorz djqÁ¨¨‰∏ÄÈ¢ò101ÊòØ4‰ΩçÂæ™ÁéØÁöÑÂõ†‰∏∫9999ÊòØ101ÁöÑÂÄçÊï∞10000=1(mod 101)Êª°Ë∂≥gcd(x,10)=1ÁöÑÊï∞ÈÉΩÊúâËøôÊ†∑ÁöÑÂæ™ÁéØÂõ†‰∏∫10^phi(x)=1(mod x)ÊúÄÂ∞èÁöÑÂæ™ÁéØË¶ÅÊûö‰∏æphi(x)ÁöÑÂõ†Êï∞Ê±Çphi(x)ÊòØÊ†πÂè∑ÁöÑÔºàÁõ¥Êé•Êö¥Âäõ‰ªé2Âà∞sqrtÔºåÊØè‰∏™Âú∞ÊñπÈÉΩ‰∏çÂÅúÁöÑÈô§Âç≥ÂèØ Êú¨È¢òdp[i][j][p][q]Ë°®Á§∫Âå∫Èó¥[i,j]ÂÜÖÊ®°101‰∏∫p‰ΩçÊï∞Ê®°4‰∏∫qÁöÑÂ≠êÂ∫èÂàó‰∏™Êï∞Ê≥®ÊÑèÂàùÂßãÊÉÖÂÜµÔºåÈïøÂ∫¶‰∏∫1ÂíåÊúâ‰∏§‰∏™Áõ∏ÂêåÁöÑ‰∏∫1ËΩ¨ÁßªË¶ÅÂ∞èÂ∞èÁöÑÂÆπÊñ•‰∏Ä‰∏ãdp[i][j][p][q]+=dp[i+1][j][p][q]+dp[i][j-1][p][q]-dp[i+1][j-1][p][q]ËøòÊòØÊúâÁÇπÂº±ÂïäÔºàÂàùÂßãÊÉÖÂÜµÂíåËΩ¨ÁßªÂÆπÊñ•Ôºâ Á¨¨‰∫åÈ¢ò‰∏çËÄÉËôëÊòØxÁöÑÂ§öÂ∞ëÂÄçÂè™ËÄÉËôëÂÆÉÊòØxÁöÑÂÄçÊï∞ÈÇ£Â∞±ÊåâÊ®°xÁöÑÂÄºÊù•ÊêûËøûËæπÂèòÊàê01bfs 01bfsÊöëÂÅázrËÆ≤‰∫ÜÂïäÔºàÂèØÊòØÊàëÊ≤°Âê¨ÂïäËøû0ÁöÑËæπÂ∞±Âä†Âà∞ÈòüÂ§¥Ëøû1ÁöÑËæπÂ∞±Âä†Âà∞ÈòüÂ∞æÈòüÂàóÊó∂ÂàªÈÉΩ‰∏ç‰ºöË∂ÖËøá2ÁßçÂÄºÔºàxÂíåx+1ÊàñËÄÖÂè™ÊúâxÔºâÊØè‰∏™ÁÇπÊúÄÂ§öÂÖ•Èòü‰∏§Ê¨°ÔºàÂÖà1ÂÜç0ÁöÑÊÉÖÂÜµÔºâ‰∏îÊ∞∏ËøúÊòØÁî®ÊúÄÂ∞èÂÄºÂÖàÊù•Êõ¥Êñ∞ÂèØ‰ª•‰∏çÁî®ËÆ∞ÂΩïÂá∫Áé∞ÊúÄÂ∞èÂÄºÁöÑvisÊï∞ÁªÑÔºàÁ±ª‰ººdijkÁöÑvisÔºâ Á¨¨‰∏âÈ¢òÁª¥Êä§Ê†ë‰∏äÂπ∂Êü•ÈõÜ‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πà80.„ÄÇLLÂÜôÊàêintÊääÂèòÈáèÊîπÊàêLL‰ª•ÂêéË¶ÅÊü•ÂÖ®ÊñáÔºÅÔºÅ]]></content>
  </entry>
  <entry>
    <title><![CDATA[ÂõæËÆ∫]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%9B%BE%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[Ê±ÇÂâ≤ËæπÊ±ÇÈîô‰∫ÜQWQÂÜô‰∏ÄÁØáË∑ütarjanÊúâÂÖ≥ÁöÑÊÄªÁªì ÊúâÂêëÂõæÔºöÊ±ÇÂº∫ËøûÈÄöÂàÜÈáèÔºöÈáçËæπ„ÄÅËá™ÁéØÈÉΩ‰∏çÂΩ±ÂìçÊ±ÇËß£ÔºåËÆ∞ÂΩïfaÔºåË¶ÅÂÜôÊ†àÊ±ÇÂâ≤ËæπÔºöÊú™ÂÆö‰πâÂâ≤ËæπÔºåË¶ÅÊ†πÊçÆÈ¢òÁõÆËΩ¨ÂåñÊàêÊó†ÂêëÂõæÂÅöÔºàÂèØËÉΩÂêßÔºâÊ±ÇÂâ≤ÁÇπÔºöÊú™ÂÆö‰πâÂâ≤ÁÇπÔºåË¶ÅÊ†πÊçÆÈ¢òÁõÆËΩ¨ÂåñÊàêÊó†ÂêëÂõæÂÅöÔºàÂèØËÉΩÂêßÔºâ Êó†ÂêëÂõæÔºöÊ±ÇÂâ≤ËæπÔºöËá™ÁéØÊó†ÂΩ±ÂìçÔºåÈáçËæπÊúâÂΩ±ÂìçÔºåË¶ÅËÆ∞ÂΩïÊòØ‰ªéÂì™Êù°ËæπÊù•ÁöÑÔºåËÄå‰∏çÊòØËÆ∞ÂΩïfaÔºå‰∏çË¶ÅÂÜôÊ†àdfn[x]&lt;low[x]ÔºåÊâÄ‰ª•‰∏çËÉΩÁî®faÊõ¥Êñ∞Ê±ÇÂâ≤ÁÇπÔºöËá™ÁéØ„ÄÅÈáçËæπÊó†ÂΩ±ÂìçÔºå‰∏çÁî®ËÆ∞ÂΩïfaÔºå‰∏çË¶ÅÂÜôÊ†à„ÄÇÊ≥®ÊÑèÊ†πËäÇÁÇπ„ÄÇdfn[x]&lt;=low[x]ÔºåÊâÄ‰ª•ÂèØ‰ª•Áî®faÊõ¥Êñ∞]]></content>
      <tags>
        <tag>ÂõæËÆ∫</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ê†ë‰∏äËÉåÂåÖ]]></title>
    <url>%2F2018%2F09%2F26%2F%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Âú®Ê†ë‰∏äÊâækÊù°ÁÇπ‰∏çÁõ∏‰∫§ÁöÑË∑ØÂæÑ‰ΩøÂæóÊùÉÂÄºÂíåÊúÄÂ§ßÔºà‰∏Ä‰∏™ÁÇπÁÆó‰∏ÄÊù°ÈÄÄÂåñÁöÑË∑ØÂæÑÔºâ‰∏çËÉΩÂè™Áî®0/1Ë°®Á§∫Ôºà0Ë°®Á§∫‰∏çËÉΩÂæÄ‰∏äÔºå1Ë°®Á§∫ËÉΩÂæÄ‰∏äÔºâÔºåÊúâÂùëÔºåÂêàÂπ∂ÁöÑÊó∂ÂÄô‰∏çÁü•ÈÅì‰∏äÈù¢ÁöÑ0ÊúâÊ≤°ÊúâÁÆó‰∏ÄÊù°Ë∑ØÂæÑÔºÅÔºÅ Áî®0/1/2ÂÜôÔºåÂ∞Ü0/1/2ÁöÑmaxÂ≠òÂà∞0‰∏≠ÔºåËøôÊòØÈîôÁöÑÔºåË∞ÉÁî®0ÁöÑÊó∂ÂÄô‰ºöÊåÇÔºàÊï∞ÊçÆÂº±Êãø‰∫Ü50/60Ôºâ‰∏≠ÈÄîÁûéÊîπÊîπÂØπ‰∫Ü„ÄÇ„ÄÇÔºàÊäät[1][0]ËµãÂàùÂÄº-infËÄå‰∏çÊòØ0ÔºåÈÄâ‰∏Ä‰∏™ÂçïÁÇπÁöÑÊÉÖÂÜµËÆ§‰∏∫ÂêëÂ≠©Â≠êËøû‰∫Ü2Êù°ËæπÔºâÔºà‰ΩÜÊòØÂπ∂Ê≤°ÊúâËøÖÈÄüË∞ÉÂØπÊòØÂõ†‰∏∫ÂâçÈù¢Êää0/1/2ÂÖ®ÈÉ®ÂèñmaxÂπ∂Âà∞0‰∫ÜÔºåÈ¢òËß£ËØØÂØºÂïäÔºÅÔºâ$f[x][j][0/1/2]$Ë°®Á§∫Âú®xÂèäÂÖ∂Â≠êÊ†ë‰∏≠ÈÄâ‰∫ÜjÊù°Ë∑ØÂæÑÔºåxÂêëÂÆÉÁöÑÂ≠©Â≠êËøûÂá∫0/1/2Êù°ËæπÔºåe[i].fÊòØËæπÊùÉyÊòØxÁöÑ‰∏Ä‰∏™Â≠©Â≠êÔºå$t[j][0/1/2]$Ë°®Á§∫ÂΩìÂâçÂêàÂπ∂ÁöÑÂ≠êÊ†ë$f[][][]=-inf,f[x][0][0]=f[x][1][1]=f[x][1][2]=0$$t[][]=-inf,t[0][0]=t[1][1]=t[1][2]=0$$t[j][0]=max(t[j][0],f[x][j-p][0]+max(f[y][p][0],f[y][p][1],f[y][p][2]))$$t[j][1]=max(t[j][1],f[x][j-p][1]+max(f[y][p][0],f[y][p][1],f[y][p][2]),f[x][j-p][0]+f[y][p][1]+e[i].f)$$t[j][2]=max(t[j][2],f[x][j-p][2]+max(f[y][p][0],f[y][p][1],f[y][p][2]),f[x][j-p][1]+f[y][p][1]+e[i].f)$ Âò§Âò§Âò§Âò§ËøôÈ¢ò‰∏çÂ§™‰∏ÄÊ†∑‰∏çË¶ÅÊ±ÇË∑ØÂæÑ‰∏™Êï∞ÊâÄ‰ª•Âè™ÈúÄË¶Å0/1Ë°®Á§∫Ë∑üÊúâÊ≤°ÊúâÈÄâÂèØ‰ª•ÈÄöËøásumÂ∑ßÂ¶ôÁöÑËΩ¨ÁßªÂà∞1ËÄåÁ°ÆÂÆöË∑ØÂæÑÊï∞ÈáèÁöÑÂ∞±‰∏çÂ•ΩËøô‰πàÂÅöÔºà‰∏çËÉΩÊéßÂà∂sumÈÄâ‰∫ÜÂ§öÂ∞ëÔºåÂèØËÉΩËøòÈúÄË¶Å‰∏Ä‰∏™ËÉåÂåÖÔºâ]]></content>
      <tags>
        <tag>Ê†ë‰∏äËÉåÂåÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-9-18Â≠¶Ê†°Ê®°ÊãüËµõ]]></title>
    <url>%2F2018%2F09%2F19%2F18-9-18%E5%AD%A6%E6%A0%A1%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[ËØ•ÊñáË¢´ÂØÜÁ†Å‰øùÊä§Á¨¨‰∏ÄÈ¢òÔºöÂçöÂºà(tc srm 664a)„ÄêÈóÆÈ¢òÊèèËø∞„Äëùê¥ùëêùëíùë†ùëüùëêÁöÑÂ•ΩÊúãÂèãùëîùëñùë†ùëùùëßùëóùëßÊúÄËøëËø∑‰∏ä‰∫Ü‰∏Ä‰∏™Ê∏∏ÊàèÔºÅ‰Ωú‰∏∫ùëîùëñùë†ùëùùëßùëóùëßÁöÑÁü•ÂøÉÂ•ΩÂèãÔºåùê¥ùëêùëíùë†ùëüùëêÂÜ≥ÂÆöÂíåùëîùëñùë†ùëùùëßùëóùëß ÊâìÊâìÊ∏∏ÊàèÔºåÊ≤üÈÄöÊ≤üÈÄöÊÑüÊÉÖ„ÄÇÂàùÂßãùê¥ùëêùëíùë†ùëüùëêÂíåùëîùëñùë†ùëùùëßùëóùëßÂêÑËá™Êúâ‰∏Ä‰∏™Êï∞a,bÔºåËøô‰∏™Ê∏∏ÊàèÂ∞ÜËøõË°åkËΩÆÔºåÊØè‰∏ÄËΩÆÊ∏∏Êàè‰ºöÊúâ‰∏ãÈù¢ÁöÑ‰∫ãÊÉÖÂèëÁîüÔºöÂÅáËÆæa ‚â§ bÔºåÊàë‰ª¨‰ª§b = b ‚àí a,a = a + aÔºõÂ¶ÇÊûúb &lt; aÔºåÂàôa = a ‚àí b,b = b + b„ÄÇÁé∞Âú®ùëîùëñùë†ùëùùëßùëóùëßÊÉ≥Áü•ÈÅìÔºåkËΩÆÊ∏∏ÊàèÂêéÔºåmin(a,b)ÊòØÂ§öÂ∞ë„ÄÇ„ÄêËæìÂÖ•Ê†ºÂºè„Äë‰ªéÊñá‰ª∂game.in‰∏≠ËØªÂÖ•Êï∞ÊçÆ„ÄÇÁ¨¨‰∏ÄË°å‰∏â‰∏™Êï∞ÔºåË°®Á§∫a,b,k„ÄÇ„ÄêËæìÂá∫Ê†ºÂºè„ÄëËæìÂá∫Âà∞Êñá‰ª∂game.out‰∏≠„ÄÇ‰∏ÄÂÖ±‰∏ÄË°åÔºåÂåÖÂê´‰∏Ä‰∏™Êï¥Êï∞ÔºåË°®Á§∫Á≠îÊ°à„ÄÇ„ÄêÊ†∑‰æãËæìÂÖ•1„Äë2 3 5„ÄêÊ†∑‰æãËæìÂá∫1„Äë1„ÄêÊ†∑‰æãËæìÂÖ•2„Äë955 812 828145516„ÄêÊ†∑‰æãËæìÂá∫2„Äë167„ÄêÊ†∑‰æãËæìÂÖ•3„Äë955253431 806956091 857954„ÄêÊ†∑‰æãËæìÂá∫3„Äë553642420„ÄêÊï∞ÊçÆËßÑÊ®°„ÄëÂØπ‰∫é20% ÁöÑÊï∞ÊçÆÔºåa,b ‚â§ 1000„ÄÇÂØπ‰∫é40% ÁöÑÊï∞ÊçÆÔºåa,b ‚â§ 106„ÄÇÂØπ‰∫é60% ÁöÑÊï∞ÊçÆÔºåa,b ‚â§ 108„ÄÇÂØπ‰∫éÂè¶20% ÁöÑÊï∞ÊçÆÔºåk ‚â§ 107„ÄÇÂØπ‰∫é100% ÁöÑÊï∞ÊçÆÔºå1 ‚â§ a,b,k ‚â§ 109„ÄÇ ÊòæÁÑ∂a+bÊòØÂÆöÂÄºÔºå‰ª§n=a+bËã•a&lt;=bÔºåa‚Äô=2aËã•a&gt;bÔºåa‚Äô=a-b=2a-(a+b)=2a-nÊâÄ‰ª•Â∞±ÊòØÂú®Ê®°nÊÑè‰πâ‰∏ã‰πò2ÁöÑkÊ¨°Êñπ„ÄÇ ÊÄùÁª¥Â•ΩÈ¢ò„ÄÇÊàëÂèëÁé∞‰∫Üa+bÊòØÂÆöÂÄºÔºåÁÑ∂ÂêéÂºÄÂßãËÄÉËôëÂë®Êúü„ÄÇ„ÄÇÊâÄ‰ª•ËØ¥ÂØπÁß∞ÊÄßÂæàÈáçË¶ÅÔºÅÔºÅÔºàËøòÊúâÂçïË∞ÉÊÄß‰πãÁ±ªÁöÑ„ÄÇÔºâ Á¨¨‰∫åÈ¢òÔºö(cf 446B)Áªô‰∏Ä‰∏™ùëÅ√óùëÄÁöÑÁü©ÈòµÔºåÂÖ±ùêæÊ¨°Êìç‰ΩúÔºåÊØèÊ¨°ÊåëÈÄâ‰∏ÄË°åÊàñËÄÖ‰∏ÄÂàóÔºåÂ∞ÜÂÖ∂‰∏≠ÁöÑÂÖÉÁ¥†ÂÖ®ÈÉΩÂä†Âà∞Á≠îÊ°à‰∏≠ÔºåÂπ∂‰∏îÊØè‰∏™ÂÖÉÁ¥†ÁöÑÂÄº‚àíùëÉ„ÄÇÈóÆÁ≠îÊ°àÊúÄÂ§ßÊòØÂ§öÂ∞ë„ÄÇ ÊòæÁÑ∂Ë°åÂàóÁã¨Á´ãÔºàÂèñÂ§öÂ∞ëË°å‰πü‰∏ç‰ºöÂΩ±ÂìçËØ•ÊÄé‰πàÂèñÂàóÔºâÈ¢ÑÂ§ÑÁêÜÂèñkË°åÁöÑÊúÄÂ§ßÂÄºÔºåÂèñkÂàóÁöÑÊúÄÂ§ßÂÄºÁÑ∂ÂêéÊûö‰∏æË°åÂèñÂ§öÂ∞ëÔºåÊõ¥Êñ∞Á≠îÊ°àÂç≥ÂèØO(klogn)Ë°åÂàó‰∏ÄËµ∑ËÄÉËôëÈöè‰æøÂèç‰æã Á¨¨‰∏âÈ¢òÔºöÁªôÂÆöùëÅ‰∏™Âå∫Èó¥[ùëôùëñ, ùëüùëñ]Ôºå‰Ω†ÂèØ‰ª•ÈÄâÂá∫ÂÖ∂‰∏≠Ëã•Âπ≤‰∏™Âå∫Èó¥ÔºåËÆæ‰∏∫ùë°ùëúùë°‰∏™Ôºõ‰ª§ùë•‰∏∫Ëøôùë°ùëúùë°‰∏™Âå∫Èó¥ÁöÑ‰∫§„ÄÇÊ±Çmin(ùë•, ùë°ùëúùë°)ÁöÑÊúÄÂ§ßÂÄº„ÄÇËåÉÂõ¥ÔºöùëÅ ‚â§ 300000Ôºå1 ‚â§ ùëôùëñ ‚â§ ùëüùëñ ‚â§ ùëÅ„ÄÇ ÊòæÁÑ∂Âå∫Èó¥ÁöÑ‰∫§ÊòØËøûÁª≠ÁöÑÊ≥®ÊÑèÂà∞Âå∫Èó¥Ë∂äÈïøÔºå‰∏™Êï∞Ë∂äÂ∞ëÊÉ≥Âà∞‰∫åÂàÜÂå∫Èó¥ÈïøÂ∫¶Êûö‰∏æÂ∑¶Á´ØÁÇπÊØèÊ¨°ÂùáÊëäO(1)ÁöÑÊèíÂÖ•Âå∫Èó¥ÔºàËÄÉËØïÊó∂Êù•‰∏çÂèäÂ∞±ÂÜôO(n)Âà§„ÄÇ„ÄÇÔºâ ÊàñËÄÖÊûö‰∏æÂ∑¶Á´ØÁÇπÔºåÊ≥®ÊÑèÂà∞ÈöèÁùÄÂè≥Á´ØÁÇπÁöÑÂè≥ÁßªÔºåÂå∫Èó¥ÈïøÂ∫¶ÂèòÂ§ßÔºå‰∏™Êï∞ÂèòÂ∞è„ÄÇÈÇ£Â∞±‰∫åÂàÜÂëóÔºåÂèëÁé∞ËøòË¶ÅÁÆóË¶ÜÁõñÂÆÉÁöÑÂå∫Èó¥‰∏™Êï∞ÊÑüËßâËøòË¶Å‰∏Ä‰∏™logÂú®Á∫øÊÆµÊ†ë‰∏äÊ±ÇËøô‰∏™ÂÄºËØ∂ÔºüÁ∫øÊÆµÊ†ë‰∏äÊ±ÇÂÄºÔºåÊâÄ‰ª•Á∫øÊÆµÊ†ë‰∫åÂàÜ ÂèëÁé∞ËøôÈ¢ò‰∏çÁÆ°ÊòØÊåâÈïøÂ∫¶ËøòÊòØÊåâ‰ΩçÁΩÆÈÉΩÊúâÂçïË∞ÉÊÄßËØ¥ÊòéËøôÈ¢òÁöÑÊÄßË¥®ÂæàÂº∫ÂïäÂèëÁé∞two pointers‰πüËÉΩÂÅöÊâÄ‰ª•ËØ¥ÂçïË∞ÉÊÄßÂæàÈáçË¶ÅÔºÅÔºÅÔºàËøòÊúâÂØπÁß∞ÊÄß‰πãÁ±ªÁöÑ„ÄÇÔºâ]]></content>
      <tags>
        <tag>Ê®°ÊãüËµõ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄêÂ≠¶‰π†Á¨îËÆ∞„ÄëÂèØÂπ∂Â†Ü]]></title>
    <url>%2F2018%2F09%2F17%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8F%AF%E5%B9%B6%E5%A0%86%2F</url>
    <content type="text"><![CDATA[Â•Ω‰πÖÊ≤°ÂÜôÁ¨îËÆ∞‰∫ÜÂèØÂπ∂Â†ÜÊòØ‰∏™ÁÆÄÂçïÂ•ΩÁî®ÔºàÂ•ΩÂÜôÔºâÁöÑÊï∞ÊçÆÁªìÊûÑÂÅö‰∫ÜÂá†ÈÅìÊ∞¥È¢òluogu2713 ÁΩóÈ©¨Ê∏∏Êàèluogu3377 „ÄêÊ®°Êùø„ÄëÂ∑¶ÂÅèÊ†ëÔºàÂèØÂπ∂Â†ÜÔºâluogu3066 [Usaco2012 Dec]Running Away From the Barn ÂèØÂπ∂Â†ÜÁöÑÊ†∏ÂøÉÂ∞±ÊòØ‰øùÊåÅÊ∑±Â∫¶ÔºàË¶ÅËÇ§ÊµÖÔºÅÔºâÊúÄÊó†ËÑëÁöÑÊñúÂ†ÜÂ∞±ÊòØÊØèÊ¨°Â∞ÜÂ∑¶Âè≥Â≠©Â≠ê‰∫§Êç¢Ôºå‰ΩÜËøôÊòØÂùáÊëälogÁöÑÔºà‰∏ç‰ºöËØÅÂïäÔºâ‰πüÂèØ‰ª•ÈöèÊú∫‰∫§Êç¢Ôºàrand()&amp;1Ôºâ‰ºòÁßÄÔºàÂèØÊåÅ‰πÖÂåñÔºâÁöÑÂÅöÊ≥ïÊòØÁª¥Êä§‰∏Ä‰∏™distÔºåË°®Á§∫Ëøô‰∏™ÁÇπÂêëÂè≥ËÉΩËµ∞ÁöÑË∑ùÁ¶ªË¶ÅÊ±ÇÊª°Ë∂≥dist_left&gt;=dist_right,dist=dist_right+1ÂÆπÊòìËØÅÊòéÊòØlogÁöÑÔºåËøôÂ∞±ÊòØÂ∑¶ÂÅèÊ†ëÔºàÂõ†‰∏∫ÂêëÂ∑¶ÂÅèÔºåÊñúÂ†Ü‰πüÊòØÂêëÂ∑¶ÂÅèÁöÑ„ÄÇ„ÄÇÔºâ ÂÆûÊµãÊÑüËßâÊñúÂ†ÜË∑ëÂæóÊúÄÂø´ÔºàÊï∞ÊçÆ‰∏çÂ§ü‰ºòÁßÄÔºü) Âá†‰∏™ÈîôËØØÔºö‰∏çËÉΩmerge‰∏§‰∏™Â§Ñ‰∫éÂêå‰∏Ä‰∏™Â†ÜÈáåÁöÑ‰∏úË•øÔºÅÔºà‰ºöÁøªÂÄçËØ∂Ôºâswap(x,y)ËÄå‰∏çÊòØswap(t[x],t[y])ÔºåÂõ†‰∏∫Ë¶Å‰øùËØÅÁºñÂè∑ÂíåÂÄºÂØπÂ∫îÔºÅ luogu2475 [SCOI2008]ÊñúÂ†ÜÔºàÂÖ≥‰∫éÊñúÂ†ÜÁöÑ‰∏Ä‰∫õÊÄßË¥®Ôºå‰∫ÜËß£‰∏Ä‰∏ãÔºâËΩ¨Ëá™MATO IS NO.1ËÄÉËôëÊñúÂ†Ü‰∏≠ÊúÄÂêéÊèíÂÖ•ÁöÑÈÇ£‰∏™ÁªìÁÇπÔºåÂÆπÊòìÂèëÁé∞ÔºöÔºà1ÔºâÂÆÉ‰∏ÄÂÆöÊòØ‰∏Ä‰∏™ÊûÅÂ∑¶ÁªìÁÇπÔºàÂ∞±ÊòØ‰ªéÊ†πÂæÄÂÆÉÁöÑË∑Ø‰∏ä‰∏ÄÁõ¥ÈÉΩÊòØÊ≤øÁùÄÂ∑¶ÈìæËµ∞ÔºâÔºåÂõ†‰∏∫ÊèíÂÖ•ÁöÑÊó∂ÂÄôÊØèÊ¨°ÈÉΩÊòØÊèíÂÖ•Âà∞Â∑¶Â≠êÊ†ë‰∏≠ÔºõÔºà2ÔºâÂÆÉ‰∏ÄÂÆöÊú®ÊúâÂè≥Â≠êÊ†ëÔºåÂõ†‰∏∫ÊèíÂÖ•ÁöÑÊó∂ÂÄôÊØèÊ¨°ÈÉΩÊòØÊääÂéüÊù•ÁöÑÊüêÊ£µÂ≠êÊ†ë‰Ωú‰∏∫Êñ∞ÁªìÁÇπÁöÑÂ∑¶Â≠êÊ†ëÔºõ Êª°Ë∂≥Ôºà1ÔºâÔºà2ÔºâÁöÑÁªìÁÇπÂèØËÉΩÊúâÂ§ö‰∏™Ôºå‰ΩÜÁ¥ßÊé•ÁùÄÂèØ‰ª•ÂèëÁé∞ÔºåËøô‰∏™ÊñúÂ†Ü‰∏≠ÁöÑÊØè‰∏™ÁªìÁÇπÂ¶ÇÊûúÊú®ÊúâÂ∑¶Â≠êÁªìÁÇπÔºåÈÇ£‰πà‰πüÊú®ÊúâÂè≥Â≠êÁªìÁÇπÔºàÊàñËÄÖËØ¥ÔºåÊØè‰∏™ÈùûÂè∂ÁªìÁÇπÈÉΩÊúâÂ∑¶Â≠êÊ†ëÔºâÔºåËÄåÂú®ÊèíÂÖ•‰∏Ä‰∏™ÁªìÁÇπ‰πãÂâçÔºåÂÖ∂ÊâÄÊúâÁöÑÁ•ñÂÖàÈÉΩË¢´‰∫§Êç¢‰∫ÜÂ∑¶Âè≥Â≠êÊ†ëÔºåÊâÄ‰ª•ÔºåËã•Êñ∞ÁªìÁÇπÁöÑÁ•ñÂÖà‰∏≠ÊúâÊª°Ë∂≥Ôºà1ÔºâÔºà2ÔºâÁöÑÔºå‰∏îÊñ∞ÁªìÁÇπ‰∏çÊòØÂè∂ÁªìÁÇπÔºåÈÇ£‰πàÂú®Êñ∞ÁªìÁÇπÊèíÂÖ•‰πãÂâçÔºåËøô‰∏™Êª°Ë∂≥Ôºà1ÔºâÔºà2ÔºâÁöÑÁ•ñÂÖàÂøÖÁÑ∂ÊòØÂè™ÊúâÂè≥Â≠êÊ†ëËÄåÊú®ÊúâÂ∑¶Â≠êÊ†ëÁöÑÔºåËøô‰∏é‰∏äÈù¢ÁöÑÈÇ£‰∏™ÊÄßË¥®ÁüõÁõæÔºåÊâÄ‰ª•ÔºåÂèØ‰ª•ÂæóÂá∫ÔºöÊúÄÂêéÊèíÂÖ•ÁöÑÈÇ£‰∏™ÁªìÁÇπ‰∏ÄÂÆöÊòØÊª°Ë∂≥Ôºà1ÔºâÔºà2ÔºâÁöÑÁªìÁÇπ‰∏≠ÔºåÊ∑±Â∫¶ÊúÄÂ∞èÁöÑÈÇ£‰∏™ÔºàËÆæ‰∏∫XÔºâÔºåÈô§ÈùûXÁöÑÂ∑¶Â≠êÁªìÁÇπÊòØÂè∂ÁªìÁÇπÔºåÊ≠§Êó∂‰∏∫‰∫ÜÊª°Ë∂≥Â≠óÂÖ∏Â∫èÊúÄÂ∞èÔºåÂ∫îËØ•ÂèñXÁöÑÂ∑¶Â≠êÁªìÁÇπ‰∏∫ÊúÄÂêéÊèíÂÖ•ÁöÑ„ÄÇÊâæÂà∞Ëøô‰∏™ÊúÄÂêéÊèíÂÖ•ÁöÑÁªìÁÇπ‰ª•ÂêéÔºåÂè™ÈúÄË¶ÅÊääÂÆÉÂà†ÊéâÔºåÂπ∂ÊääÂÆÉÁöÑÊâÄÊúâÁ•ñÂÖà‰∫§Êç¢Â∑¶Âè≥Â≠êÊ†ëÔºåÂ∞±ÊòØÊèíÂÖ•ËØ•ÁªìÁÇπ‰ª•ÂâçÁöÑÁä∂ÊÄÅ‰∫Ü„ÄÇËøôÊ†∑ÂèØ‰ª•ÊâæÂà∞Â≠óÂÖ∏Â∫èÊúÄÂ∞èÁöÑÊèíÂÖ•È°∫Â∫è„ÄÇ]]></content>
      <tags>
        <tag>ÂèØÂπ∂Â†Ü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zrÊ®°ÊãüËµõ]]></title>
    <url>%2F2018%2F09%2F04%2Fzr%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[ËÄÉËØïÁöÑÈ¶ñË¶ÅÁõÆÊ†áÔºöÂæóÈ´òÂàÜÔºÅ‰∏çÂÜôÂØπÊãçÁöÑËØùÔºå‰∏ÄÂçäÊ¶ÇÁéá‰ºöÁÇ∏„ÄÇ ÊèêÈ´òr1Á¨¨‰∏ÄÈ¢òÊâæËßÑÂæãÔºå40minÂÆåÊàêÁ¨¨‰∫åÈ¢òÂü∫ÁéØÂÜÖÂêëÊ†ëÔºåÂÜô‰∫ÜÊå∫‰πÖÔºåÂª∫‰∫ÜÂèçÂêëËæπdfs„ÄÇÂÖ∂ÂÆûÊãìÊâëÊàñËÄÖtarjanÈÉΩË°å„ÄÇ1.5hÊâçÂÜôÂÆåÁ¨¨‰∏âÈ¢òÊ≤°‰ªÄ‰πàÊÄùË∑ØÔºåÊâì‰∫ÜÊö¥Âäõ„ÄÇÊúüÊúõ100+100+50=250ÂÆûÈôÖ100+100+40=240Á¨¨‰∏âÈ¢òÂ∫îËØ•ÊòØn&gt;20ÊòØÁâπÂà§ÔºåÁªìÊûúÂÜôÊàên&gt;100ÔºåÊúâ10ÂàÜt‰∫Ü„ÄÇ t3Ê≠£Ëß£ÔºöÂ∫îËØ•ÊÉ≥Âà∞Âå∫Èó¥dpÔºå‰ΩÜÊòØÂæàÈöæÊÉ≥Âà∞Áª¥Êä§‰ªÄ‰πàÂõ†‰∏∫ÂæàÊùÇ‰π±È¶ñÂÖàË¶ÅÊûö‰∏æÂá∫ÊòØÂì™‰∏™Â≠óÁ¨¶‰∏≤pÔºåÂ§çÊùÇÂ∫¶ $\sum_{len|n}(n-len+1)$ dp[i][j]Ë°®Á§∫ Ëã•j-i+1ÊòØlenÁöÑÂÄçÊï∞ÔºåÂàôdp[i][j]=[ËÉΩÂê¶Ê∂àÂÆå] Ëã•j-i+1‰∏çÊòØlenÁöÑÂÄçÊï∞ÔºåÂàôdp[i][j]=[ÊòØÂê¶ËÉΩÊ∂àÊàêpÁöÑÂâçÁºÄ]ÔºåÊ≥®ÊÑèÂà∞Ëøô‰∏™ÂâçÁºÄÊòØÂõ∫ÂÆöÁöÑÔºåÂèØ‰ª•ÈÄöËøáÈïøÂ∫¶ÁÆóËΩ¨ÁßªÔºö ËÄÉËôëÂæÄÂå∫Èó¥ÂêéÈù¢Âä†‰∏Ä‰∏™Â≠óÁ¨¶Ôºå$dp[i][j]=dp[i][j-1]&amp;s[j]==prefix((j-i)%len+1)$ ËÄÉËôëÂæÄÂå∫Èó¥ÂâçÈù¢Âä†‰∏ÄÊÆµÂ≠óÁ¨¶Ôºå$dp[i][j]=dp[i][j-klen]&amp;dp[j-klen+1][j]$ ËøôÊ†∑Â∞±ÂèØ‰ª•ËÄÉËôëÂà∞ÊâÄÊúâÁöÑÊÉÖÂÜµÔºåÂêëÂêéÂä†‰∏ÄÊÆµÂèØ‰ª•ÈÄöËøá‰∏Ä‰∏™‰∏Ä‰∏™Âä†ÂæóÂà∞ÔºåÂêëÂâçÂä†‰∏Ä‰∏™ÂèØ‰ª•ÈÄöËøáÊîπÂèòiÂæóÂà∞„ÄÇÊ≥®ÊÑèÂàùÂßãÂåñÔºödp[i][i-1]=1ÔºåÂÖ∂‰ªñ‰∏∫0 ÊèêÈ´òr5 18-9-22ÊâæËßÑÂæãÁúüÊúâË∂£ ÊèêÈ´òr7 18-10-13Á¨¨‰∏ÄÈ¢òÁõ∏ÂΩì‰∫é01Ë¶ÜÁõñÈóÆÈ¢òÁÑ∂ËÄåËøô‰∏™ÈóÆÈ¢òÂπ∂‰∏çÂèØÂÅö‰ΩÜÊòØn&gt;=m^2‰∏îÊï∞ÊçÆÈöèÊú∫ÊâÄ‰ª•ÂèØ‰ª•ËÆ§‰∏∫ÂõæÊòØËøûÈÄöÁöÑ„ÄÇ„ÄÇÂç°‰∫Ü2h„ÄÇ„ÄÇ Á¨¨‰∫åÈ¢òÊ†ë‰∏äÈöèÊú∫Ê∏∏Ëµ∞+Ê†ë‰∏äÊúÄÈïøË∑ØÊúÄÂèØÂÅöÁöÑ‰∏ÄÈ¢òÂêßËÄÉÂÆåËØï1minac Á¨¨‰∏âÈ¢òÊï∞Â≠¶+Êé®ÂºèÂ≠ê‰∏çÊòØÂæàÊìÖÈïøÂïäÁúãÂÆåÈ¢òËß£ËßâÂæóÊå∫ÁÆÄÂçïÁöÑÊö¥ÂäõÂÜôÁÇ∏‰∫ÜÂøÉÊÄÅÁàÜÁÇ∏Âä†ÂÜôÁÇ∏ÂØπ1Âíå2ÁöÑÁä∂ÊÄÅÂÜôÈîô‰∫ÜÔºàÂ∞èÁä∂ÊÄÅ‰∏ÄÂÆöË¶ÅÂÜôÂØπÂïäÔºåÈÇ£Â§ßÁä∂ÊÄÅÁöÑÁ®ãÂ∫èË∑ë‰∏Ä‰∏ã‰πüË°åÂïä„ÄÇ„ÄÇÔºâËøòÊúâtarjanÂÜôÁöÑ‰∏ëstÂíåins‰ªÄ‰πàÁöÑÊúÄÂ•ΩÈÉΩÊ∏ÖÁ©∫ÔºÅÔºÅÊï∞ÁªÑ‰∏çË¶ÅÂè™ÂºÄÂ§ß1ÔºÅÔºÅÔºàsta[ta+1]!=xÔºåËøôÊ†∑ÁàÜ‰∫ÜÔºÅÔºÅÔºâ ÊèêÈ´òr8 18-10-20ÂøÉÊÄÅ‰∏çËÉΩÂ¥©ÔºåÊö¥Âäõ‰∏çËÉΩÊåÇ‚ÄòÊâìÂ•ΩÊö¥ÂäõÂ∞±rk10‰∫ÜÔºÅÔºÅ Á¨¨‰∏ÄÈ¢òÊö¥ÂäõÊåÇ+Á¨¨‰∫åÈ¢òÊö¥ÂäõÊåÇËâπ Á¨¨‰∏ÄÈ¢òa[i]ÂÜôÊàêi Á¨¨‰∫åÈ¢òÈÄíÂΩíÁöÑÂèòÈáèÂíåÂÖ®Â±ÄÂèòÈáèÈáç‰∫Ü wtf!ËøôÁßçÈîôËØØÈùôÊÄÅÊü•ÈîôÂ∫îËØ•ËÉΩÊü•Âá∫Êù•ÁöÑÔºÅÔºÅ‰ª•ÂêéÊ®°ÊãüËµõ‰∏çÁÆ°ÊÄéÊ†∑ÈÉΩË¶ÅÈùôÊÄÅÊü•ÈîôÔºåÂåÖÊã¨Êö¥ÂäõÔºÅÔºÅ ÊèêÈ´òr9 18-10-27Á¨¨‰∏ÄÈ¢òËøòÊòØÈÄªËæë‰∏çÂ§ü‰∏•Ë∞®ËØÅÊòéÁöÑ‰∏úË•øËøòÊòØË¶ÅÂÜô‰∏ãÊù•Êâç‰∏•Ë∞®ÂïäÂú®cppÂºÄÂ§¥ÂÜôÂÄíÊòØ‰∏çÈîô Á¨¨‰∫åÈ¢òÂÆπÊñ•ÔºàÊàëÂÆπÊñ•Â•ΩÂ∑ÆÂïä Á¨¨‰∏âÈ¢òÊØíÁò§È¢òÂ•ΩÂ•ΩËØªÈ¢òÔºå‰∏çË¶ÅË¢´ÈïøÈ¢òÈù¢ÂêìÂà∞‰∫Ü ÊôÆËΩ¨Êèêr1 18-9-9Á¨¨‰∏ÄÈ¢ò‰∫åÂàÜÂä†ÊªëÂä®Á™óÂè£Ë¢´Á≤æÂ∫¶Âç°Âà∞Ê≠ªÂØπÊãç‰∫ÜÂ•Ω‰πÖ‰∏çÂÅúÁöÑË∞ÉepsÂÆûÈôÖ‰∏ä‰ªÄ‰πàÈÉΩÊ≤°Âç°„ÄÇ„ÄÇ Á¨¨‰∫åÈ¢òË¥™ÂøÉdpÈöè‰æødpÔºöËÆ∞ÂΩïÊØè‰∏™Â∑¶Á´ØÁÇπÊúÄËøëÁöÑÂè≥Á´ØÁÇπÔºåf[r[i]]=max(f[r[i]],f[i]+1),f[i+1]=max(f[i+1],f[i])Ë¥™ÂøÉÔºö ÈÅáÂà∞‰∏Ä‰∏™Âè≥Á´ØÁÇπÔºåÂÅáÂ¶ÇËøô‰∏™Âå∫Èó¥ËøòÊúâÊïàÔºå++ansÔºåÂ∞ÜÁõÆÂâçÈÅáÂà∞ÁöÑÊâÄÊúâÂå∫Èó¥ÁΩÆ‰∏∫Êó†Êïà ÈÅáÂà∞‰∏Ä‰∏™Â∑¶Á´ØÁÇπÔºå‰ΩøËøô‰∏™Âå∫Èó¥ÊúâÊïà Á¨¨ÂõõÈ¢òÂøÉ‰∏≠ÊúâËæπÁöÑÊó∂ÂÄôÔºàÂ∞±ÊòØ‰Ω†Áü•ÈÅìÂ∫îËØ•ËÆøÈóÆÂì™‰∫õÁÇπÁöÑÊó∂ÂÄôÔºâÂèØ‰ª•‰∏çÂª∫ËæπÔºåËäÇÁ∫¶Êó∂Èó¥Á©∫Èó¥ÊääËøôÈ¢òÊö¥Âäõ*Êéâ„ÄÇ Ê≠£Ëß£ÊòØ‰ºòÂåñÂª∫ÂõæÔºà‰Ω†ËÉ°ÊÄù‰π±ÊÉ≥Âì™‰∫õÂÄçÂ¢ûÊúâÁîö‰πàÁî®ÔºâÊääÊØè‰∏™ÁÇπÁöÑÈ´òÂ∫¶ÂÜç‰Ωú‰∏∫1Áª¥ÂèòÊàên^3ÁöÑÁÇπÊï∞ÂíåËæπÊï∞Ôºå‰∏ädijkÂ∞±Ë°å ÊôÆËΩ¨Êèêr2 18-9-16Á¨¨‰∏ÄÈ¢òÊ≥®ÊÑèÂà∞‰∫§Êç¢‰∏§‰∏™Êï∞‰πãÂíåÂ∑¶Âè≥‰∏§ËæπÂ∞±ÂàÜÂºÄ‰∫ÜÊåâÂå∫Èó¥ËÄÉËôë‰∏ÄÊó¶Âå∫Èó¥ÁöÑÂ∑¶Âè≥‰ΩçÁΩÆÁ°ÆÂÆö‰∫ÜÔºåÂå∫Èó¥‰∏≠ÊúâÂì™‰∫õÊï∞Â∞±Á°ÆÂÆö‰∫ÜËøôÊ†∑Â∞±ÂèØ‰ª•dp[l][r]Ë°®Á§∫Â∞Ü[l,r]ÊéíÊàêÈÄíÂ¢ûÁöÑÈ°∫Â∫èÊúâÂ§öÂ∞ëÁßçÊñπÊ≥ïÊûö‰∏æ‰∏≠Èó¥ÁöÑËΩ¨ÁßªÁÇπÂ∞±ÂèØ‰ª•‰∫ÜËÆ∞ÂøÜÂåñÊêúÁ¥¢Âà§Êñ≠ËΩ¨ÁßªÂêàÊ≥ïÁöÑÊñπÂºèÔºà‰πüÂ∞±ÊòØ[l,i]‰∏≠ÊÅ∞Â•ΩÂê´Êúâ[l,i]ÔºâÔºöÁî®cnt[i]ËÆ∞ÂΩï‰ªélÂà∞iÊúâÂ§öÂ∞ë‰∏™Êï∞Âú®[l,i]ÂêàÊ≥ï&lt;=&gt;cnt[i]==i-1&amp;&amp;((cnt[i+1]==i&amp;&amp;a[i]!=l+i)||(cnt[i+1]==i+1&amp;&amp;a[i]==l+i))O(n^3) Á¨¨‰∫åÈ¢òÊúâ2^(R+C)ÁöÑË¥°ÁåÆÁõ∏ÂΩì‰∫éÊØè‰∏™Â≠êÈõÜÊúâ1ÁöÑË¥°ÁåÆÁõ∏ÂΩì‰∫éÊ±ÇÊØè‰∏™ÈõÜÂêàË¢´Â§öÂ∞ë‰∏™ÈõÜÂêàÂåÖÂê´ÂÖàÊûö‰∏æÂåÖÂê´ÁöÑË°åÂàóÊï∞Ôºå‰ª§$t=im+jn-i*j$Áõ∏ÂΩì‰∫éÈïøÂ∫¶‰∏∫nÁöÑÊ†ºÂ≠êÔºåÂæÄÈáåÈù¢Â°´m‰∏™Êï∞ÔºåÂÜçÈÄâÊã©k‰∏™Êï∞Ôºå‰ΩøÂæóÂâçt‰∏™Ê†ºÂ≠êË¢´ÈÄâ‰∏≠ $ans=\sum{i=0}^{n}\sum{j=0}^{m}C_n^iC_m^jF$ÂÖ∂‰∏≠FË°®Á§∫Êª°Ë∂≥iË°åjÂàóÁöÑÊ¶ÇÁéá$$F=\frac{Am^{n^2}*C{m-k}^{k-t}}{Am^{n^2}*C{m}^{k}}$$ÂàÜÊØçË°®Á§∫ÊÄªÊñπÊ°àÊï∞ÂàÜÂ≠êË°®Á§∫Êª°Ë∂≥Êù°‰ª∂ÁöÑÊñπÊ°àÊï∞ÊÄª‰ΩìËÄÉËôëÂàÜÂ≠êÔºàËÄå‰∏çÊòØÂØπÊüêÁßçÈÄâÂÆåk‰∏™Êï∞ÁöÑÊñπÊ°àËøõË°åËÄÉËôëÔºâÂØπÊüê‰∏™ÊéíÂàóÔºåÂÆÉÂèØ‰ª•ÂØπÂ∫îÁöÑÊñπÊ°àÊï∞ÊòØ$C_{m-k}^{k-t}$ÊàñËÄÖÊö¥ÂäõÁöÑÁÆóÂÖàÈí¶ÂÆöÈÄâÊï∞Âíåt‰∏™Êï∞ÔºåÂÜçÁÆó‰∏äÊéíÂàó$$Cm^t*C{m-k}^{k-t}t!A_{m-t}^{n^2-t}=Am^{n^2}*C{m-k}^{k-t}$$ Á¨¨‰∏âÈ¢òÁõ∏ÂΩì‰∫é‰∏≠Â∫èÈÅçÂéÜÁöÑÂ∫èÂàóÂçïË∞É‰∏äÂçáÊúÄÂ∞èÂåñ‰øÆÊîπÊ¨°Êï∞Áõ∏ÂΩì‰∫éÊúÄÂ§ßÂåñ‰∏ç‰øÆÊîπÊï∞ÔºàÈáçË¶ÅÁöÑÊÄùÊÉ≥ÔºöË°•ÈõÜÔºÅÔºÅÔºâÊ≥®ÊÑèÂà∞lis‰ΩÜÊòØ‰∏§‰∏™Êï∞‰∏≠Èó¥‰∏ç‰∏ÄÂÆöËÉΩÊîæ‰∏ãËøô‰πàÂ§öÊï∞Â¶ÇÊûúÊòØÊ±ÇÂçïË∞É‰∏çÈôçÁöÑÂ∫èÂàóÂ∞±ÊØîËæÉÁÆÄÂçïÔºåÁõ¥Êé•Ê±ÇÂéüÂ∫èÂàóÁöÑÂçïË∞É‰∏çÈôçÁöÑÂ∫èÂàó‰ΩÜÊòØÂçïË∞É‰∏çÈôçÂíåÂçïË∞É‰∏äÂçáËøòÊòØÂæàÂÆπÊòìËΩ¨ÂåñÁöÑËÆ©a[i]-=iÂç≥ÂèØÔºàÂÖ∂ÂÆû‰πüÂèØ‰ª•ÁêÜËß£‰∏∫Âú®‰∏•Ê†ºÂçïÂ¢ûÈóÆÈ¢ò‰∏≠ËÉΩÊãìÂ±ïÁöÑÊù°‰ª∂‰∏∫$a[i]-a[k]\geq i-k$ÈÇ£‰πà‰πüÂ∞±ÊòØ$a[i]-i\geq a[k]-k$Ôºâ Á¨¨ÂõõÈ¢òÊòæÁÑ∂akÊòØÂå∫Èó¥ÁöÑÊúÄÂ∞èÂÄº‰∏îÂÖ∂‰ªñÊï∞ÈÉΩÊòØÂÆÉÁöÑÂÄçÊï∞ÊâælÔºårÂç≥ÂèØ ÊôÆËΩ¨Êèêr3 18-9-23Á¨¨‰∏ÄÈ¢òÊÄùÁª¥È¢òÂ•ΩÂ•ΩËßÇÂØüÈ¢òÁõÆÊÄßË¥® Á¨¨‰∫åÈ¢òÂèëÁé∞Ê°•ÁöÑÊùøÂ≠êÊòØÂÜôÂÅá‰∫Ü„ÄÇ‰∏çËÉΩËÆ∞faÔºåÂõ†‰∏∫ÊúâÈáçËæπÔºÅÔºÅÂÖ∂ÂÆûÂª∫Âõæ‰πüÂÅá‰∫ÜË¶ÅÊ≠£ÂèçÂêÑË∑ë‰∏ÄÈÅçdijk Á¨¨‰∏âÈ¢òÊï∞‰ΩçÁöÑÈ¢òÁõÆË¶Å‰ª•‰∫åËøõÂà∂ÁöÑÁúºÂÖâÁúãÊï∞Âä†‰∏Ä‰∏™Êï∞Â∞±ÊòØÂú®ÊØè‰ΩçÂä†0Êàñ1fi,jË°®Á§∫Â§ÑÁêÜÂà∞Á¨¨i‰ΩçÔºà‰ªéÂè≥ÂæÄÂ∑¶ÁöÑÁ¨¨i‰Ωç‰ª•Â∑¶Â∑≤ÁªèÂ§ÑÁêÜÂÆåÔºâÔºåÁ¨¨i-1‰ΩçÊúâj‰∏™Êï∞Ëøõ‰Ωç‰∫ÜËÄÉËôëÁ¨¨i‰ΩçÂä†ÁöÑÊòØ0ËøòÊòØ1ÔºåO1ËΩ¨Áßª Á¨¨ÂõõÈ¢òn^2lognÂ∫îËØ•Ë¶ÅÊÉ≥Âà∞ÁÑ∂ÂêéË¶ÅÊ≥®ÊÑèÂà∞ÂèØ‰ª•ÊãøÂΩìÂâçÂÄºÂÖàÂà§‰∏Ä‰∏ãÔºåËøô‰∏™Ââ™ÊûùÂæàÂº∫ÔºåÂèØ‰ª•Áõ¥Êé•aÊéâÊüêÂ•áÊÄ™ÊÄßË¥®Ôºö ÈöèÊú∫Â∫èÂàóÁöÑlisÁöÑÈïøÂ∫¶ÁöÑÊúüÊúõÊòØ2sqrt(n)ÁöÑÔºàÊúâËÆ∫ÊñáÔºâ ÈïøÂ∫¶‰∏∫n2+1ÁöÑÊéíÂàóËá≥Â∞ëÊúâ‰∏Ä‰∏™Èïø‰∏∫n+1ÁöÑ‰∏äÂçáÂ≠êÂ∫èÂàóÊàñ‰∏ãÈôçÂ≠êÂ∫èÂàóÔºàËØÅÊòéÔºödpÊòØËØ¥‰ª•ÊØè‰∏™Êï∞ÁªìÂ∞æÁöÑÊúÄÈïø‰∏äÂçáÂ≠êÂ∫èÂàóÈïøÂ∫¶ÂíåÊúÄÈïø‰∏ãÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶ ÂØπ‰∫é‰∏§‰∏™Êï∞ËÄåË®Ä‰∏§ËÄÖ‰∏çËÉΩÈÉΩ‰∏ÄÊ†∑ ÊâÄ‰ª•Ë¶ÅÊòØÈÉΩÂú®1-nÂ∞±ÊúÄÂ§öÊúân2‰∏™Êï∞ from ytlÔºâ ÈïøÂ∫¶‰∏∫nÁöÑÊéíÂàóÔºåËÆæÂÆÉÁöÑÊúÄÈïø‰∏äÂçáÂ≠êÂ∫èÂàóÈïøÂ∫¶‰∏∫aÔºåÊúÄÈïø‰∏ãÈôçÂ≠êÂ∫èÂàóÈïøÂ∫¶‰∏∫bÔºåÂàôab&gt;=nÔºàËØÅÊòéÔºöËøôn‰∏™‰ΩçÁΩÆÁöÑdpÂÄºÈÉΩ‰∏ç‰∏ÄÊ†∑ÔºåÂú®‰∫åÁª¥ÂùêÊ†áÁ≥ª‰∏ãË°®Á§∫Ëøô‰∫õÁÇπÔºåabÊúÄÂ∞èÁöÑÊó∂ÂÄô‰∏ÄÂÆöÊòØËøô‰∫õÁÇπÂõ¥Êàê‰∏Ä‰∏™Áü©ÂΩ¢ÔºåÁü©ÂΩ¢ÁöÑÈïø‰πòÂÆΩÂ∞±ÊòØabÔºåÊâÄ‰ª•ab&gt;=bÔºâ ÈöèÊú∫Â∫èÂàóÁöÑ‰∏çÂêåÂâçÁºÄÊúÄÂ§ßÂÄº‰∏™Êï∞ÊòØÔºàË∞ÉÂíåÁ∫ßÊï∞Ôºâln(n)ÁöÑÔºàËØÅÊòéÔºöÂõ†‰∏∫Á¨¨i‰∏™Êï∞Êúâ1/iÊ¶ÇÁéáÊØî‰πãÂâçÁöÑÈÉΩÂ§ß ÊâÄ‰ª•Ê†πÊçÆÊúüÊúõÁöÑÁ∫øÊÄßÊÄßÂä†Ëµ∑Êù•Â∞±ÊòØlnÔºâ Â∞ÜÈ°∫Â∫èÈöèÊú∫‰∏Ä‰∏ãÔºåÂè™Êúâlog‰∏™‰ΩçÁΩÆÈúÄË¶ÅËøõÂéª‰∫åÂàÜÔºåÂÖ∂‰ªñ‰ΩçÁΩÆÂè™Ë¶ÅÂà§ÊéâÂ∞±Ë°åÂ§çÊùÇÂ∫¶O(n^2+nlognlogn) ÊôÆËΩ¨Êèêr4 18-9-30Á¨¨‰∏ÄÈ¢òÊï∞Â≠¶Á∫øÊÄßÁ≠õÂõ†Êï∞‰∏™Êï∞ÔºàÊö¥ÂäõÂç°Êó∂Ëøá„ÄÇ„ÄÇÔºâ Á¨¨‰∫åÈ¢òÂàÜÁ±ªËÆ®ËÆ∫knight‚Äôs tourÔºönn‰∏≠Ôºån&gt;=5Â≠òÂú®ÂìàÂØÜÂ∞îÈ°øË∑ØÂæÑÔºån&gt;=6‰∏în‰∏∫ÂÅ∂Êï∞Â≠òÂú®ÂìàÂØÜÂ∞îÈ°øÂõûË∑ØÔºàËØÅÊòéËßÅwikiÔºânm‰∏≠ÔºåÂè™Ë¶Åmin(n,m)&gt;=5ÂàôÂ≠òÂú®ÂìàÂØÜÂ∞îÈ°øË∑ØÂæÑÔºåÊó†ËØÅÊòéÔºàÊêúÁ¥¢ËØÅÊòé„ÄÇ„ÄÇ Á¨¨‰∏âÈ¢òÊö¥ÂäõÂä†ÊúÄ‰ºòÊÄßÂâ™ÊûùÊö¥ËâπÊ≠£Ëß£Ê≠£Ëß£‰∫åÂàÜ+Êâ´ÊèèÁ∫ø+set Á¨¨ÂõõÈ¢òÊö¥ÂäõrÂíåmÊâìÈîô„ÄÇ„ÄÇÂ∏∏Áî®ÂèòÈáèÂêçËøòÊòØ‰∏çË¶Å‰π±Âä®„ÄÇ„ÄÇËΩ¨ÂØπÂÅ∂Âõæ+Âπ∂Êü•ÈõÜ ÊôÆÂèär3 18-9-29‰Ω†oiÊØîËµõÂΩìÁÑ∂Ë¶ÅÂ•ΩÂ•ΩÊ£ÄÊü•Âïä from fizzydavid Á¨¨‰∏ÄÈ¢òsbÈ¢òsbÈ¢ò‰πüË¶Å‰ªîÁªÜÂÅöÔºÅÔºÅÊÉ≥Ê∏ÖÊ•öÂÜçÂÜôÔºÅÔºÅ Á¨¨‰∫åÈ¢ò‰∫∫ÁúºÊü•Èîô‰∏çÊòØÁî®ÁúºÁùõÊü•ÈîôÊòØÁî®ËÑëÂ≠êÊü•ÈîôÔºÅÔºÅ ËøôÊâçÊòØ‰ºòÁßÄÁöÑÂÜôÊ≥ï123456789101112double Calc(int x) &#123; if (x == 4) return s[x]; if (f[x] &lt;= 2) &#123; if (f[x] == 1) s[x + 1] *= s[x]; if (f[x] == 2) s[x + 1] = s[x] / s[x + 1]; return Calc(x + 1); &#125; else &#123; if (f[x] == 3) return s[x] + Calc(x + 1); if (f[x] == 4) return s[x] - Calc(x + 1); &#125;&#125; roundÔºöÂèñÁ¶ªËá™Â∑±ÊúÄËøëÁöÑÊï¥Êï∞ÔºàÂõõËàç‰∫îÂÖ•ÔºâÔºå0.5ÁöÑËØùÂèñËøúÁ¶ª0ÁöÑÂÄºtruncÔºöËàçÂºÉÂ∞èÊï∞floorÔºöÂ∞è‰∫éÁ≠â‰∫éÁöÑÊúÄÂ§ßÊï¥Êï∞ceilÔºöÂ§ß‰∫éÁ≠â‰∫éÁöÑÊúÄÂ∞èÊï¥Êï∞int()ÂíåLL()ËøôÁßçÂº∫Âà∂Á±ªÂûãËΩ¨Êç¢Á≠âÂêå‰∫étruncÂà§Êñ≠xÊòØÂê¶ÊòØÊï¥Êï∞Ôºöfabs(x-round(x))]]></content>
      <tags>
        <tag>ÂøÉÊÉÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2120 [ZJOI2007]‰ªìÂ∫ìÂª∫ËÆæ]]></title>
    <url>%2F2018%2F08%2F17%2Fluogu2120%20%5BZJOI2007%5D%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[ÂÅöÁâπÂà´Ë°åÂä®ÈòüÁöÑÊó∂ÂÄôÂèëÁé∞ËøôÈ¢òÁöÑÈ¢òËß£ËøòÊ≤°ÂÜôËøôÊâçÊòØÁ¨¨‰∏ÄÈÅìÊñúÁéá‰ºòÂåñÂïäÂΩìÊó∂ÊáµÊáµÊáÇÊáÇÂØπÁùÄÈ¢òËß£ÂÜôÁöÑÁé∞Âú®ÊòéÁôΩ‰∫Ü ÊÉ≥ÊÉ≥ÂÖ®tmÊòØÂ•óË∑Ø12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1000008;int n;int x[N],c[N];LL s[N],t[N],f[N];int q[N],he,ta;inline double rate(int x,int y)&#123; return (f[y]+t[y]-f[x]-t[x])*1.0/(s[y]-s[x]);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; x[i]=read();s[i]=read();c[i]=read(); t[i]=t[i-1]+s[i]*x[i]; s[i]+=s[i-1]; &#125; he=1;ta=1;q[1]=0; for(int i=1;i&lt;=n;++i)&#123; while(he+1&lt;=ta&amp;&amp;x[i]&gt;rate(q[he],q[he+1])) ++he; f[i]=f[q[he]]+c[i]+(s[i]-s[q[he]])*x[i]-t[i]+t[q[he]]; while(he+1&lt;=ta&amp;&amp;rate(q[ta],i)&lt;rate(q[ta-1],q[ta])) --ta; q[++ta]=i; &#125; printf("%lld",f[n]); return 0;&#125;]]></content>
      <tags>
        <tag>ÊñúÁéá‰ºòÂåñ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3628 [APIO2010]ÁâπÂà´Ë°åÂä®Èòü]]></title>
    <url>%2F2018%2F08%2F17%2Fluogu3628%20%5BAPIO2010%5D%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F%2F</url>
    <content type="text"><![CDATA[ÊñúÁéá‰ºòÂåñÁúüÊòØÂ•óË∑Ø $f[i]=min(a[i]*b[j]+c[j]+d[i])$ ÁúãÂà∞ËøôÁßçÂ∏¶ÂΩìÂâçiÂíåËΩ¨ÁßªjÁöÑ‰∫åÊ¨°È°πÁöÑÔºåÂ∞±ÊòØÊñúÁéá‰ºòÂåñ‰∫Üd[i]ÊúÄÂêéÂä†ÂèØ‰ª•‰∏çÁÆ°ÔºåÂéªÊéâminÔºåÁÑ∂ÂêéÊï¥ÁêÜÊàêy=kx+bÁöÑÂΩ¢Âºè $c[j]=-a[i]*b[j]+f[i]$ k‰∏∫-a[i]Ôºåb‰∏∫f[i]Ôºå(x,y)‰∏∫(b[j],c[j])Ë¶ÅÊúÄÂ§ßÂåñf[i]ÔºåÂ∞±ÊòØÁª¥Êä§‰∏äÂá∏Â£≥Ë¶ÅÊúÄÂ∞èÂåñf[i]ÔºåÂ∞±ÊòØÁª¥Êä§‰∏ãÂá∏Â£≥Ê≥®ÊÑèËµ∑ÁÇπÂú®Âì™‰∏™‰ΩçÁΩÆÔºà‰∏ÄËà¨ÊòØ(0,0) ËøòÂèØ‰ª•ËÄÉËôëÊØîËæÉÊ≥ïËÄÉËôë1&lt;=k&lt;j&lt;iÂÅáÂ¶ÇjÁöÑËΩ¨ÁßªÊõ¥‰ºòË¶ÅÊª°Ë∂≥ÁöÑÊù°‰ª∂ÁÑ∂ÂêéÊé®‰∏ÄÊ≥¢ÂºèÂ≠êÂèëÁé∞Âíå‰∏äÈù¢ÁöÑÊòØ‰∏ÄÊ†∑ÁöÑ ÁÑ∂ÂêéÊòØÈáçÁÇπÔºàÊï≤ÈªëÊùøÂ¶ÇÊûúb[i]ÈöèiÊúâÂçïË∞ÉÊÄßÔºàÂçïË∞ÉÈÄíÂ¢ûÊúÄÂ•ΩÔºåÂ¶ÇÊûúÊòØÂçïË∞ÉÈÄíÂáèÂèØ‰ª•ÊèêË¥üÂè∑Â•ΩÁêÜËß£ a[i]ÊúâÂçïË∞ÉÊÄßÔºåÂàÜÊàê‰∏§ÁßçÂçïË∞ÉÊÄßÔºå‰∏ÄÁßçÈöèÁùÄÂá∏Â£≥ÂæÄÂêéËÄåÂæÄÂêéÔºå‰∏ÄÁßçÂè™‰ºöÂÅúÂú®Á¨¨‰∏Ä‰∏™ÁÇπÔºàËøôÁßçÊÉÖÂÜµÂá†‰πé‰∏ç‰ºöÊúâÂêßÂ§çÊùÇÂ∫¶ÊòØO(n) a[i]Ê≤°ÊúâÂçïË∞ÉÊÄßÔºåÈÇ£‰πàË¶Å‰∫åÂàÜÔºåÂ§çÊùÇÂ∫¶O(nlogn)„ÄÇ‰ª•‰∏ãÂºïÁî®Ôºö‰∫åÂàÜÂÅöÊ≥ïÔºöÂÅáËÆæ‰Ω†Ë¶ÅÂú®‰∏äÂá∏ÂåÖ‰∏ä‰∫åÂàÜÊâæÊñúÁéá‰∏∫kÁöÑÂàáÁ∫ø„ÄÇÂèñ‰∏≠Èó¥ÁöÑmidÂè∑ÁÇπÔºåÂ¶ÇÊûúmid+1Â≠òÂú®‰∏î‰∏émidÁÇπÁöÑÊñúÁéáÂ∞è‰∫ékÔºåÂàôl=mid+1ÔºõÂ¶ÇÊûúmid‚àí1Â≠òÂú®‰∏î‰∏émidÁÇπÁöÑÊñúÁéáÂ§ß‰∫ékÔºåÂàôr=mid‚àí1ÔºõÂ¶ÇÊûú‰∏äÈù¢‰∏§Êù°ÈÉΩ‰∏çÊª°Ë∂≥ÔºåÂàômidÂ∞±ÊòØÂàáÁÇπ„ÄÇ‰∏Ä‰∏™ÂæàÂ•ΩÁöÑÊñúÁéá‰ºòÂåñËÆ≤Ëß£ Â¶ÇÊûúb[i]Ê≤°ÊúâÂçïË∞ÉÊÄßÔºàÁ≥üÁ≥ïË¶ÅÂä®ÊÄÅÁª¥Êä§Âá∏ÂåÖÔºâÈÇ£‰πàËÄÉËôëset/ÊâãÂÜôÂπ≥Ë°°Ê†ë/cdqÂàÜÊ≤ªÔºåÂ§çÊùÇÂ∫¶O(nlogn) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1000008;int n;int a,b,c;int sum[N];int q[N],he,ta;LL xl; LL dp[N];inline LL calc(int x)&#123; return dp[x]+1ll*a*sum[x]*sum[x]-1ll*b*sum[x];&#125;inline double rate(int x,int y)&#123; return (calc(x)-calc(y))/(sum[x]-sum[y]);&#125;int main()&#123; n=read(); a=read();b=read();c=read(); for(int i=1;i&lt;=n;++i)&#123; sum[i]=sum[i-1]+read(); &#125; he=ta=1; q[1]=0; xl=2ll*a; for(int i=1;i&lt;=n;++i)&#123; while(he+1&lt;=ta&amp;&amp;xl*sum[i]&lt;rate(q[he+1],q[he])) ++he; dp[i]=calc(q[he])-xl*sum[i]*sum[q[he]]+1ll*a*sum[i]*sum[i]+1ll*b*sum[i]+c; while(he+1&lt;=ta&amp;&amp;rate(q[ta],q[ta-1])&lt;rate(i,q[ta])) --ta; q[++ta]=i; &#125; printf("%lld",dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>ÊñúÁéá‰ºòÂåñ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2819 Nim]]></title>
    <url>%2F2018%2F08%2F16%2Fbzoj2819%20Nim%2F</url>
    <content type="text"><![CDATA[Ë£∏Ê†ëÂâñ+Á∫øÊÆµÊ†ëÁ†ÅÁ†ÅÁ†ÅÊåÇ‰∫ÜÊü•‰∫ÜÂ•Ω‰πÖÂèëÁé∞dfs2ÊåÇ‰∫Ü‰º§ÂøÉÊ¨≤Áªù‰ª•‰∏∫Êàë‰∏ÄÁõ¥‰ª•Êù•ÁöÑÊùøÂ≠êÈÉΩÊòØÈîôÁöÑÂºÄÂßãÂêêÊßΩËøáÂéªaÊéâÁöÑÈ¢òÁõÆÊï∞ÊçÆÊ∞¥ÁÑ∂ÂêéÂèëÁé∞Âè™ÊúâÂ•óÁ∫øÊÆµÊ†ëÊâç‰ºöÊåÇÂõ†‰∏∫Ê≤°ÊúâÂÖàdfsÈáçÂ≠©Â≠êÔºàÂéüÊù•ÊàëÂÜôÁöÑÈÉΩÊòØÊ±ÇlcaÂêó„ÄÇ Ê≠£Ëß£ÊòØÂú®dfsÂ∫è‰∏äÊêûÂèëÁé∞Á≠îÊ°àÊòØ‰∏§ÁÇπÂà∞Ê†πÁöÑÂºÇÊàñÂíåÂÜçÂºÇÊàñlca‰∏Ä‰∏™ÁÇπÂè™ÂØπÂ≠êÊ†ëÊúâË¥°ÁåÆÁÑ∂ÂêéÊàëË∑ëÂéªÂÜôÊâãÂÜôÊ†àÂÖ∂ÂÆûÊòØÁ¨¨‰∏ÄÊ¨°ÂÜôÂÖ•Ê†àÁöÑÊó∂ÂÄôÂ§ÑÁêÜ‰∏Ä‰∏™ÁÇπÁöÑ‰ø°ÊÅØÂÖ®ÈÉ®Â§ÑÁêÜÂÆåÂá∫Ê†àÂá∫Ê†àÊó∂Â§ÑÁêÜÂØπÁà∂‰∫≤ÁöÑË¥°ÁåÆ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008;int n,qn;int a[N];int x,y;vector&lt;int&gt; e[N];int sz[N],dep[N],fa[N],hvson[N],tf[N],id[N],w[N],num;inline void dfs1(int x)&#123; sz[x]=1; for(int i=0;i&lt;e[x].size();++i)&#123; if(e[x][i]!=fa[x])&#123; fa[e[x][i]]=x; dep[e[x][i]]=dep[x]+1; dfs1(e[x][i]); sz[x]+=sz[e[x][i]]; if(sz[hvson[x]]&lt;sz[e[x][i]]) hvson[x]=e[x][i]; &#125; &#125;&#125;inline void dfs2(int x)&#123; id[x]=++num; w[num]=a[x]; //Ë¶ÅÂÖàdfsÈáçÂ≠©Â≠êÔºÅÔºÅ /*tf[x]=(hvson[fa[x]]==x?tf[fa[x]]:x); for(int i=0;i&lt;e[x].size();++i)&#123; if(e[x][i]!=fa[x]) dfs2(e[x][i]); &#125;*/ /*tf[x]=ances; if(!hvson[x]) return; dfs2(hvson[x],ances); for(int i=0;i&lt;e[x].size();++i)&#123; if(e[x][i]!=fa[x]&amp;&amp;e[x][i]!=hvson[x]) dfs2(e[x][i],e[x][i]); &#125;*/ tf[x]=(hvson[fa[x]]==x?tf[fa[x]]:x); if(!hvson[x]) return; dfs2(hvson[x]); for(int i=0;i&lt;e[x].size();++i)&#123; if(e[x][i]!=fa[x]&amp;&amp;e[x][i]!=hvson[x]) dfs2(e[x][i]); &#125;&#125;int tr[N&lt;&lt;2];inline void pushup(int t)&#123; tr[t]=tr[t&lt;&lt;1]^tr[t&lt;&lt;1|1];&#125;inline void build_segment_tree(int t,int l,int r)&#123; if(l==r)&#123; tr[t]=w[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build_segment_tree(t&lt;&lt;1,l,mid); build_segment_tree(t&lt;&lt;1|1,mid+1,r); pushup(t);&#125;inline void update(int t,int l,int r,int pos,int val)&#123; if(l==r)&#123; tr[t]=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(t&lt;&lt;1,l,mid,pos,val); else update(t&lt;&lt;1|1,mid+1,r,pos,val); pushup(t);&#125;inline int query(int t,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; return tr[t]; &#125; int mid=(l+r)&gt;&gt;1; if(rr&lt;=mid) return query(t&lt;&lt;1,l,mid,ll,rr); if(ll&gt;mid) return query(t&lt;&lt;1|1,mid+1,r,ll,rr); return query(t&lt;&lt;1,l,mid,ll,rr)^query(t&lt;&lt;1|1,mid+1,r,ll,rr);&#125;inline void solve(int x,int y)&#123; int ans=0; while(tf[x]!=tf[y])&#123; if(dep[tf[x]]&gt;dep[tf[y]])&#123; ans^=query(1,1,n,id[tf[x]],id[x]); x=fa[tf[x]]; &#125; else&#123; ans^=query(1,1,n,id[tf[y]],id[y]); y=fa[tf[y]]; &#125; &#125; if(dep[x]&lt;dep[y])&#123; ans^=query(1,1,n,id[x],id[y]); &#125; else&#123; ans^=query(1,1,n,id[y],id[x]); &#125; //‰∏ãÈù¢ÊòØÂÅáÂÅöÊ≥ïÔºålcaÊ≤°ÊúâË¢´ËÄÉËôëÂà∞ /* while(x&gt;0)&#123; ans^=query(1,1,n,id[tf[x]],id[x]); x=fa[tf[x]]; &#125; while(y&gt;0)&#123; ans^=query(1,1,n,id[tf[y]],id[y]); y=fa[tf[y]]; &#125;*/ if(ans)&#123; puts("Yes"); &#125; else&#123; puts("No"); &#125;&#125;char op;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;n;++i)&#123; x=read();y=read(); e[x].pb(y); e[y].pb(x); &#125; dfs1(1); dfs2(1); build_segment_tree(1,1,n); qn=read(); while(qn--)&#123; op=getchar(); while(op!='Q'&amp;&amp;op!='C') op=getchar(); if(op=='Q')&#123; x=read();y=read(); solve(x,y); &#125; else&#123; x=read();y=read(); update(1,1,n,id[x],y); &#125; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008;int n,qn;int a[N];int x,y,z;vector&lt;int&gt; e[N];int sta[N],ta;int sz[N],fa[N],dep[N],hvson[N],tf[N];int cur[N];inline void dfs1()&#123; memset(cur,0,sizeof(cur)); ta=0; sta[++ta]=1; sz[1]=1; while(ta&gt;0)&#123; int x=sta[ta]; int &amp;i=cur[x]; if(e[x][i]==fa[x]) ++i; if(i&gt;=e[x].size())&#123; --ta; if(fa[x])&#123; sz[fa[x]]+=sz[x]; if(sz[hvson[fa[x]]]&lt;sz[x]) hvson[fa[x]]=x; &#125; continue; &#125; fa[e[x][i]]=x; dep[e[x][i]]=dep[x]+1; sta[++ta]=e[x][i]; sz[e[x][i]]=1; ++i; &#125;&#125;bool vis[N];int in[N],out[N],num;inline void dfs2()&#123; memset(cur,0,sizeof(cur)); ta=0; sta[++ta]=1; in[1]=++num; tf[1]=1; while(ta&gt;0)&#123; int x=sta[ta]; if(!hvson[x])&#123; out[x]=num; --ta; continue; &#125; if(!vis[x])&#123; vis[x]=1; sta[++ta]=hvson[x]; in[hvson[x]]=++num; tf[hvson[x]]=tf[x]; continue; &#125; int &amp;i=cur[x]; while(i&lt;e[x].size()&amp;&amp;(e[x][i]==fa[x]||e[x][i]==hvson[x])) ++i; if(i&gt;=e[x].size())&#123; out[x]=num; --ta; continue; &#125; sta[++ta]=e[x][i]; in[e[x][i]]=++num; tf[e[x][i]]=e[x][i]; ++i; &#125;&#125;char op;int bit[N];inline void add(int pos,int x)&#123; if(!pos) return; for(int i=pos;i&lt;=n;i+=i&amp;-i)&#123; bit[i]^=x; &#125;&#125;inline int query(int pos)&#123; int tmp=0; for(int i=pos;i&gt;0;i-=i&amp;-i)&#123; tmp^=bit[i]; &#125; return tmp;&#125;inline int lca(int x,int y)&#123; while(tf[x]!=tf[y])&#123; dep[tf[x]]&gt;dep[tf[y]]?x=fa[tf[x]]:y=fa[tf[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;n;++i)&#123; x=read();y=read(); e[x].pb(y); e[y].pb(x); &#125; dfs1(); dfs2(); for(int i=1;i&lt;=n;++i)&#123; add(in[i],a[i]); add(out[i]+1,a[i]); &#125; qn=read(); while(qn--)&#123; op=getchar(); while(op!='Q'&amp;&amp;op!='C') op=getchar(); if(op=='Q')&#123; x=read();y=read(); puts((query(in[x])^query(in[y])^a[lca(x,y)])?"Yes":"No"); &#125; else&#123; x=read();y=read(); add(in[x],a[x]); add(out[x]+1,a[x]); a[x]=y; add(in[x],a[x]); add(out[x]+1,a[x]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ê†ëÈìæÂâñÂàÜ</tag>
        <tag>Á∫øÊÆµÊ†ë</tag>
        <tag>Ê†ëÁä∂Êï∞ÁªÑ</tag>
        <tag>dfsÂ∫è</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2046 [NOI2010]Êµ∑Êãî]]></title>
    <url>%2F2018%2F08%2F16%2Fluogu2046%20%5BNOI2010%5D%E6%B5%B7%E6%8B%94%2F</url>
    <content type="text"><![CDATA[‰∏ÄÁúº‚Äî‚ÄîË¶Å‰πà0Ë¶Å‰πà1ÊúÄÂ∞èÂâ≤ÔºÅÁ†ÅÁ†ÅÁ†Å90ÂàÜÔºàdinicÊªöÂéªÂÜôÊ≠£Ëß£ËøòÂ•ΩÂ∞±ÊòØÂª∫ÂõæÊúâÁÇπÁÉ¶ÊåÇ‰∫Ü‰∏ÄÊ¨°ÊòØÂÜôÊàêÂ§ßÊ†πÂ†ÜÔºàËøôtmËÉΩËøáÊ†∑‰æã„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=508;int n,x;int s,t;int nume,head[N*N];struct edge&#123; int to,nxt,f;&#125;e[N*N*4];inline void add_edge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; pq;int dis[N*N];bool vis[N*N];inline void dijk()&#123; memset(dis,0x3f,sizeof(dis)); dis[s]=0; pq.push(mp(0,s)); while(!pq.empty())&#123; int x=pq.top().second; pq.pop(); if(vis[x]) continue; vis[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; pq.push(mp(dis[e[i].to],e[i].to)); &#125; &#125; &#125; printf("%d",dis[t]);&#125;int main()&#123; n=read(); s=0;t=n*n+1; for(int i=1;i&lt;=n+1;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; x=read(); if(i==1)&#123; add_edge(s,j,x); &#125; else if(i==n+1)&#123; add_edge(n*(n-1)+j,t,x); &#125; else&#123; add_edge(n*(i-2)+j,n*(i-1)+j,x); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n+1;++j)&#123; x=read(); if(j==1)&#123; add_edge(n*(i-1)+1,t,x); &#125; else if(j==n+1)&#123; add_edge(s,n*i,x); &#125; else&#123; add_edge(n*(i-1)+j,n*(i-1)+j-1,x); &#125; &#125; &#125; for(int i=1;i&lt;=n+1;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; x=read(); if(i==1)&#123; add_edge(j,s,x); &#125; else if(i==n+1)&#123; add_edge(t,n*(n-1)+j,x); &#125; else&#123; add_edge(n*(i-1)+j,n*(i-2)+j,x); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n+1;++j)&#123; x=read(); if(j==1)&#123; add_edge(t,n*(i-1)+1,x); &#125; else if(j==n+1)&#123; add_edge(n*i,s,x); &#125; else&#123; add_edge(n*(i-1)+j-1,n*(i-1)+j,x); &#125; &#125; &#125; dijk(); return 0;&#125;]]></content>
      <tags>
        <tag>ÁΩëÁªúÊµÅ</tag>
        <tag>ÊúÄÁü≠Ë∑Ø</tag>
        <tag>ÂØπÂÅ∂Âõæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2115 [Wc2011] Xor]]></title>
    <url>%2F2018%2F08%2F16%2Fbzoj2115%20%5BWc2011%5D%20Xor%2F</url>
    <content type="text"><![CDATA[Á∫øÊÄßÂü∫ÊúÄÂü∫Êú¨ÁöÑÈ¢òÁõÆ‰∫ÜÂêßËæπÊúâÊùÉÂÄºÂõæ‰∏≠‰ªªÊÑèÁöÑÁéØÈÉΩÂèØ‰ª•Ëµ∞Âá∫Êù•ÔºàÂÖàÂà∞ÁéØ‰∏ä‰∏ÄÁÇπÔºåÁªï‰∏ÄÂúàÔºåÂÜçÂõûÂéªÔºâÂÖàÈöè‰æøÊâæ‰∏ÄÊù°1Âà∞nÁöÑË∑ØÂæÑÊääÁéØÂÅöÁ∫øÊÄßÂü∫Èîô‰∫Ü‰∏ÄÊ¨°Âú®‰∫éÊüê‰∏™Âú∞ÊñπÁöÑLLÂÜôÊàêint123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=50008,M=100008;int n,m;int x,y;LL z;vector&lt;pair&lt;int,LL&gt; &gt; e[N];bool vis[N];LL w[N];LL xhj[64];LL ans;inline void inser(LL x)&#123; for(int i=62;i&gt;=0;--i)&#123; if(!(x&gt;&gt;i)) continue; if(!xhj[i])&#123; xhj[i]=x; return; &#125; else&#123; x^=xhj[i]; &#125; &#125;&#125;inline void dfs(int x,int fa)&#123; vis[x]=1; for(int i=0;i&lt;e[x].size();++i)&#123; if(e[x][i].first!=fa)&#123; if(vis[e[x][i].first])&#123; inser(e[x][i].second^w[x]^w[e[x][i].first]); &#125; else&#123; w[e[x][i].first]=w[x]^e[x][i].second; dfs(e[x][i].first,x); &#125; &#125; &#125; &#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; x=read();y=read();z=read(); e[x].pb(mp(y,z)); e[y].pb(mp(x,z)); &#125; dfs(1,0); ans=w[n]; for(int i=62;i&gt;=0;--i)&#123; ans=max(ans,ans^xhj[i]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>Á∫øÊÄßÂü∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2568 GCD]]></title>
    <url>%2F2018%2F08%2F16%2Fluogu2568%20GCD%2F</url>
    <content type="text"><![CDATA[ÁÆÄÂçïÈ¢òËÄÉËôëÊûö‰∏ægcdÔºåÂâ©‰∏ãÁöÑ‰∏§‰∏™‰∏úË•ø‰∫íË¥®ÊÉ≥Âà∞Á∫øÊÄßÁ≠õÊ¨ßÊãâÂáΩÊï∞Ê≤°ÊúâÊ≥®ÊÑèÂÜÖÂ≠òÂºÄ‰∫Ü1e7ÁöÑLL+2¬∑1e7ÁöÑint+1e7ÁöÑboolÂ±ÖÁÑ∂Ê≤°ÊúâmleÊ≥®ÊÑèÊúÄÂ∞èÁöÑË¥®Êï∞ÊòØ2Ê¨ßÊãâÂáΩÊï∞Âè™ÈúÄË¶ÅÂà∞1e7/2Âç≥ÂèØËøôÊ†∑Â∞±‰∏ç‰ºömle12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1e7+8;int n;bool not_pri[N];int pri[N],phi[N/2],num;LL sum[N/2],ans;int main()&#123; n=read(); //phi[1]=sum[1]=1; for(int i=2;i&lt;=n;++i)&#123; if(!not_pri[i])&#123; pri[++num]=i; if(i&lt;=n/2) phi[i]=i-1; &#125; if(i&lt;=n/2) sum[i]=sum[i-1]+phi[i]; int j; for(j=1;j&lt;=num&amp;&amp;pri[j]&lt;=n/i;++j)&#123; not_pri[pri[j]*i]=1; if(i%pri[j])&#123; if(pri[j]&lt;=n/2/i) phi[pri[j]*i]=phi[i]*(pri[j]-1); &#125; else&#123; if(pri[j]&lt;=n/2/i) phi[pri[j]*i]=phi[i]*pri[j]; break; &#125; &#125; &#125; for(int i=1;i&lt;=num;++i)&#123; ans+=sum[n/pri[i]]; &#125; printf("%lld",ans*2+num); return 0;&#125;]]></content>
      <tags>
        <tag>Êï∞ËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2964 BossÂçïÊåëÊàò]]></title>
    <url>%2F2018%2F08%2F16%2Fbzoj2964%20Boss%E5%8D%95%E6%8C%91%E6%88%98%2F</url>
    <content type="text"><![CDATA[Áõ∏ÂΩìÁπÅÁêêÁöÑËÉåÂåÖdp_mp[i][j]Ë°®Á§∫Áî®iÂõûÂêàËøòÂâ©jÁÇπmpËÉΩÊâìÂá∫ÁöÑmax‰º§ÂÆ≥f_mp[i]Ë°®Á§∫iÂõûÂêàÁî®mpËÉΩÊâìÂá∫ÁöÑmax‰º§ÂÆ≥ËΩ¨ÁßªÊØîËæÉÁÆÄÂçïÔºåÊåâÈ¢òÁõÆËØ¥ÁöÑÂÅöÂç≥ÂèØspÂêåÁêÜÁÑ∂ÂêéÊ±ÇÂá∫ÊúÄÂ∞èÈúÄË¶ÅminiÂõûÂêàËÉΩÊâìÊ≠ªbossdp_hp[i][j]Ë°®Á§∫Á¨¨iËΩÆÊàëÊâßË°åÂÆåËøòÂâ©jË°ÄËÉΩÁ©∫Âá∫ÁöÑmaxÂõûÂêàÊï∞Â¶ÇÊûúÂ≠òÂú®iÔºå‰ΩøÂæódp_hp[i][j]&gt;=miniÂàôyesÂê¶ÂàôÂ¶ÇÊûúdp_hp[n+1][j]ÂêàÊ≥ïÔºåË°®ÊòéÊàëÊ¥ªËøáÂâçnËΩÆÔºåtieÂÜçÂê¶Âàôno Èîô‰∫Ü‰∏ÄÊ¨°ÊòØÂõ†‰∏∫ËæπÁïåÔºåfÂ∫îËØ•‰ªé0ÂºÄÂßãÔºåÂèØ‰ª•‰∏ç‰ΩøÁî®123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008,NN=18;int T;int n,m,hp,mp,sp,dhp,dmp,dsp,x; int a[N];int n1,n2,b[NN],c[NN],y[NN],z[NN];int dp_mp[N][N],dp_sp[N][N],f_mp[N],f_sp[N],dp_hp[N][N]; inline void init()&#123; n=read();m=read();hp=read();mp=read();sp=read();dhp=read();dmp=read();dsp=read();x=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; n1=read(); for(int i=1;i&lt;=n1;++i)&#123; b[i]=read();y[i]=read(); &#125; n2=read(); for(int i=1;i&lt;=n2;++i)&#123; c[i]=read();z[i]=read(); &#125;&#125; inline void up(int &amp;x,int y)&#123; if(y&gt;x) x=y;&#125;int mini,t;inline void solve()&#123; memset(dp_mp,-1,sizeof(dp_mp)); memset(dp_sp,-1,sizeof(dp_sp)); memset(f_mp,0,sizeof(f_mp)); memset(f_sp,0,sizeof(f_sp)); dp_mp[0][mp]=0; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;=mp;++j)&#123; if(~dp_mp[i][j])&#123; up(dp_mp[i+1][min(j+dmp,mp)],dp_mp[i][j]); for(int k=1;k&lt;=n1;++k)&#123; if(j&gt;=b[k]) up(dp_mp[i+1][j-b[k]],dp_mp[i][j]+y[k]); &#125; &#125; &#125; &#125; for(int i=0;i&lt;=n;++i)&#123; for(int j=0;j&lt;=mp;++j) up(f_mp[i],dp_mp[i][j]); &#125; dp_sp[0][sp]=0; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;=sp;++j)&#123; if(~dp_sp[i][j])&#123; up(dp_sp[i+1][min(j+dsp,sp)],dp_sp[i][j]+x); for(int k=1;k&lt;=n2;++k)&#123; if(j&gt;=c[k]) up(dp_sp[i+1][j-c[k]],dp_sp[i][j]+z[k]); &#125; &#125; &#125; &#125; for(int i=0;i&lt;=n;++i)&#123; for(int j=0;j&lt;=sp;++j) up(f_sp[i],dp_sp[i][j]); &#125; mini=INT_MAX; t=n; for(int i=0;i&lt;=n;++i)&#123; while(t&gt;0&amp;&amp;f_mp[i]+f_sp[t-1]&gt;=m) --t; if(f_mp[i]+f_sp[t]&gt;=m) mini=min(mini,i+t); &#125; memset(dp_hp,0,sizeof(dp_hp)); dp_hp[1][hp]=1; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=hp;++j)&#123; if(dp_hp[i][j]&gt;=mini)&#123; printf("Yes %d\n",i); return; &#125; &#125; for(int j=a[i]+1;j&lt;=hp;++j)&#123; if(dp_hp[i][j])&#123; up(dp_hp[i+1][j-a[i]],dp_hp[i][j]+1); up(dp_hp[i+1][min(j-a[i]+dhp,hp)],dp_hp[i][j]); &#125; &#125; &#125; for(int i=1;i&lt;=hp;++i)&#123; if(dp_hp[n+1][i]&gt;0)&#123; puts("Tie"); return; &#125; &#125; puts("No");&#125;int main()&#123; T=read(); while(T--)&#123; init(); solve(); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1129 [ZJOI2007]Áü©ÈòµÊ∏∏Êàè]]></title>
    <url>%2F2018%2F08%2F14%2Fluogu1129%20%5BZJOI2007%5D%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[Ë°åÂèòÊç¢ÂíåÂàóÂèòÊç¢‰∏ç‰ºö‰ΩøÂêå‰∏ÄË°åÊàñËÄÖÂêå‰∏ÄÂàóÁöÑ‰∏úË•øÂàÜÂºÄÈ¢òÁõÆË¶ÅÊ±ÇÊúÄÂêéÂ≠òÂú®n‰∏™‰∏§‰∏§Ë°åÂàóÈÉΩ‰∏çÂêåÁöÑ‰∏úË•øÈÇ£‰πà‰∏ÄÂºÄÂßã‰πüË¶ÅÊúân‰∏™‰∏§‰∏§Ë°åÂàóÈÉΩ‰∏çÂêåÁöÑ‰∏úË•øÁÑ∂ÂêéÂºÄÂßãÂ•óË∑ØÂ∑¶Ëæπn‰∏™ÁÇπË°®Á§∫Ë°åÂè≥Ëæπn‰∏™ÁÇπË°®Á§∫Âàó(i,j)‰∏∫1Âàô Â∑¶i -&gt; Âè≥jË∑ë‰∫åÂàÜÂõæÂåπÈÖçÔºå‰∏∫nÂàôÂèØ‰ª•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N=408,M=100008;int nume,head[N],from[M],to[M],f[M],nxt[M];int d[N],gap[N],cur[N],p[N],num[N];bool vis[N];int t,n,k,en;inline void addedge(int x,int y)&#123; ++nume;to[nume]=y;nxt[nume]=head[x];head[x]=nume;f[nume]=1; ++nume;to[nume]=x;nxt[nume]=head[y];head[y]=nume;f[nume]=0;&#125;void bfs()&#123; queue&lt;int&gt; q; q.push(en); d[0]=en+1; vis[en]=1; while(!q.empty())&#123; int top=q.front();q.pop(); for(int i=head[top];i;i=nxt[i])&#123; if(!vis[to[i]])&#123; vis[to[i]]=1; d[to[i]]=d[top]+1; q.push(to[i]); &#125; &#125; &#125;&#125;int augment()&#123; int x=en; while(x!=0)&#123; f[p[x]]--; f[p[x]^1]++; x=to[p[x]^1]; &#125; return 1;&#125;int maxflow()&#123; bfs(); int ans=0; for(int i=0;i&lt;=en;i++) num[d[i]]++; int x=0; for(int i=0;i&lt;=en;i++)&#123; cur[i]=head[i]; &#125; while(d[0]&lt;=en)&#123; if(x==en)&#123; ans+=augment(); x=0; &#125; bool ok=0; for(int i=cur[x];i;i=nxt[i])&#123; if(f[i]&amp;&amp;d[x]==d[to[i]]+1)&#123; ok=1; p[to[i]]=i; cur[x]=i;//cur[x]=i+1; x=to[i]; break; &#125; &#125; if(!ok)&#123; int m=en; for(int i=head[x];i;i=nxt[i])&#123; if(f[i]) m=min(m,d[to[i]]); &#125; num[d[x]]--; if(!num[d[x]]) break; d[x]=m+1; num[d[x]]++; cur[x]=head[x]; if(x!=0) x=to[p[x]^1]; &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); //cin.tie(0); cin&gt;&gt;t; while(t--)&#123; nume=1; memset(head,0,sizeof(head)); memset(vis,0,sizeof(vis)); memset(gap,0,sizeof(gap)); cin&gt;&gt;n; en=(n&lt;&lt;1)+1; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;k; if(k) addedge(i,j+n); &#125; &#125; for(int i=1;i&lt;=n;i++) addedge(0,i); for(int i=n+1;i&lt;en;i++) addedge(i,en); if(maxflow()==n) cout&lt;&lt;"Yes"&lt;&lt;'\n'; else cout&lt;&lt;"No"&lt;&lt;'\n'; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>‰∫åÂàÜÂõæ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu4113 [HEOI2012]ÈááËä±]]></title>
    <url>%2F2018%2F08%2F14%2Fluogu4113%20%5BHEOI2012%5D%E9%87%87%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[È¢ìÂ∫üÂ•Ω‰πÖÂºÄÂßãnewtrain‰πãÂêéÊØèÈÅìÈ¢òÈÉΩË¶ÅÂÜôÈ¢òËß£ÔºÅÔºÅÂå∫Èó¥ÈôêÂà∂Êï∞ÈáèÊòØÁªèÂÖ∏ÈóÆÈ¢òÔºåÂêëÂâçËøûËæπÂç≥ÂèØÊ≠§È¢òÊòØÊ±ÇÂå∫Èó¥Âá∫Áé∞Ê¨°Êï∞Â§ß‰∫é1ÁöÑÊï∞ÁöÑ‰∏™Êï∞‰∏§ÁßçÊ±ÇÊ≥ïÔºö1.ÂØπpre+1Â§Ñ-1,1Â§Ñ+1Ôºåquery‰∏∫Â∑¶Á´ØÁÇπÂèäÂÖ∂Â∑¶ÁöÑÂíåÔºåÁõ∏ÂΩì‰∫éÂØπÂå∫Èó¥ËµãÂÄºÔºåË¶ÅÊí§ÂõûÊìç‰Ωú„ÄÇ2.ÂØπpreÂ§Ñ+1Ôºåpre[pre]Â§Ñ-1Ôºåquery‰∏∫Âè≥Á´ØÁÇπ-ÔºàÂ∑¶Á´ØÁÇπ-1ÔºâÔºåÁõ∏ÂΩì‰∫éÁªüËÆ°ÊØè‰∏™ÁÇπÂØπÂå∫Èó¥ÁöÑË¥°ÁåÆÔºåÈöêËóè‰∫ÜÊí§Âõû„ÄÇÁäØ‰∫Ü‰∏Ä‰∏™Â∞èÈîôËØØ:ÊäänÂíåqnÂºÑÈîô‰∫Ü12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=2000008;int n,c,qn;int a[N];struct que&#123; int l,r,id;&#125;q[N];inline bool cmp(const que &amp;a,const que &amp;b)&#123; return a.r&lt;b.r;&#125;int pre[N],pos[N];int t;int bit[N],ans[N];inline void add(int pos,int x)&#123; for(int i=pos;i&lt;=n;i+=i&amp;-i)&#123; bit[i]+=x; &#125;&#125;inline int query(int pos)&#123; int tmp=0; for(int i=pos;i&gt;0;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125;inline void solve(int pos,int type)&#123; if(pre[pos]&gt;0)&#123; add(pre[pos]+1,-1*type); add(1,1*type); &#125;&#125;int main()&#123; n=read();c=read();qn=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;=n;++i)&#123; pre[i]=pos[a[i]]; pos[a[i]]=i; &#125; for(int i=1;i&lt;=qn;++i)&#123; q[i].l=read(); q[i].r=read(); q[i].id=i; &#125; sort(q+1,q+qn+1,cmp); t=1; for(int i=1;i&lt;=n;++i)&#123; /*while(t&lt;q[i].r)&#123; ++t; solve(t,1); solve(pre[t],-1); &#125; ans[q[i].id]=query(q[i].l); */ if(pre[i]&gt;0)&#123; add(pre[i],1); if(pre[pre[i]]&gt;0) add(pre[pre[i]],-1); &#125; while(q[t].r==i&amp;&amp;t&lt;=qn)&#123; ans[q[t].id]=query(q[t].r)-query(q[t].l-1); ++t; &#125; &#125; for(int i=1;i&lt;=qn;++i)&#123; printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ê†ëÁä∂Êï∞ÁªÑ</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F13%2F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.ÁÇπÂèåÁöÑÁº©ÁÇπ ÁÇπÂèå‰∏≠ÁöÑËæπÂÖ®ÈÉ®ÂéªÊéâÔºåËøûÂêë‰∏Ä‰∏™Êñ∞ÁÇπ2.ÊúâÂêëÂõæËá≥Â∞ëÂä†Âá†Êù°ËæπÂèòÊàêÂº∫ËøûÈÄöÂõæ ÔºàÊòìËØÅÊòéÔºåÊó†ÁéØÁöÑÊúâÂêëÂõæËá≥Â∞ëÂ≠òÂú®‰∏Ä‰∏™ÂÖ•Â∫¶‰∏∫0/Âá∫Â∫¶‰∏∫0ÁöÑÁÇπÔºâÂÖàÁº©ÁÇπÔºåans=max(ÂÖ•Â∫¶‰∏∫0ÁöÑÁÇπÊï∞ÔºåÂá∫Â∫¶‰∏∫0ÁöÑÁÇπÊï∞)ÔºàÂè™Êúâ‰∏Ä‰∏™ÁÇπËØ¥ÊòéÂ∑≤ÁªèÊòØÂº∫ËøûÈÄöÂõæÔºåË¶ÅÁâπÂà§ÊéâÔºâ Ê≥®ÊÑè‰∏Ä‰∏™ÁÇπÁöÑÊó∂ÂÄôÔºåÊòØÂê¶ÁÆó‰ΩúÂº∫ËøûÈÄöÔºåË¶ÅÁúãÈ¢òÁõÆÔºÅÔºÅ ÊúâÂêëÂõæËá≥Â∞ëÂä†Âá†Êù°Ëæπ‰ΩøÂæóÊØèÊù°ËæπÈÉΩÂú®Êüê‰∏™Âº∫ËøûÈÄöÂàÜÈáèÂÜÖÔºöÂíå‰∏äÈù¢ÁöÑÈóÆÈ¢ò‰∏ÄÊ†∑Ôºå‰∏çËøáË¶ÅÊääÂçïÁÇπÂéªÊéâ„ÄÇ3.Êó†ÂêëÂõæËá≥Â∞ëÂä†Âá†Êù°ËæπÂèòÊàêËæπÂèå ÂÖàÁº©ÁÇπÔºåans=ceiling(Â∫¶Êï∞‰∏∫1ÁöÑÁÇπÁöÑÊï∞Èáè/2)+Â∫¶Êï∞‰∏∫0ÁöÑÁÇπÁöÑÊï∞ÈáèÔºàÁâπÂà§Âè™Êúâ‰∏Ä‰∏™ÁÇπÔºâ ËØÅÊòéÔºàÁÆÄÁï•ÔºâÔºö‰∏ÄÊù°ËæπÂèØ‰ª•Âπ≤Êéâ‰∏§‰∏™Âè∂Â≠ê Âè∂Â≠êÂπ≤ÂÖâ‰∫ÜÂ∞±ÊòØÂèåËÅîÈÄö ‰∏Ä‰∏™ÁÇπÂèØ‰ª•ÊèíÂÖ•Âà∞‰∏ÄÊù°ËæπÈáåÂéª Êó†ÂêëÂõæËá≥Â∞ëÂä†Âá†Êù°ËæπÂèòÊàêÁÇπÂèåÔºü4.ËÆæf[u][i]‰∏∫Âú®ËäÇÁÇπuÁöÑÂ≠êÊ†ëÂÜÖÔºåË¥πÁî®ÈôêÂà∂‰∏∫iÁöÑÊù°‰ª∂‰∏ãËÉΩÂèñÂà∞ÁöÑÊúÄÂ§ß‰ª∑ÂÄº5.Ê†ë‰∏äËé´Èòü6.//return dcmp(cross(a-p,b-p))==0&amp;&amp;dcmp(dot(a-p,b-p))&lt;0;//ac return dcmp(length(a-p)+length(b-p)-length(a-b))==0&amp;&amp;!(p==a)&amp;&amp;!(p==b);//waÔºåËØØÂ∑ÆÂ∑®Â§ß7.doubleÂú®g++‰∏≠ÁöÑËæìÂÖ•ÊòØ%lf,ËæìÂá∫Êó∂%f„ÄÇ‰ªÄ‰πàÊó∂ÂÄôÁî®‰ªÄ‰πàÔºü g++‰∏≠abs‰∏ÄÂÆöË¶ÅÊúâcstdlibÔºåc++‰∏çÁî®„ÄÇ8.printf(‚Äú%.3f‚Äù,0);ÊúâÈîôÔºü9.Á∫øÂíåÂá∏ÂåÖÊòØÂê¶Êúâ‰∫§„ÄÅÂá∏ÂåÖÂíåÂá∏ÂåÖÊòØÂê¶Êúâ‰∫§ Á∫øÂíåÂá∏ÂåÖÔºöÊâæÁ∫ø‰∏ä‰∏Ä‰∏™Ëøú‰∏Ä‰∫õÁöÑÁÇπÔºåÊâæÂà∞‰∏§Êù°ÂàáÁ∫øÔºåÂà§Êñ≠Á∫øÊòØÂê¶Âú®ÂàáÁ∫ø‰πãÈó¥ Âá∏ÂåÖÊòØÂê¶Êúâ‰∫§ÔºöÔºü10.ÁÇπÂíåÂá∏ÂåÖÁöÑÂàáÁ∫ø Âá∏ÂåÖÂ§ñÁöÑÁÇπpÂêëÂá∏ÂåÖ‰∏ä‰∏ÄÁÇπËøûÁ∫øÔºåÊúâÁöÑÊòØÂÖ•Âá∏ÂåÖÔºåÊúâÁöÑÊòØÂá∫Âá∏ÂåÖ„ÄÇÂàôcross(a[i]-p,a[i+1]-a[i])ÁöÑÊñπÂêëÊòØ‰∏çÂêåÁöÑ„ÄÇÊâæÂà∞ÊúÄÂêé‰∏Ä‰∏™ÂÖ•Âá∏ÂåÖÁöÑÁÇπÔºåÈÇ£‰πà‰∏ã‰∏Ä‰∏™ÁÇπÂ∞±ÊòØÂàáÁÇπ„ÄÇÂ∑¶Âè≥ÂàáÁ∫øÊâæÁöÑÊó∂ÂÄôÂè™ÈúÄË¶ÅÊääÊñπÂêëÂà§Êñ≠Âèç‰∏Ä‰∏ãÂç≥ÂèØ„ÄÇ Âà§Êñ≠‰∏Ä‰∏™ÁÇπÂú®Âá∏ÂåÖÂÜÖÔºöÊâæ‰∏çÂà∞ÂàáÁ∫øÔºåÂç≥Êâæ‰∏çÂà∞ÂÖ•Âá∏ÂåÖÁöÑÁÇπ„ÄÇ11.‰∫åÁª¥Âå∫Èó¥Âíå Ê†ëÂ•óÊ†ëÔºü12.ÂáΩÊï∞ÂÜÖÊñ∞Âª∫pqÔºüÂú®ÂáΩÊï∞ÁªìÊùüÊó∂‰ºöËá™Âä®Ê∏ÖÁ©∫Âêó ‰ºöÂêß13.dp of dp14.ÂºÇÊàñhashÔºü ÂÜ≤Á™ÅÊ¶ÇÁéá1/‰∏™Êï∞15.Âπ∂Êü•ÈõÜ Êí§ÈîÄÔºüÊãÜÂπ∂Êü•ÈõÜÔºü‰∏çËÉΩÊãÜ16.Âà§Êñ≠‰∏§‰∏™ÁÇπÂú®‰∏Ä‰∏™ÁÇπÁöÑ‰∏çÂêåÂ≠êÊ†ë‰∏≠Ôºü17.Áü©ÈòµËΩ¨ÁßªÔºü18.ÂÜ≥Á≠ñÂçïË∞ÉÊÄßÁöÑÂÜôÊ≥ï19.pruferÁºñÁ†Å20.ÊåáÈíàÂíåËø≠‰ª£Âô®21.O(n)ÊâæÁ¨¨kÂ§ß22.ÈÅçÂéÜsetÊòØO(n)23.long doubleÊÄé‰πàÁî®Âïä24.int128ÊÄé‰πàÁî®25.float128ÊÄé‰πàÁî®26.01Ë¶ÜÁõñÈóÆÈ¢òÊòØnpcÂêó ÂèçÊ≠£‰∏çÂèØÂÅö27.‰øùÁïôx‰ΩçÂ∞èÊï∞ÂèòÊàê-0.00000?]]></content>
  </entry>
  <entry>
    <title><![CDATA[luogu3084 [USACO13OPEN]ÁÖßÁâáPhoto]]></title>
    <url>%2F2018%2F06%2F25%2Fluogu3084%20%5BUSACO13OPEN%5D%E7%85%A7%E7%89%87Photo%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536Âå∫Èó¥‰∏≠ÊúâÂ§öÂ∞ë‰∏™Êï∞ÁöÑÈ¢òÁõÆÂíåpkuÁöÑÂ§è‰ª§Ëê•È¢òÁõÆÊå∫ÂÉèÁöÑËøôÁßçÈ¢òÁõÆÂ•ΩÂÉèÈÉΩÂèØ‰ª•Áî®Â∑ÆÂàÜÁ∫¶ÊùüÂÅö‰∏çËøáÂç°Êó∂ËøôÈ¢òspfaÂè™ËÉΩËøá6‰∏™ÁÇπd[i]Ë°®Á§∫‰ªé1Âà∞iÁöÑ‰∏™Êï∞d[i]Âíåd[i+1]ÁöÑÂÖ≥Á≥ª‰∏∫d[i]=d[i+1]Êàñd[i]+1=d[i+1]ÊãÜÊàê‰∏çÁ≠âÂºè‰∏∫d[i]=d[i+1] =&gt; d[i]&lt;=d[i+1] d[i]&gt;=d[i+1]d[i]+1=d[i+1] =&gt; d[i]&lt;=d[i+1]-1 d[i]+1&gt;=d[i+1]ÂêàÂπ∂‰∏∫‰∏ãÈù¢‰∏§‰∏™ÔºàËã•a&lt;=bÔºåÂàôË¶ÅËÆ©bÂ∞ΩÈáèÂ§ßÔºâd[i]&lt;=d[i+1]d[i]+1&gt;=d[i+1]ÂàùÂßãÊÉÖÂÜµ‰∏∫d[0]=0ÔºåÂÖ∂‰ªñÊó†Á©∑Â§ßÔºàÊùæÂºõÂ§ß‰∫énÊ¨°Â∞±ÊúâË¥üÁéØ‰∏ÄÁÇπÈÉΩ‰∏çÈù†Ë∞±ÔºåÈöè‰æøÊûÑÈÄ†Âá∫Âèç‰æãÂÖ•ÈòüÂ§ß‰∫énÊ¨°ÊâçÊòØÊ≠£Á°ÆÁöÑÔºåÂõ†‰∏∫ÂÅáÂ¶ÇÊ≤°ÊúâË¥üÁéØÔºåbfs‰∏ÄÂ±ÇÂ∞±ËÉΩËá≥Â∞ëÁ°ÆÂÆö‰∏Ä‰∏™ÁÇπÁöÑdisÊâÄ‰ª•ÊúÄÂ§öÂÅön(ÂÖ∂ÂÆûn-1Ôºå‰ΩÜÊòØË¶ÅËÄÉËôë1‰∏™ÁÇπ)ËΩÆÔºå&gt;nÂ∞±Êó†Ëß£(ÂÖ∂ÂÆû&gt;=n)ÊØè‰∏™ÁÇπÂú®ÊØè‰∏ÄÂ±ÇÊúÄÂ§öÂÖ•Èòü1Ê¨°(ÂèØËÉΩË¢´ÊùæÂºõÂæàÂ§öÊ¨°)ÊâÄ‰ª•ÂÖ•ÈòüÊ¨°Êï∞Â§ß‰∫énÂ∞±Êó†Ëß£ÔºâÊ≠£Ëß£dpf[i]Ë°®Á§∫Ââçi‰∏™Â∑≤ÁªèÊª°Ë∂≥Êù°‰ª∂ÔºåÁ¨¨i‰∏™Êîæ‰∫ÜÁöÑÊúÄÂ§ß‰∏™Êï∞f[i]=max(f[j])+1jÁöÑËåÉÂõ¥ÊòØÂÖ≥ÈîÆËÆæiÂØπÂ∫îÁöÑjÊª°Ë∂≥l[i]&lt;=j&lt;=r[i]Êúâ‰∏îÂè™Êúâ1‰∏™Ëøô‰∏™Êù°‰ª∂ÊãÜÊàêËá≥Â∞ë1‰∏™ÂíåËá≥Â§ö1‰∏™l[i]‰∏∫Âå∫Èó¥Âè≥Á´ØÁÇπÂú®iÂ∑¶ËæπÁöÑÂ∑¶Á´ØÁÇπÁöÑÊúÄÂ§ßÂÄºÔºàÂõ†‰∏∫Ëá≥Â∞ë1‰∏™Ôºâr[i]‰∏∫iÊâÄÂú®ÁöÑÂå∫Èó¥ÁöÑÂ∑¶Á´ØÁÇπÁöÑÊúÄÂ∞èÂÄº-1ÔºàÂõ†‰∏∫Ëá≥Â§ö1‰∏™ÔºâÊ≥®ÊÑèÂà∞l[i]Âíår[i]ÈÉΩÊòØÂçïË∞É‰∏çÈôçÁöÑÊâÄ‰ª•ËΩ¨ÁßªÂèØ‰ª•Áî®ÂçïË∞ÉÈòüÂàó‰ºòÂåñÊ±Çl[i]Âíår[i]‰πüÂèØ‰ª•Âà©Áî®ÂçïË∞ÉÊÄßÁöÑÁâπÁÇπÂÅöÂà∞O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=200008,M=100008;int n,m;struct node&#123; int l,r;&#125;a[M];int l[N],r[N];int q[N],he,ta,t;int f[N];int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n+1;++i)&#123; r[i]=i-1; &#125; for(int i=1;i&lt;=m;++i)&#123; a[i].l=read();a[i].r=read(); l[a[i].r+1]=max(l[a[i].r+1],a[i].l); r[a[i].r]=min(r[a[i].r],a[i].l-1); &#125; for(int i=1;i&lt;=n;++i) l[i+1]=max(l[i+1],l[i]); for(int i=n;i;--i) r[i]=min(r[i],r[i+1]); he=ta=1;//f[0]=0,q[1]=0; t=1; for(int i=1;i&lt;=n+1;++i)&#123; while(he&lt;=ta&amp;&amp;q[he]&lt;l[i]) ++he; if(t&lt;l[i]) t=l[i]; while(t&lt;=r[i])&#123; if(f[t]!=-1)&#123; while(he&lt;=ta&amp;&amp;f[t]&gt;=f[q[ta]]) --ta; q[++ta]=t; &#125; ++t; &#125; if(he&lt;=ta)&#123; f[i]=f[q[he]]+1; &#125; else&#123; f[i]=-1; &#125; &#125; if(f[n+1]==-1) puts("-1"); else printf("%d",f[n+1]-1); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=200008,M=100008;int n,m;int l,r;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N*2+M*2];inline void add_edge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[N];bool inq[N];int q[N],he,ta;int tim[N]; inline void spfa()&#123; memset(dis,0x3f,sizeof(dis)); dis[0]=0; he=1;ta=2; q[1]=0; inq[0]=1; tim[0]=1; int maxi=min(n,1000); while(he!=ta)&#123; int x=q[he]; ++he; if(he==200005) he=1; inq[x]=0; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; tim[e[i].to]=tim[x]+1; if(tim[e[i].to]&gt;maxi)&#123; puts("-1"); return; &#125; if(!inq[e[i].to])&#123; q[ta]=e[i].to; ++ta; if(ta==200005) ta=1; inq[e[i].to]=1; &#125; &#125; &#125; &#125; printf("%d",dis[n]); return;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; l=read();r=read(); add_edge(l-1,r,1); add_edge(r,l-1,-1); &#125; for(int i=0;i&lt;n;++i)&#123; add_edge(i,i+1,1); add_edge(i+1,i,0); &#125; spfa(); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>Â∑ÆÂàÜÁ∫¶Êùü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2157 [SDOI2009]Â≠¶Ê†°È£üÂ†Ç]]></title>
    <url>%2F2018%2F06%2F21%2Fluogu2157%20%5BSDOI2009%5D%E5%AD%A6%E6%A0%A1%E9%A3%9F%E5%A0%82%2F</url>
    <content type="text"><![CDATA[1Â•ΩÈ¢ò 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int T;int n;int t[N],b[N];int f[N][1&lt;&lt;8][18];int ans;inline bool ok(int x,int y,int t)&#123; for(int i=x;i&lt;y;++i)&#123; if(((t&gt;&gt;(i-x))&amp;1)==0&amp;&amp;i+b[i]&lt;y) return 0;//Ê≥®ÊÑèÂà§‰∏çÂåÖÂê´ÁöÑ &#125; return 1;&#125;int main()&#123; T=read(); while(T--)&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; t[i]=read();b[i]=read(); &#125; memset(f,0x3f,sizeof(f)); f[1][0][7]=0; for(int i=1;i&lt;=n;++i)&#123; for(int j=0;j&lt;256;++j)&#123;/////// //for(int j=0;j&lt;(1&lt;&lt;(b[i]+1));++j)&#123; for(int k=0;k&lt;=15;++k)&#123; if(f[i][j][k]&lt;0x3f3f3f3f)&#123; if((j&amp;1))&#123; f[i+1][j&gt;&gt;1][k-1]=min(f[i+1][j&gt;&gt;1][k-1],f[i][j][k]); &#125; else&#123; int tmp=0x3f3f3f3f; for(int p=i;p&lt;=n;++p)&#123; if((j&amp;(1&lt;&lt;(p-i)))==0)&#123; //if(!ok(i,p,j)) break; if(p&gt;tmp) break; tmp=min(tmp,p+b[p]); if(i==1&amp;&amp;j==0) f[i][j|(1&lt;&lt;(p-i))][p-i+8]=0; else f[i][j|(1&lt;&lt;(p-i))][p-i+8]=min(f[i][j|(1&lt;&lt;(p-i))][p-i+8],f[i][j][k]+(t[i+k-8]^t[p])); &#125; &#125; &#125; &#125; &#125; &#125; &#125; ans=0x3f3f3f3f; for(int k=0;k&lt;=7;++k)&#123; ans=min(ans,f[n+1][0][k]); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>Áä∂Âéã</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2331 [SCOI2005]ÊúÄÂ§ßÂ≠êÁü©Èòµ]]></title>
    <url>%2F2018%2F06%2F20%2Fluogu2331%20%5BSCOI2005%5D%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[123ÁÆÄÂçïÁöÑdpÂØπ‰∫éÂ∑≤ÁªèËµ∞ËøáÁöÑÂå∫ÂüüÔºå‰∏çÁÆ°ÊúâÊ≤°ÊúâÈÄâÊã©ÔºåÈÉΩ‰∏ç‰ºöÁÆ°‰∫ÜÂØπ‰∫éÂΩìÂâçÁöÑiÂíåjÔºå‰∏ÄÂÆöÊòØËÄÉËôëÈÄâËøô‰∏™iÊàñjÔºåËÄå‰∏çÊòØ‰πãÂâçÁöÑÔºàÂõ†‰∏∫‰πãÂâçÁöÑÂú®‰πãÂâçË¢´ËÄÉËôëÔºâ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108;int n,m,k;int a[N],b[N],sum1[N],sum2[N];int f[N][11],f2[N][N][11];int ans;int main()&#123; n=read();m=read();k=read(); if(m==1)&#123; for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); sum1[i]=sum1[i-1]+a[i]; &#125; for(int i=0;i&lt;=n;++i)&#123; for(int j=1;j&lt;=k;++j)&#123; f[i][j]=-0x3f3f3f3f;//INT_MIN‰∏çË°åÔºåINT_MINÂÜçÂáè‰∏úË•øÂèòÊàêÊ≠£ÁöÑ‰∫Ü„ÄÇ„ÄÇ &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=k;++j)&#123; f[i][j]=max(f[i][j],f[i-1][j]); for(int p=0;p&lt;i;++p)&#123; f[i][j]=max(f[i][j],f[p][j-1]+sum1[i]-sum1[p]); &#125; &#125; &#125; for(int j=0;j&lt;=k;++j)&#123; ans=max(ans,f[n][j]); &#125; printf("%d",ans); &#125; else&#123; for(int i=1;i&lt;=n;++i)&#123; a[i]=read();b[i]=read(); sum1[i]=sum1[i-1]+a[i];sum2[i]=sum2[i-1]+b[i]; &#125; for(int i=0;i&lt;=n;++i)&#123; for(int j=0;j&lt;=n;++j)&#123; for(int p=1;p&lt;=k;++p)&#123; f2[i][j][p]=-0x3f3f3f3f; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; for(int p=1;p&lt;=k;++p)&#123; f2[i][j][p]=max(f2[i][j][p],f2[i-1][j][p]); f2[i][j][p]=max(f2[i][j][p],f2[i][j-1][p]); for(int q=0;q&lt;i;++q)&#123; f2[i][j][p]=max(f2[i][j][p],f2[q][j][p-1]+sum1[i]-sum1[q]); &#125; for(int q=0;q&lt;j;++q)&#123; f2[i][j][p]=max(f2[i][j][p],f2[i][q][p-1]+sum2[j]-sum2[q]); &#125; if(i==j)&#123; for(int q=0;q&lt;i;++q)&#123; f2[i][j][p]=max(f2[i][j][p],f2[q][q][p-1]+sum1[i]-sum1[q]+sum2[j]-sum2[q]); &#125; &#125; &#125; &#125; &#125; for(int p=0;p&lt;=k;++p)&#123; ans=max(ans,f2[n][n][p]); &#125; printf("%d",ans); &#125; return 0;&#125;/*10 1 41 2 -3 4 -1 6 -8 7 -9 10*/]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2216 [HAOI2007]ÁêÜÊÉ≥ÁöÑÊ≠£ÊñπÂΩ¢]]></title>
    <url>%2F2018%2F06%2F20%2Fluogu2216%20%5BHAOI2007%5D%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[1Ë£∏È¢ò stÊúâ‰∏§ÁßçËÆ≤ÂæóÂæàÊ∏ÖÊ•öÁöÑÂçöÂÆ¢O(nmlogm) - O(n)O(nmlognlogm) - O(1)ËøôÈ¢òÊòØÊ±ÇÊ≠£ÊñπÂΩ¢ÔºåÂèØ‰ª•O(nmlogt) - O(1)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int n,m,t;int a[N][N],maxi[N][N][8],mini[N][N][8];int len,ans=INT_MAX;int main()&#123; n=read();m=read();t=read(); memset(mini,0x3f,sizeof(maxi)); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; maxi[i][j][0]=mini[i][j][0]=a[i][j]=read(); &#125; &#125; for(int k=1;(1&lt;&lt;k)&lt;=t;++k)&#123; for(int i=1;i+(1&lt;&lt;k)-1&lt;=n;++i)&#123; for(int j=1;j+(1&lt;&lt;k)-1&lt;=m;++j)&#123; maxi[i][j][k]=max(max(maxi[i][j][k-1],maxi[i+(1&lt;&lt;(k-1))][j][k-1]), max(maxi[i][j+(1&lt;&lt;(k-1))][k-1],maxi[i+(1&lt;&lt;(k-1))][j+(1&lt;&lt;(k-1))][k-1])); mini[i][j][k]=min(min(mini[i][j][k-1],mini[i+(1&lt;&lt;(k-1))][j][k-1]), min(mini[i][j+(1&lt;&lt;(k-1))][k-1],mini[i+(1&lt;&lt;(k-1))][j+(1&lt;&lt;(k-1))][k-1])); &#125; &#125; &#125; //len=0; //while((1&lt;&lt;(len+1))&lt;t) ++len; len=log2(t); for(int i=1;i+t-1&lt;=n;++i)&#123; for(int j=1;j+t-1&lt;=m;++j)&#123; ans=min(ans,max(max(maxi[i][j][len],maxi[i+t-(1&lt;&lt;len)][j][len]),max(maxi[i][j+t-(1&lt;&lt;len)][len],maxi[i+t-(1&lt;&lt;len)][j+t-(1&lt;&lt;len)][len])) -min(min(mini[i][j][len],mini[i+t-(1&lt;&lt;len)][j][len]),min(mini[i][j+t-(1&lt;&lt;len)][len],mini[i+t-(1&lt;&lt;len)][j+t-(1&lt;&lt;len)][len]))); &#125; &#125; printf("%d",ans); return 0;&#125; O(nm)ÁöÑÂçïË∞ÉÈòüÂàóÂÜôÈîôÊòØÂõ†‰∏∫ÂèòÈáèÂêçÊâìÈîôÔºÅÔºÅ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int n,m,t;int a[N][N],maxi[N][N],mini[N][N];int q[N],pos[N],he,ta; int main()&#123; n=read();m=read();t=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; a[i][j]=read(); &#125; &#125; //---------------- for(int i=1;i&lt;=n;++i)&#123; he=1;ta=0; for(int j=1;j&lt;t;++j)&#123; while(he&lt;=ta&amp;&amp;a[i][j]&gt;=q[ta]) --ta; q[++ta]=a[i][j]; pos[ta]=j; &#125; for(int j=t;j&lt;=m;++j)&#123; while(he&lt;=ta&amp;&amp;pos[he]&lt;=j-t) ++he; while(he&lt;=ta&amp;&amp;a[i][j]&gt;=q[ta]) --ta; q[++ta]=a[i][j]; pos[ta]=j; maxi[i][j]=q[he]; &#125; &#125;/* for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; cout&lt;&lt;maxi[i][j]&lt;&lt;' '; &#125;cout&lt;&lt;'\n'; &#125; puts("");*/ for(int j=t;j&lt;=m;++j)&#123; he=1;ta=0; for(int i=1;i&lt;t;++i)&#123; while(he&lt;=ta&amp;&amp;maxi[i][j]&gt;=q[ta]) --ta; q[++ta]=maxi[i][j]; pos[ta]=i; &#125; for(int i=t;i&lt;=n;++i)&#123; while(he&lt;=ta&amp;&amp;pos[he]&lt;=i-t) ++he; while(he&lt;=ta&amp;&amp;maxi[i][j]&gt;=q[ta]) --ta; q[++ta]=maxi[i][j]; pos[ta]=i; maxi[i][j]=q[he]; &#125; &#125;/* for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; cout&lt;&lt;maxi[i][j]&lt;&lt;' '; &#125;cout&lt;&lt;'\n'; &#125; puts("");*/ //-------------------------- for(int i=1;i&lt;=n;++i)&#123; he=1;ta=0; for(int j=1;j&lt;t;++j)&#123; while(he&lt;=ta&amp;&amp;a[i][j]&lt;=q[ta]) --ta; q[++ta]=a[i][j]; pos[ta]=j; &#125; for(int j=t;j&lt;=m;++j)&#123; while(he&lt;=ta&amp;&amp;pos[he]&lt;=j-t) ++he; while(he&lt;=ta&amp;&amp;a[i][j]&lt;=q[ta]) --ta; q[++ta]=a[i][j]; pos[ta]=j; mini[i][j]=q[he]; &#125; &#125;/* for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; cout&lt;&lt;mini[i][j]&lt;&lt;' '; &#125;cout&lt;&lt;'\n'; &#125; puts("");*/ for(int j=t;j&lt;=m;++j)&#123; he=1;ta=0; for(int i=1;i&lt;t;++i)&#123; while(he&lt;=ta&amp;&amp;mini[i][j]&lt;=q[ta]) --ta; q[++ta]=mini[i][j]; pos[ta]=i; &#125; for(int i=t;i&lt;=n;++i)&#123; while(he&lt;=ta&amp;&amp;pos[he]&lt;=i-t) ++he; while(he&lt;=ta&amp;&amp;mini[i][j]&lt;=q[ta]) --ta; q[++ta]=mini[i][j]; pos[ta]=i; mini[i][j]=q[he]; &#125; &#125; /*for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; cout&lt;&lt;mini[i][j]&lt;&lt;' '; &#125;cout&lt;&lt;'\n'; &#125; puts("");*/ int ans=INT_MAX; for(int i=t;i&lt;=n;++i)&#123; for(int j=t;j&lt;=m;++j)&#123; ans=min(ans,maxi[i][j]-mini[i][j]); &#125; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>ÂçïË∞ÉÈòüÂàó</tag>
        <tag>st</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dp‰∏ìÈ¢ò]]></title>
    <url>%2F2018%2F06%2F20%2Fdp%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ÊàëÁöÑdpÂÆûÂú®Â§™Â∑Æ‰∫ÜÔºà‰∏çÂøçÁõ¥ËßÜÂÜô‰∏Ä‰∏™ÊÄªÁªìÂíåÊèêÈÜí‰∏ÄÊ†∑ÁöÑ‰∏úË•øÔºà‰∏çÂÆöÊó∂Êõ¥Êñ∞ dpÁöÑÂá†‰∏™ÈáçË¶ÅÁöÑ‰∏úË•øÁä∂ÊÄÅÔºàÁ∫¨Â∫¶ÔºåÁ©∫Èó¥Êó∂Èó¥ÔºåÂì™‰∫õÁä∂ÊÄÅÂêàÊ≥ïÔºâËΩ¨ÁßªÔºàËΩ¨ÁßªÊù°‰ª∂ÔºåËΩ¨ÁßªËåÉÂõ¥ÔºåËΩ¨ÁßªÈ°∫Â∫èÔºåÊâÄÊúâÂêàÊ≥ïÁä∂ÊÄÅË¶ÅË¢´ËÄÉËôëÔºâÂàùÂßãÁä∂ÊÄÅÔºàËæπÁïåÔºâÊúÄÁªàÁä∂ÊÄÅÔºàÁõÆÊ†áÔºâÁ°ÆÂÆöÁöÑÈ°∫Â∫èÂ∫îËØ•ÊòØ‰ªé‰∏äÂà∞‰∏ã ÊääÂÅöÂæó‰∏çÈ°∫ÁöÑÈ¢òËÆ∞‰∏ãÊù• luogu2157 [SDOI2009]Â≠¶Ê†°È£üÂ†Ç(Áä∂Âéã)Ë∞É‰∫ÜÂ•Ω‰πÖÈîôËØØÂú®‰∫é‰∏§‰∏™ÁªÜËäÇ‰∏ÄÊòØfor(int j=0;j&gt;(i-x))&amp;1)==0&amp;&amp;i+b[i]&lt;y) return 0;Ââç‰∏Ä‰∏™Âà§Êñ≠‰∏çËÉΩÂ∞ë ÂçïË∞ÉÊÄß[USACO13OPEN]ÁÖßÁâáPhotoÁ≠â‰∫éÂèØ‰ª•ÊãÜÊàê‰∏§Âè•ËØùÔºåÂ§ß‰∫éÁ≠â‰∫éÂíåÂ∞è‰∫éÁ≠â‰∫éÊúâÂçïË∞ÉÊÄßÁöÑËØùÂæàÂ§öÈÉΩÂèØ‰ª•O(n)ÂÅö‰∫Ü]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ËÆ°ËíúÂÆ¢ Ë¥ùÂ£≥ÊâæÊàø‰∏éÈÄÅÊ∞¥Âëò]]></title>
    <url>%2F2018%2F06%2F18%2F%E8%AE%A1%E8%92%9C%E5%AE%A2%20%E8%B4%9D%E5%A3%B3%E6%89%BE%E6%88%BF%E4%B8%8E%E9%80%81%E6%B0%B4%E5%91%98%2F</url>
    <content type="text"><![CDATA[1234567891011121314Â•ΩÈ¢òÂèëÁé∞‰∫Ü‰∏§‰∏™vÁöÑÂÅöÊ≥ï‰ΩÜÊòØÊ≤°ÂèëÁé∞‰∏Ä‰∏™vÁöÑÊåâÁÖß‰πãÂâçÁöÑÊÄùË∑ØÊ≠ªÊ¥ªÂÅö‰∏çÂá∫Êù•ÔºåËøôÊó∂ÂÄôË¶ÅË∑≥Âá∫‰πãÂâçÁöÑÊÄùÁª¥Ê®°ÂºèÔºàÈáçÁÇπÔºÅÈáçÁÇπÔºÅÈáçÁÇπÔºÅÔºâ‰∏çÂÜçÊòØÊåâÁÖßÂØπ‰ΩçÁöÑËæπÂΩ¢ÊàêÁöÑÊ†ë‰∏äÊâæ‰∫ÜËÄåÊòØËÄÉËôëÊúâÊ≤°ÊúâÁéØÈ¢òËß£Ôºö1‰∏™vÔºöÁé∞Âú®È¢òÊÑèÂèòÊàê‰∫ÜË¶ÅÊ±ÇÂ§öÁªÑÂçïÂêëÂèØËææÂÖ≥Á≥ªÂä†ÊúÄÂ∞ëÊúâÂêëËæπÁöÑÈóÆÈ¢ò„ÄÇËÄÉËôëÊØè‰∏™Âº±ËÅîÈÄöÂ≠êÂõæÔºåÂ¶ÇÊûúÊòØ‰∏™dagÁöÑËØùÊúÄÂ∞ëÈúÄË¶Åv-1‰∏™È≠îÊ≥ïÔºàÊûÑÈÄ†ÊñπÊ≥ïÔºöÁî®ÈìæÂ∞ÜÊãìÊâëÂ∫è‰∏≤Ëµ∑Êù•ÔºâÔºåÂê¶ÂàôÁöÑËØùËá≥Â∞ëÈúÄË¶Åv‰∏™È≠îÊ≥ïÔºà‰∏Ä‰∏™Â§ßÁéØÔºâ„ÄÇÁÑ∂ÂêéÂä†Ëµ∑Êù•Â∞±Â•Ω‰∫Ü„ÄÇÂèëÁé∞‰∏ç‰ºöÊâæÂº±ËøûÈÄöÂ≠êÂõæÂìáÂìáÂìádfs3+dfs2ÔºåÂÜçÂºÄ‰∏§‰∏™visÊï∞ÁªÑ‰∏ëÁöÑ‰∏çË°åÁöÑ‰ª£Á†Å 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008,shiwan=100000;int n;char s[20];int cnt;int a[N],b[N];bool vis[N],ins[N];vector&lt;int&gt; v;int nume,head[N];int nume_2,head_2[N];struct edge&#123; int to,nxt;&#125;e[N&lt;&lt;1],e_2[N&lt;&lt;1];inline void add_edge(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;inline void add_edge_2(int x,int y)&#123; e_2[++nume_2]=(edge)&#123;y,head_2[x]&#125;;head_2[x]=nume_2;&#125;int ans;inline void dfs(int x)&#123; vis[x]=0; for(int i=head[x];i;i=e[i].nxt)&#123; if(vis[e[i].to])&#123; dfs(e[i].to); &#125; &#125;&#125;bool flag;inline void dfs2(int x)&#123; vis[x]=0; ins[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(vis[e[i].to])&#123; dfs2(e[i].to); &#125; else if(ins[e[i].to])&#123; flag=1; &#125; &#125; ins[x]=0;&#125;bool vis2[N];inline void dfs3(int x)&#123; if(vis[x])&#123; dfs2(x); &#125; vis2[x]=1; for(int i=head_2[x];i;i=e_2[i].nxt)&#123; if(!vis2[e_2[i].to])&#123; dfs3(e_2[i].to); &#125; &#125;&#125;inline void solve()&#123; if(cnt==0)&#123; for(int i=1;i&lt;=n;++i)&#123; if(a[i]!=b[i])&#123; puts("-1"); return; &#125; &#125; puts("0"); return; &#125; if(cnt==1)&#123; for(int i=1;i&lt;=n;++i)&#123; if(a[i]!=b[i])&#123; add_edge(a[i],b[i]); add_edge_2(a[i],b[i]); add_edge_2(b[i],a[i]); if(!vis[a[i]])&#123; v.pb(a[i]); vis[a[i]]=1; &#125; if(!vis[b[i]])&#123; v.pb(b[i]); vis[b[i]]=1; &#125; &#125; &#125; ans=v.size(); for(int i=0;i&lt;v.size();++i)&#123; if(vis[v[i]])&#123; flag=0; dfs3(v[i]); if(!flag) --ans; &#125; &#125; printf("%d",ans); return; &#125; if(cnt==2)&#123; for(int i=1;i&lt;=n;++i)&#123; if(a[i]!=b[i])&#123; add_edge(a[i],b[i]); add_edge(b[i],a[i]); if(!vis[a[i]])&#123; v.pb(a[i]); vis[a[i]]=1; &#125; if(!vis[b[i]])&#123; v.pb(b[i]); vis[b[i]]=1; &#125; &#125; &#125; ans=v.size(); for(int i=0;i&lt;v.size();++i)&#123; if(vis[v[i]])&#123; dfs(v[i]); --ans; &#125; &#125; printf("%d",ans); return; &#125;&#125;int main()&#123; //freopen("D.in","r",stdin); n=read(); scanf("%s",s+1); if(s[1]=='V') ++cnt; for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; scanf("%s",s+1); if(s[1]=='V') ++cnt; for(int i=1;i&lt;=n;++i)&#123; b[i]=read(); &#125; solve(); return 0;&#125;]]></content>
      <tags>
        <tag>ËßÇÂØü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂæÖÂ°´ÁöÑÂùë]]></title>
    <url>%2F2018%2F06%2F16%2F%E5%BE%85%E5%A1%AB%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1.ÂùóÁä∂Êï∞ÁªÑ/ÂùóÁä∂ÈìæË°®2.‰∏ä‰∏ãÁïåÁΩëÁªúÊµÅ3.fft/ntt4.dpÊñúÁéá‰ºòÂåñ/ÂõõËæπÂΩ¢‰∏çÁ≠âÂºè/ÂÜ≥Á≠ñÂçïË∞ÉÊÄß5.Êï∞ËÆ∫ÔºàÂèçÊºî/Á≠õÔºåÁΩÆÊç¢Ôºâ6.ÂõæËÆ∫ÔºàtarjanÔºå‰ªô‰∫∫ÊéåÔºàÂúÜÊñπÊ†ëÔºâÔºâ7.Êï∞ÊçÆÁªìÊûÑÔºàÁ∫øÊÆµÊ†ëÂêàÂπ∂ÂíåÂàÜË£ÇÔºå‰∏ªÂ∏≠Ê†ëÔºåÁÇπÂàÜÊ≤ªÔºåÂπ≥Ë°°Ê†ëÔºå‰∫åÂèâÂ†ÜÔºåcdqÂàÜÊ≤ªÔºåÊï¥‰Ωì‰∫åÂàÜÔºålctÔºåk-d treeÔºâ8.ÂÆπÊñ•9.È´òÁ≤æÂ∫¶Èô§Ê≥ï]]></content>
      <tags>
        <tag>ÂøÉÊÉÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[989D A Shade of Moonlight]]></title>
    <url>%2F2018%2F06%2F12%2F989D%20A%20Shade%20of%20Moonlight%2F</url>
    <content type="text"><![CDATA[1234567È£éÂêπ‰∫ëËµ∞ÂÖ∂ÂÆû‰∫ëÊòØ‰∏çÂä®ÁöÑÊòØÊúà‰∫ÆÂú®Ëµ∞ËøôÂ∞±ÊòØÁ¨¨‰∏ÄÊ≠•ÁÑ∂ÂêéÂ∞ÜÊó∂Èó¥‰Ωú‰∏∫Á¨¨‰∫åËΩ¥ÁîªÂá∫Êù•A picture is worth a thousand words. ÁÑ∂ÂêéÂ∞±ÊòØÊãºÂëΩÊé®ÂÖ¨ÂºèÔºàÂπ≤‰∫ÜÂ•Ω‰πÖ„ÄÇ„ÄÇÔºâvector a‰∏≠Â≠òÂêëÂè≥ÁöÑ$x_u$vector b‰∏≠Â≠òÂêëÂ∑¶ÁöÑ$xv$$$\frac{1}{w{max}}&lt;\frac{x_v-x_u+l}{|x_u+x_v+l|}$$ÊãÜÁªùÂØπÂÄº1.$x_u+x_v+l&gt;=0$,$$x_v&gt;\frac{x_u(w+1)}{w-1}-l$$2.$x_u+x_v+l\frac{x_u(w-1)}{w+1}-l$$Ê≥®ÊÑè$x_u&gt;=0$Êó∂Âè™‰ºöÂú®1.‰∏≠‰∫ßÁîüË¥°ÁåÆ,‰∏î1.‰∏≠‰∏çÁ≠âÂºèÊàêÁ´ãÁöÑËØùÊù°‰ª∂Â∞±ÊàêÁ´ã$x_u]]></content>
      <tags>
        <tag>ÊÄùÁª¥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hiho1412 Rikka with Subsequence]]></title>
    <url>%2F2018%2F06%2F11%2Fhiho1412%20Rikka%20with%20Subsequence%2F</url>
    <content type="text"><![CDATA[123456Â∫èÂàóËá™Âä®Êú∫Êú¨Ë¥®‰∏äÂ∞±ÊòØdpÊâÄ‰ª•ËøôÈ¢òËÄÉËôëdpf[i]Ë°®Á§∫Âà∞‰ª•iÁªìÂ∞æÁöÑÂ≠êÂ∫èÂàóÁöÑÂêàÊ≥ïÁöÑÊ¶ÇÁéáÊï∞c[i][ch]Ë°®Á§∫Âà∞Á¨¨i‰Ωç‰∏∫Ê≠¢Ê≤°ÊúâÁî®Âà∞ÁöÑchÂÖ®Ë¢´Âà†Èô§ÁöÑÂ≠êÂ∫èÂàóÁöÑÂêàÊ≥ïÁöÑÊ¶ÇÁéáÊï∞ÂèëÁé∞cÁöÑÁ¨¨‰∏ÄÁª¥Êó†ÊÑè‰πâÂèØ‰ª•ÁúÅÂéªdpÁöÑÂê´‰πâË¶ÅÊêûÊ∏ÖÊ•ö 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008,mod=998244353;int ni=828542813; int n;char s[N];int a[N];int f[N],c[28],ans;inline LL ksm(LL x,int y)&#123; LL tmp=1; while(y)&#123; if(y&amp;1) tmp=tmp*x%mod; x=x*x%mod; y&gt;&gt;=1; &#125; return tmp;&#125;int main()&#123; n=read(); scanf("%s",s+1); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=0;i&lt;26;++i)&#123; c[i]=1; &#125; f[0]=1; for(int i=1;i&lt;=n;++i)&#123; f[i]=1ll*c[s[i]-'a']*(100-a[i])%mod*ni%mod; for(int j=0;j&lt;26;++j)&#123; if(s[i]-'a'==j)&#123; c[j]=(1ll*c[j]*a[i]%mod*ni%mod+f[i])%mod; &#125; else&#123; c[j]=(c[j]+f[i])%mod; &#125; &#125; &#125; for(int i=0;i&lt;=n;++i)&#123; ans=(ans+f[i])%mod; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3989 [SHOI2013]Èò∂‰πòÂ≠óÁ¨¶‰∏≤ÔºàÂ∫èÂàóËá™Âä®Êú∫Ôºâ]]></title>
    <url>%2F2018%2F06%2F07%2Fluogu3989%20%5BSHOI2013%5D%E9%98%B6%E4%B9%98%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[12345Â∫èÂàóËá™Âä®Êú∫Â∞±ÊòØdp„ÄÇ„ÄÇËÆ∞ÂΩïnext[i][26]ÔºåO(26n)ÁöÑÈ¢ÑÂ§ÑÁêÜÔºå‰ªénÂà∞1ÔºåÊØèÊ¨°a[26]ËÆ∞ÂΩïÊúÄÂêéÂá∫Áé∞ÁöÑ‰ΩçÁΩÆÔºåÁÑ∂ÂêéÂ§çÂà∂ÁªônextÂ∞±ÂèØ‰ª•‰∫ÜÔºànextÊòØdagÔºâÁä∂ÂéãÂä†ÊâãÁÆó‰ºòÂåñÔºàÂ§ß‰∫é21Â∞±Êó†Ëß£Êàë‰πü‰∏ç‰ºöËØÅÔºâÂèØ‰ª•ÁúãÁ¨¨‰∏ÄÈÅìÈ≠îÊîπÈ¢òÊûÑÈÄ†Âá∫n^2-2n+4ÁöÑÊï∞ÂàóÔºàÊâÄ‰ª•ÂèØ‰ª•Âç°22Ôºâ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=28,L=458;int T;int n,len;char s[L];int next[L][N];inline void get_next()&#123; for(int i=0;i&lt;n;++i)&#123; next[len][i]=next[len+1][i]=len+1; &#125; for(int i=len;i;--i)&#123; for(int j=0;j&lt;n;++j)&#123; next[i-1][j]=next[i][j]; &#125; next[i-1][s[i]-'a']=i; &#125;&#125;int f[1&lt;&lt;21];inline bool dp()&#123; for(int i=1;i&lt;(1&lt;&lt;n);++i)&#123; f[i]=0; //for(int j=0;j&lt;n;++j)&#123; // if((i&gt;&gt;j)&amp;1)&#123; // f[i]=max(f[i],next[f[i^(1&lt;&lt;j)]][j]); // &#125; //&#125; for(int j=i;j;j^=j&amp;-j)&#123; f[i]=max(f[i],next[f[i^(j&amp;-j)]][__builtin_ctz(j)]); &#125; if(f[i]&gt;len) return 0; &#125; return 1;&#125;int main()&#123; T=read(); while(T--)&#123; n=read(); scanf("%s",s+1); if(n&gt;21)&#123; puts("NO"); continue; &#125; len=strlen(s+1); get_next(); if(dp()) puts("YES"); else puts("NO"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>Áä∂Âéã</tag>
        <tag>Â∫èÂàóËá™Âä®Êú∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄêÂ≠¶‰π†Á¨îËÆ∞„ÄëÂêéÁºÄÊï∞ÁªÑ]]></title>
    <url>%2F2018%2F06%2F07%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[ÂêéÁºÄÊï∞ÁªÑÂêºÂïäÔºàÊçÆËØ¥samÊõ¥Â•ΩÂïäÁ≠âÊàëËÇùÂÆåÂêéÁºÄÊï∞ÁªÑÂ∞±ÂéªÁúãsam‰πãÂâçÂ≠¶‰∫Ü‰∏ÄÈÅçÂÄçÂ¢ûÂèàÂøò‰∫ÜËÆ∫Êñá‰∏≠ÁöÑÂèòÈáèÂêçÁÆÄÁõ¥‰∏çËÆ©‰∫∫Â≠¶‰ºöÊää‰∏ãÊ†áÂíåÂê´‰πâËØ¥Ê∏ÖÊ•öÁöÑÂçöÂÆ¢ÊâÄ‰ª•ÊàëÁöÑÊùøÂ≠ê‰∏ÄÂÆöË¶ÅÁªôÊï∞ÁªÑÂê´‰πârk_[i]=jË°®Á§∫ÂêéÁºÄiÁöÑÊéíÂêçrk1[]‰∏≠‰ºöÊúâÁõ∏ÂêåÁöÑÊéíÂêçÔºå‰ΩÜÊòØsa[]ÁöÑ‰∏ãÊ†áÔºà‰πüÂ∞±ÊòØÊéíÂêçÔºâÊòØÊ≤°ÊúâÁõ∏ÂêåÁöÑsa[i]=jË°®Á§∫ÊéíÂêçiÁöÑÂêéÁºÄÂØπÂêéÁºÄiÔºålcp[i]&gt;=lcp[i-1]+1 Â§öÊ¨°Ê±ÇsaÁöÑËØùËÆ∞ÂæóÂÖàÊääcntÊ∏ÖÁ©∫12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;char s[N]; int sa[N],rk[N],a[N],b[N],cnt[N];inline void get_sa()&#123; int m=128; int *rk_1=a,*sa_2=b,*tmp; //for i = 1 to m cnt[i]=0 for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;int lcp[N];inline void get_lcp()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[i]&gt;1)&#123; if(k) --k; int j=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k])&#123; ++k; &#125; lcp[rk[i]]=k; &#125; &#125;&#125;int main()&#123; scanf("%s",s+1); n=strlen(s+1); get_sa(); get_lcp(); for(int i=1;i&lt;=n;++i)&#123; printf("%d ",sa[i]); &#125; puts(""); for(int i=2;i&lt;=n;++i)&#123; printf("%d ",lcp[i]); &#125; return 0;&#125; hihocoder‰∏äÊúâÂõõÈÅìÂêéÁºÄÊï∞ÁªÑÁªèÂÖ∏Â∫îÁî®È¢òhiho1403 ÂêéÁºÄÊï∞ÁªÑ‰∏Ä¬∑ÈáçÂ§çÊóãÂæã ÊúÄÈïøÂèØÈáçÂè†ÈáçÂ§çKÊ¨°Â≠ê‰∏≤ÔºàÂçïË∞ÉÈòüÂàóÔºâ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=20008;int n,k;int s[N];int sa[N],rk[N],lcp[N],a[N],b[N],cnt[N];inline void get_sa()&#123; int m=100; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;inline void get_lcp()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[i]&gt;1)&#123; if(k) --k; int j=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k])&#123; ++k; &#125; lcp[rk[i]]=k; &#125; &#125;&#125;int q[N],he,ta;int ans;int main()&#123; n=read();k=read(); for(int i=1;i&lt;=n;++i)&#123; s[i]=read(); &#125; if(k==1)&#123; printf("%d",n); return 0; &#125; get_sa(); get_lcp(); --k; he=1;ta=0; for(int i=2;i&lt;2+k;++i)&#123; while(he&lt;=ta&amp;&amp;lcp[i]&lt;=lcp[q[ta]])&#123; --ta; &#125; q[++ta]=i; &#125; for(int i=2+k;i&lt;=n;++i)&#123; while(he&lt;=ta&amp;&amp;lcp[i]&lt;=lcp[q[ta]])&#123; --ta; &#125; q[++ta]=i; if(i-q[he]&gt;=k) ++he; ans=max(ans,lcp[q[he]]); &#125; printf("%d",ans); return 0;&#125; hiho1407 ÂêéÁºÄÊï∞ÁªÑ‰∫å¬∑ÈáçÂ§çÊóãÂæã2 ÊúÄÈïø‰∏çÂèØÈáçÂè†ÈáçÂ§çÂ≠ê‰∏≤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;int s[N];int sa[N],rk[N],lcp[N],a[N],b[N],cnt[N];inline void get_sa()&#123; int m=1000; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;inline void get_lcp()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[i]&gt;1)&#123; if(k) --k; int j=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k])&#123; ++k; &#125; lcp[rk[i]]=k; &#125; &#125;&#125;int l,r,mid,ans;int mini,maxi;inline bool ok()&#123; mini=sa[1]; maxi=sa[1]; for(int i=2;i&lt;=n;++i)&#123; if(lcp[i]&lt;mid)&#123; mini=sa[i]; maxi=sa[i]; &#125; else&#123; mini=min(mini,sa[i]); maxi=max(maxi,sa[i]); if(maxi-mini&gt;=mid) return 1; &#125; &#125; return 0;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; s[i]=read(); &#125; get_sa(); get_lcp(); l=0;r=n-1; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(ok())&#123; ans=mid; l=mid+1; &#125; else&#123; r=mid-1; &#125; &#125; printf("%d",ans); return 0;&#125; hiho1415 ÂêéÁºÄÊï∞ÁªÑ‰∏â¬∑ÈáçÂ§çÊóãÂæã3 ÊúÄÈïøÂÖ¨ÂÖ±Â≠ê‰∏≤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=200008;int n1,n;char s[N];int sa[N],rk[N],lcp[N],a[N],b[N],cnt[N];inline void get_sa()&#123; int m=128; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;inline void get_lcp()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[i]&gt;1)&#123; if(k) --k; int j=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) ++k; lcp[rk[i]]=k; &#125; &#125;&#125;int ans;int main()&#123; scanf("%s",s+1); n1=strlen(s+1); s[n1+1]='#'; scanf("%s",s+n1+2); n=strlen(s+1); get_sa(); get_lcp(); for(int i=2;i&lt;=n;++i)&#123; if((sa[i-1]&lt;=n1)^(sa[i]&lt;=n1))&#123; ans=max(ans,lcp[i]); &#125; &#125; printf("%d",ans); return 0;&#125; hiho1419 ÂêéÁºÄÊï∞ÁªÑÂõõ¬∑ÈáçÂ§çÊóãÂæã4 ÈáçÂ§çÊ¨°Êï∞ÊúÄÂ§öÁöÑËøûÁª≠Â≠ó‰∏≤Èîô‰∫ÜÂ•ΩÂ§öÊ¨°Â∞±ÊòØst_revÂíåstÊâìÈîô‰∫ÜÈáçÂÜô‰∫Ü‰∏ÄÈÅç123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;char s[N],s_rev[N];int sa[N],rk[N],lcp[N],a[N],b[N],cnt[N];inline void get_sa()&#123; int m=128; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;inline void get_lcp()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[i]&gt;1)&#123; if(k) --k; int j=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) ++k; lcp[rk[i]]=k; &#125; &#125;&#125;inline void get_sa_rev()&#123; int m=128; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s_rev[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;int rk_rev[N],lcp_rev[N];inline void get_lcp_rev()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk_rev[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk_rev[i]&gt;1)&#123; if(k) --k; int j=sa[rk_rev[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s_rev[i+k]==s_rev[j+k]) ++k; lcp_rev[rk_rev[i]]=k; &#125; &#125;&#125;int st[20][N],st_rev[20][N];inline void get_st()&#123; for(int i=2;i&lt;=n;++i)&#123; st[0][i]=lcp[i]; &#125; for(int i=1;(1&lt;&lt;i)&lt;n;++i)&#123; for(int j=2;j+(1&lt;&lt;i)-1&lt;=n;++j)&#123; st[i][j]=min(st[i-1][j],st[i-1][j+(1&lt;&lt;(i-1))]); &#125; &#125;&#125;inline void get_st_rev()&#123; for(int i=2;i&lt;=n;++i)&#123; st_rev[0][i]=lcp_rev[i]; &#125; for(int i=1;(1&lt;&lt;i)&lt;n;++i)&#123; for(int j=2;j+(1&lt;&lt;i)-1&lt;=n;++j)&#123; st_rev[i][j]=min(st_rev[i-1][j],st_rev[i-1][j+(1&lt;&lt;(i-1))]); &#125; &#125;&#125;inline int rmq(int x,int y)&#123; if(x&gt;y) swap(x,y); int t=log2(y-x); return min(st[t][x+1],st[t][y-(1&lt;&lt;t)+1]);&#125;inline int rmq_rev(int x,int y)&#123; if(x&gt;y) swap(x,y); int t=log2(y-x); return min(st_rev[t][x+1],st_rev[t][y-(1&lt;&lt;t)+1]);&#125;int x,y,ans;int main()&#123; scanf("%s",s+1); n=strlen(s+1); get_sa(); get_lcp(); get_st(); for(int i=1;i&lt;=n;++i)&#123; s_rev[i]=s[n-i+1]; &#125; get_sa_rev(); get_lcp_rev(); get_st_rev(); ans=1; for(int l=1;l&lt;=n/2;++l)&#123; y=l; for(int i=1;i&lt;n/l;++i)&#123; x=y; y+=l; ans=max(ans,(rmq(rk[x],rk[y])+rmq_rev(rk_rev[n-x+1],rk_rev[n-y+1])-1)/l+1); &#125; &#125; printf("%d\n",ans); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;char s[2][N];int sa[N],rk[2][N],lcp[2][N],a[N],b[N],cnt[N];inline void get_sa(int id)&#123; int m=128; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[id][i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;inline void get_lcp(int id)&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[id][sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[id][i])&#123; if(k) --k; int j=sa[rk[id][i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[id][i+k]==s[id][j+k]) ++k; lcp[id][rk[id][i]]=k; &#125; &#125;&#125;int st[2][20][N];inline void get_st(int id)&#123; for(int i=2;i&lt;=n;++i)&#123; st[id][0][i]=lcp[id][i]; &#125; for(int i=1;(1&lt;&lt;i)&lt;n;++i)&#123; for(int j=2;j+(1&lt;&lt;i)-1&lt;=n;++j)&#123; st[id][i][j]=min(st[id][i-1][j],st[id][i-1][j+(1&lt;&lt;(i-1))]); &#125; &#125;&#125;inline int rmq(int id,int x,int y)&#123; if(x&gt;y) swap(x,y); int t=log2(y-x); return min(st[id][t][x+1],st[id][t][y-(1&lt;&lt;t)+1]);&#125;int x,y;int ans;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); scanf("%s",s[0]+1); n=strlen(s[0]+1); for(int i=1;i&lt;=n;++i)&#123; s[1][i]=s[0][n-i+1]; &#125; get_sa(0); get_lcp(0); get_st(0); get_sa(1); get_lcp(1); get_st(1); ans=1; for(int l=1;l&lt;=n/2;++l)&#123; y=l; for(int i=1;i&lt;n/l;++i)&#123; x=y; y+=l; ans=max(ans,(rmq(0,rk[0][x],rk[0][y])+rmq(1,rk[1][n-x+1],rk[1][n-y+1])-1)/l+1); &#125; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>ÂêéÁºÄÊï∞ÁªÑ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[È≠îÊîπÈ¢ò]]></title>
    <url>%2F2018%2F06%2F07%2F%E9%AD%94%E6%94%B9%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.Ê±ÇÂ≠êÂ∫èÂàóÂåÖÂê´1Âà∞nÁöÑÂÖ®ÊéíÂàóÁöÑÊï∞ÂàóÁöÑÈïøÂ∫¶ÁöÑÊúÄÂ∞èÂÄºhttps://ipsc.ksp.sk/2013/problems DÂíåRhttps://ipsc.ksp.sk/2013/real/solutions/booklet.pdfÊòØopen questionÊúâ‰∏ÄÁßçÊûÑÈÄ†n^2-2n+4n=1,ans=1,a[1]=1;n=2,ans=3,a[1]=1,a[2]=2,a[3]=1;n=3,ans=7,a[]=1,2,1,3,1,2,1;n=4,ans=12,a[]=1,2,3,4,1,2,3,1,4,2,1,3;n=5,ans=19,a[]=1,5,2,3,4,5,1,2,3,5,4,1,2,5,3,4,1,5,2;]]></content>
      <tags>
        <tag>È¢òÁõÆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊùÇ]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%9D%82%2F</url>
    <content type="text"><![CDATA[6.6‰∏çË¶ÅÂú®Â≠¶Ê†°ÈáåÈù¢ÊâìÂç∞ÂïäÂïäÂïä0.8ÂÖÉ‰∏ÄÂº†Ë∂ÖË¥µÁöÑÂú®ÂÆ∂Êâì‰∏Ä‰ªΩÂà∞Â≠¶Ê†°Â§çÂç∞0.15ÂÖÉ‰∏ÄÂº† 6.14ÂèëÁé∞ÈóÆÈ¢òÊâçÊòØÊúÄÂõ∞ÈöæÁöÑÂïäÊáµÊáµÊáÇÊáÇËøûÈóÆÈ¢òÈÉΩÈóÆ‰∏çÂá∫Êù•ËØ¥ÊòéÊòØÁúüÁöÑÊ≤°ÁêÜËß£ÂèëÁé∞ÈóÆÈ¢òËµ∑Á†ÅËØ¥ÊòéÊÄùË∑ØÊòØÊ∏ÖÊô∞ÁöÑÔºàÂèØËÉΩ‰∏çÂØπÔºüÔºâ]]></content>
      <tags>
        <tag>ÂøÉÊÉÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu4503 [CTSC2014]‰ºÅÈπÖQQ]]></title>
    <url>%2F2018%2F06%2F05%2Fluogu4503%20%5BCTSC2014%5D%E4%BC%81%E9%B9%85QQ%2F</url>
    <content type="text"><![CDATA[123456789ÂçïhashË¢´Âç°Êàë‰πüÂæàÊó†Â•àÔºàÊòéÊòéÂæàÊ≠£Â∏∏Â•ΩÂêóÔºâ‰ΩÜÊòØrk1Â±ÖÁÑ∂ÊòØÂçïhash„ÄÇ„ÄÇ233Êó†ÊïåÂïä‰∏çËøáÊàë233Â∞±a‰∏ç‰∫ÜÊå∫ÁÆÄÂçïÁöÑÂ∞±ÊòØË¶ÅÂèåhashhzwÁöÑÂÅöÊ≥ï‰πüÊå∫Âº∫ÁöÑÂâçÂêéÂêÑ‰∏ÄËæπhashÔºåÊØèÊ¨°Â∫ïÊï∞‰∏ç‰∏ÄÊ†∑ÂèçÊ≠£‰∏çË¶ÅËÆ©Âà†ÊéâÁöÑÈÇ£‰∏Ä‰ΩçÊúâË¥°ÁåÆÂ∞±Ë°åÊÄé‰πàÂÅö‰Ω†ÂºÄÂøÉÂ∞±Â•Ω 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=30008,L=208,base=521,base2=1999;int n,l;char s[N][L];int len[N];LL hash[N],mi[L],hash2[N],mi2[L];struct node&#123; int x,y;&#125;tmp[N];int cnt,ans;inline bool cmp(const node &amp;a,const node &amp;b)&#123; if(a.x!=b.x) return a.x&lt;b.x; return a.y&lt;b.y;&#125;int main()&#123; n=read();l=read();cnt=read(); mi[0]=mi2[0]=1; for(int i=1;i&lt;L;++i)&#123; mi[i]=mi[i-1]*base; mi2[i]=mi2[i-1]*base2; &#125; for(int i=1;i&lt;=n;++i)&#123; scanf("%s",s[i]+1); for(int j=1;j&lt;=l;++j)&#123; hash[i]=hash[i]*base+s[i][j]; hash2[i]=hash2[i]*base2+s[i][j]; &#125; &#125; for(int i=1;i&lt;=l;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; tmp[j].x=hash[j]-s[j][i]*mi[l-i]; tmp[j].y=hash2[j]-s[j][i]*mi2[l-i]; &#125; sort(tmp+1,tmp+n+1,cmp); cnt=1; for(int j=2;j&lt;=n;++j)&#123; if(tmp[j].x==tmp[j-1].x&amp;&amp;tmp[j].y==tmp[j-1].y)&#123; ans+=cnt; ++cnt; &#125; else&#123; cnt=1; &#125; &#125; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3502 [POI2010]Hamsters]]></title>
    <url>%2F2018%2F06%2F05%2Fluogu3502%20%5BPOI2010%5DHamsters%2F</url>
    <content type="text"><![CDATA[1234567891011121314Âõ†‰∏∫ÂçïËØçÊï∞ÊØîËæÉÂ∞ë‰∏çË¶Å‰∏Ä‰∏™Â≠óÁ¨¶‰∏Ä‰∏™Â≠óÁ¨¶ËÄÉËôëËÄÉËôë‰∏Ä‰∏™ÂçïËØçÂà∞‰∏Ä‰∏™ÂçïËØçÁöÑËΩ¨ÁßªÊ±ÇÂá∫iÂà∞jÁöÑËΩ¨ÁßªÔºàÁî®hashÔºåÂ§çÊùÇÂ∫¶ÊòØO(sum(len)*n))È¢òÁõÆÂèòÊàêÊ±ÇÂá∫Âú®n‰∏™ÁÇπÁöÑÂõæ‰∏äËµ∞kÊ≠•ÊúÄÂ∞ëÁöÑËæπÊùÉÂíåkÂ∞èÁöÑËØùÂèØ‰ª•O(nk)dpkÂ§ßÁöÑËØùËÄÉËôëdp‰ºòÂåñÔºåÁü©Èòµ+ÂÄçÂ¢ûÔºåÈ¢ÑÂ§ÑÁêÜÂá∫Ëµ∞2ÁöÑÂπÇÊ≠•ÁöÑÊúÄÂ∞èËæπÊùÉÂíåÁäØ‰∫Ü‰∏ÄÂ†ÜÈîôÔºöi/jÊâìÈîômi[0]Ê≤°ÊúâÂàùÂßãÂåñÂ∞ëbreakÔºåbreakÂêé‰∏çÊâßË°å++i!Êï∞ÁªÑÂºÄÂ∞è‰∫ÜhashÂíåmiË¶ÅÊ±ÇÂêåÁ±ªÂûã ``` #include #define mp make_pair #define pb push_backusing namespace std;typedef long long LL;typedef pair PII;inline LL read(){ LL x=0,f=1;char ch=getchar(); while(ch&lt;‚Äô0‚Äô||ch&gt;‚Äô9‚Äô){if(ch==‚Äô-‚Äò)f=-1;ch=getchar();} while(ch&gt;=‚Äô0‚Äô&amp;&amp;ch&lt;=‚Äô9‚Äô){x=(x&lt;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>ÂÄçÂ¢û</tag>
        <tag>hash</tag>
        <tag>Áü©Èòµ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3538 [POI2012]A Horrible Poem]]></title>
    <url>%2F2018%2F06%2F04%2Fluogu3538%20%5BPOI2012%5DA%20Horrible%20Poem%2F</url>
    <content type="text"><![CDATA[1234567891011hash1.Ëá™ÁÑ∂Ê∫¢Âá∫ÔºållÊàñullÈÉΩÂèØ‰ª•Ôºå‰∏çÈúÄË¶ÅÊ®°Êï∞ÔºåÂø´ÔºåÂèØËÉΩ‰ºöË¢´Âç°2.ÂèñÊ®°ÔºåÊ≥®ÊÑèÊ∞∏Ëøú‰∏çË¶ÅÂèòÊàêË¥üÂÄºÔºåÂÄºÂüüÊéßÂà∂Âú®[0,p)ÔºåÂõ†‰∏∫ÂèòÊàêË¥üÂÄºÁõ∏ÂΩì‰∫é‰∏ÄÁßçÂèñÊ®°3.ÂèåhashÔºöhash1+hash2ÔºåÂèØËÉΩ‰ºöË¢´Âç°Â∏∏Âà§Êñ≠‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÁöÑÂæ™ÁéØËäÇÔºöÊûö‰∏ælenÔºàlenÊï¥Èô§|s|)ÁÑ∂ÂêéÂà§Êñ≠Ââç|s|-lenÂíåÂêé|s|-len‰∏™ÁöÑhashÂÄºÊòØÂê¶Áõ∏ÂêåÂØπÊØè‰∏™ËØ¢ÈóÆÔºå‰∏çÊñ≠Èô§‰ª•ÈïøÂ∫¶ÁöÑË¥®Âõ†Êï∞Âπ∂Âà§Êñ≠ÊÄªÂ§çÊùÇÂ∫¶ÊòØO(n+qlogn)ÂÖàÁ∫øÊÄßÁ≠õÊ±ÇÂá∫ÊØè‰∏™Êï∞ÁöÑÊúÄÂ∞èË¥®Âõ†Êï∞ÔºåÁÑ∂ÂêéÂèØ‰ª•Âú®O(ÊÄªÂõ†Êï∞‰∏™Êï∞)ÂÜÖÊ±ÇÂá∫1Âà∞nÁöÑÂõ†Êï∞‰∏™Êï∞ Ëá™ÁÑ∂Ê∫¢Âá∫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008,base=233;int n,qn;char s[N];int l,r;int hash[N],mi[N];bool vis[N];int pri[N],li_pri[N],num;vector&lt;int&gt; factor[N];inline void shai()&#123; for(int i=2;i&lt;=n;++i)&#123; if(!vis[i])&#123; pri[++num]=i; li_pri[i]=i; factor[i].pb(i); &#125; else&#123; factor[i].pb(li_pri[i]); int tmp=i; tmp/=li_pri[i]; for(int j=0;j&lt;factor[tmp].size();++j)&#123; if(factor[i][factor[i].size()-1]!=factor[tmp][j]) factor[i].pb(factor[tmp][j]); &#125; &#125; for(int j=1;j&lt;=n&amp;&amp;pri[j]*i&lt;=n;++j)&#123; vis[pri[j]*i]=1; li_pri[pri[j]*i]=pri[j]; if(i%pri[j]==0) break; &#125; &#125;&#125;inline int get_hash(int l,int r)&#123; return hash[r]-hash[l-1]*mi[r-l+1];&#125;int main()&#123; n=read(); //scanf(&quot;%s&quot;,s+1); gets(s+1); mi[0]=1; for(int i=1;i&lt;=n;++i)&#123; hash[i]=hash[i-1]*base+s[i]; mi[i]=mi[i-1]*base; &#125; shai(); qn=read(); while(qn--)&#123; l=read();r=read(); if(l==r)&#123; puts(&quot;1&quot;); continue; &#125; int tmp=r-l+1,ans=tmp; for(int i=0;i&lt;factor[tmp].size();++i)&#123; while(ans%factor[tmp][i]==0&amp;&amp;get_hash(l,r-ans/factor[tmp][i])==get_hash(l+ans/factor[tmp][i],r))&#123; ans/=factor[tmp][i]; &#125; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; Âçïhash12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008,base=233,mod=998244353;int n,qn;char s[N];int l,r;int hash[N],mi[N];bool vis[N];int pri[N],li_pri[N],num;vector&lt;int&gt; factor[N];inline void shai()&#123; for(int i=2;i&lt;=n;++i)&#123; if(!vis[i])&#123; pri[++num]=i; li_pri[i]=i; factor[i].pb(i); &#125; else&#123; factor[i].pb(li_pri[i]); int tmp=i; tmp/=li_pri[i]; for(int j=0;j&lt;factor[tmp].size();++j)&#123; if(factor[i][factor[i].size()-1]!=factor[tmp][j]) factor[i].pb(factor[tmp][j]); &#125; &#125; for(int j=1;j&lt;=n&amp;&amp;pri[j]*i&lt;=n;++j)&#123; vis[pri[j]*i]=1; li_pri[pri[j]*i]=pri[j]; if(i%pri[j]==0) break; &#125; &#125;&#125;inline int get_hash(int l,int r)&#123; return (hash[r]-1ll*hash[l-1]*mi[r-l+1]%mod+mod)%mod;&#125;int main()&#123; n=read(); //scanf(&quot;%s&quot;,s+1); gets(s+1); mi[0]=1; for(int i=1;i&lt;=n;++i)&#123; hash[i]=(1ll*hash[i-1]*base%mod+s[i])%mod; mi[i]=1ll*mi[i-1]*base%mod; &#125; shai(); qn=read(); while(qn--)&#123; l=read();r=read(); if(l==r)&#123; puts(&quot;1&quot;); continue; &#125; int tmp=r-l+1,ans=tmp; for(int i=0;i&lt;factor[tmp].size();++i)&#123; while(ans%factor[tmp][i]==0&amp;&amp;get_hash(l,r-ans/factor[tmp][i])==get_hash(l+ans/factor[tmp][i],r))&#123; ans/=factor[tmp][i]; &#125; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; Âèåhash12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008,base=233,mod=998244353;int n,qn;char s[N];int l,r;int hash1[N],mi1[N],hash2[N],mi2[N];bool vis[N];int pri[N],li_pri[N],num;vector&lt;int&gt; factor[N];inline void shai()&#123; for(int i=2;i&lt;=n;++i)&#123; if(!vis[i])&#123; pri[++num]=i; li_pri[i]=i; factor[i].pb(i); &#125; else&#123; factor[i].pb(li_pri[i]); int tmp=i; tmp/=li_pri[i]; for(int j=0;j&lt;factor[tmp].size();++j)&#123; if(factor[i][factor[i].size()-1]!=factor[tmp][j]) factor[i].pb(factor[tmp][j]); &#125; &#125; for(int j=1;j&lt;=n&amp;&amp;pri[j]*i&lt;=n;++j)&#123; vis[pri[j]*i]=1; li_pri[pri[j]*i]=pri[j]; if(i%pri[j]==0) break; &#125; &#125;&#125;inline int get_hash1(int l,int r)&#123; return hash1[r]-hash1[l-1]*mi1[r-l+1];&#125; inline int get_hash2(int l,int r)&#123; return (hash2[r]-1ll*hash2[l-1]*mi2[r-l+1]%mod+mod)%mod;&#125;int main()&#123; n=read(); //scanf(&quot;%s&quot;,s+1); gets(s+1); mi1[0]=mi2[0]=1; for(int i=1;i&lt;=n;++i)&#123; hash1[i]=hash1[i-1]*base+s[i]; mi1[i]=mi1[i-1]*base; hash2[i]=(1ll*hash2[i-1]*base%mod+s[i])%mod; mi2[i]=1ll*mi2[i-1]*base%mod; &#125; shai(); qn=read(); while(qn--)&#123; l=read();r=read(); if(l==r)&#123; puts(&quot;1&quot;); continue; &#125; int tmp=r-l+1,ans=tmp; for(int i=0;i&lt;factor[tmp].size();++i)&#123; while(ans%factor[tmp][i]==0&amp;&amp;get_hash1(l,r-ans/factor[tmp][i])==get_hash1(l+ans/factor[tmp][i],r)&amp;&amp;get_hash2(l,r-ans/factor[tmp][i])==get_hash2(l+ans/factor[tmp][i],r))&#123; ans/=factor[tmp][i]; &#125; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3691 DNA repair]]></title>
    <url>%2F2018%2F06%2F01%2Fpoj3691%20DNA%20repair%2F</url>
    <content type="text"><![CDATA[123456Âú®acËá™Âä®Êú∫‰∏ädpf[i][j]Ë°®Á§∫ÂåπÈÖç‰∏≤Âà∞Á¨¨i‰ΩçÔºåÂú®acËá™Âä®Êú∫‰∏äË∑ëÂà∞j‰ΩçÁΩÆÁöÑÊúÄÂ∞è‰øÆÊîπÊ¨°Êï∞acËá™Âä®Êú∫‰∏äÊØè‰∏™ÁÇπË¶ÅÊàñ‰∏äfailÊ†ë‰∏äÁöÑÊØè‰∏Ä‰∏™Á•ñÂÖàÂèØ‰ª•Âú®Ê±ÇfailÊåáÈíà‰πãÂêéÊ±ÇÂá∫Â§öÊµãÊ≥®ÊÑèÊÉÖÂÜµÊï∞ÁªÑÂíåÂèòÈáèÔºàÂèòÈáèÂèòÈáèÂèòÈáèÔºâszÊ≤°Ê∏ÖÁ©∫ÁÑ∂ÂêéreÂ•Ω‰πÖ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int n,cas,mapping[128];char s[N];struct node&#123; int ch[5],fail; bool num;&#125;t[N];int sz;inline void inser()&#123; int u=0,c,n=strlen(s+1); for(int i=1;i&lt;=n;++i)&#123; c=mapping[s[i]]; if(!t[u].ch[c]) t[u].ch[c]=++sz; u=t[u].ch[c]; &#125; t[u].num=1;&#125;int q[N];inline void get_ac()&#123; int he=1,ta=1; for(int i=1;i&lt;=4;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; &#125; while(he!=ta)&#123; int x=q[he]; ++he; t[x].num|=t[t[x].fail].num; for(int i=1;i&lt;=4;++i)&#123; if(!t[x].ch[i])&#123; t[x].ch[i]=t[t[x].fail].ch[i]; &#125; else&#123; t[t[x].ch[i]].fail=t[t[x].fail].ch[i]; q[ta]=t[x].ch[i]; ++ta; &#125; &#125; &#125;&#125;int f[N][N],ans;inline void solve()&#123; memset(f,0x3f,sizeof(f)); int n=strlen(s+1); f[0][0]=0; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;=sz;++j)&#123; if(f[i][j]&lt;0x3f3f3f3f)&#123; int tmp=t[j].ch[mapping[s[i+1]]]; if(!t[tmp].num)&#123; f[i+1][tmp]=min(f[i+1][tmp],f[i][j]); &#125; for(int k=1;k&lt;=4;++k)&#123; if(!t[t[j].ch[k]].num) f[i+1][t[j].ch[k]]=min(f[i+1][t[j].ch[k]],f[i][j]+1); &#125; &#125; &#125; &#125; ans=0x3f3f3f3f; for(int i=0;i&lt;=sz;++i)&#123; ans=min(ans,f[n][i]); &#125; printf(&quot;Case %d: &quot;,++cas); if(ans==0x3f3f3f3f) puts(&quot;-1&quot;); else printf(&quot;%d\n&quot;,ans);&#125;int main()&#123; mapping[&apos;A&apos;]=1;mapping[&apos;G&apos;]=2;mapping[&apos;C&apos;]=3;mapping[&apos;T&apos;]=4; while((n=read()))&#123; memset(t,0,sizeof(t)); sz=0;//// for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s+1); inser(); &#125; scanf(&quot;%s&quot;,s+1); get_ac(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>acËá™Âä®Êú∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2336 [SCOI2012]ÂñµÊòüÁêÉ‰∏äÁöÑÁÇπÂêç]]></title>
    <url>%2F2018%2F05%2F31%2Fluogu2336%20%5BSCOI2012%5D%E5%96%B5%E6%98%9F%E7%90%83%E4%B8%8A%E7%9A%84%E7%82%B9%E5%90%8D%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617‰πüÊòØÁ•ûÈ¢ò‰∫ÜÂ≠óÁ¨¶‰∏≤ÁªºÂêàÈ¢òÂêÑÁßçÂÅöÊ≥ïacËá™Âä®Êú∫Êö¥ÂäõËøá‰∏ç‰∫ÜÔºüÂÅáÁöÑzyzÁöÑÊö¥ÂäõË∑ëÂæóÈ£ûÂø´ËÄå‰∏îÂæàÈöæÂç°ÔºàÊàëÊÉ≥‰∫ÜÂçäÂ§©‰πüÊûÑÈÄ†‰∏çÂá∫Êù•Ôºâ‰∏Ä‰∏™ÊúâÂ§çÊùÇÂ∫¶‰øùËØÅÁöÑÂÅöÊ≥ïQ1Â∞±ÊòØfailÊ†ë‰∏≠‰∏Ä‰∏™ÁÇπÁöÑÂ≠êÊ†ë‰∏≠ÊúâÂ§öÂ∞ë‰∏™‰∏çÂêåÁöÑÊ†áËÆ∞ÂØπ‰∫éÂêå‰∏Ä‰∏™ÂêçÂ≠óÂ∞ÜÂÆÉÂú®failÊ†ë‰∏≠ÊâÄÊúâÁöÑÁÇπÊåâdfnÊéíÂ∫èÔºåÂú®dfsÂ∫è‰∏äÊâìÊ†áËÆ∞ÊØè‰∏™ÁÇπËá™Ë∫´+1ÔºåÂíåÂâç‰∏Ä‰∏™ÁÇπÁöÑlcaÂ§Ñ-1ÔºåËøôÊ†∑ÂèØ‰ª•‰øùËØÅÊØè‰∏™ÂêçÂ≠óÂú®‰∏ÄÈ¢óÂ≠êÊ†ë‰∏≠Âè™‰∫ßÁîü1ÁöÑË¥°ÁåÆQ2Â∞±ÊòØÈóÆ‰∏Ä‰∏™ÁÇπÂà∞Ê†πÊúâÂ§öÂ∞ëÁÇπÂêç‰∏≤Âú®inÁöÑÂú∞Êñπ+1Ôºåout+1ÁöÑÂú∞Êñπ-1ÔºåËøôÊ†∑ÂèØ‰ª•‰øùËØÅÊØè‰∏™ÂêçÂ≠óÂè™‰ºöËÄÉËôëÂú®ÂÆÉÁöÑÊ†πÁöÑË∑ØÂæÑ‰∏äÁöÑÁÇπËøòÊòØË¶ÅÂáèÊéâlca ÊúâÂ§çÊùÇÂ∫¶‰øùËØÅÁöÑÂÅöÊ≥ï123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int len,x;vector&lt;int&gt; a[N];map&lt;int,int&gt; t[N];int sz,fail[N];int nume,head[N];struct edge&#123; int to,nxt;&#125;e[N];inline void addedge(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;int pos[N];inline void inser(int id)&#123; int u=0; len=read(); for(int i=1;i&lt;=len;++i)&#123; x=read(); if(!t[u][x])&#123; t[u][x]=++sz; &#125; u=t[u][x]; &#125; pos[id]=u;&#125;int q[N],he,ta;map&lt;int,int&gt;::iterator it;inline void getfail()&#123; he=1;ta=2; q[1]=0; while(he!=ta)&#123; int x=q[he]; ++he; for(it=t[x].begin();it!=t[x].end();++it)&#123; int t1=it-&gt;first,t2=it-&gt;second; if(x==0)&#123; fail[t2]=0; addedge(0,t2); &#125; else&#123; int k=fail[x]; while(k!=0&amp;&amp;t[k].find(t1)==t[k].end())&#123; k=fail[k]; &#125; int tmp=t[k][t1]; fail[t2]=tmp; addedge(tmp,t2); &#125; q[ta]=t2; ++ta; &#125; &#125;&#125;int in[N],out[N],dfc,fa[N][20],dep[N];inline void dfs(int x)&#123; in[x]=++dfc; for(int i=1;i&lt;=18;++i)&#123; if(dep[x]&gt;=(1&lt;&lt;i))&#123; fa[x][i]=fa[fa[x][i-1]][i-1]; &#125; &#125; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x][0])&#123; fa[e[i].to][0]=x; dep[e[i].to]=dep[x]+1; dfs(e[i].to); &#125; &#125; out[x]=dfc;&#125;inline int lca(int x,int y)&#123; if(x==y) return x; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=18;i&gt;=0;--i)&#123; if(dep[x]&gt;=dep[y]+(1&lt;&lt;i))&#123; x=fa[x][i]; &#125; &#125; if(x==y) return x; for(int i=18;i&gt;=0;--i)&#123; if(fa[x][i]!=fa[y][i])&#123; x=fa[x][i]; y=fa[y][i]; &#125; &#125; return fa[x][0];&#125;int bit1[N],bit2[N];inline void add(int *bit,int x,int pos)&#123; for(int i=pos;i&lt;=dfc;i+=i&amp;-i)&#123; bit[i]+=x; &#125;&#125;inline int query(int *bit,int pos)&#123; int tmp=0; for(int i=pos;i;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125; int b[N],vis[N],ans[N];inline bool cmp(const int &amp;a,const int &amp;b)&#123; return in[a]&lt;in[b];&#125;inline void solve(int id)&#123; int u=0,len=0; for(int i=0;i&lt;a[id].size();++i)&#123; while(u&amp;&amp;t[u].find(a[id][i])==t[u].end())&#123; u=fail[u]; &#125; if(t[u].find(a[id][i])!=t[u].end())&#123; u=t[u][a[id][i]]; &#125; if(vis[u]!=id) b[++len]=u; vis[u]=id; &#125; sort(b+1,b+len+1,cmp); ans[id]+=query(bit1,in[b[1]]); add(bit2,1,in[b[1]]); for(int i=2;i&lt;=len;++i)&#123; ans[id]+=query(bit1,in[b[i]]); ans[id]-=query(bit1,in[lca(b[i],b[i-1])]); add(bit2,1,in[b[i]]); add(bit2,-1,in[lca(b[i],b[i-1])]); &#125;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; len=read(); while(len--)&#123; x=read(); a[i].pb(x); &#125; a[i].pb(-1); len=read(); while(len--)&#123; x=read(); a[i].pb(x); &#125; &#125; for(int i=1;i&lt;=m;++i)&#123; inser(i); &#125; getfail(); dfs(0); for(int i=1;i&lt;=m;++i)&#123; add(bit1,1,in[pos[i]]); add(bit1,-1,out[pos[i]]+1); &#125; for(int i=1;i&lt;=n;++i)&#123; solve(i); &#125; for(int i=1;i&lt;=m;++i)&#123; printf(&quot;%d\n&quot;,query(bit2,out[pos[i]])-query(bit2,in[pos[i]]-1)); &#125; for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%d &quot;,ans[i]); &#125; return 0;&#125; Êö¥Âäõ„ÄÇ„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int ans1[N],ans2[N];vector&lt;int&gt; a[N],V;int num[N],pos[N],q[N];map&lt;int,int&gt; to[N];bool vis[N];int sz;struct data&#123; int fail[N]; inline void insert(int id)&#123; int L=read(),x; int u=0; for(int i=1;i&lt;=L;i++) &#123; x=read(); if(!to[u][x])to[u][x]=++sz; u=to[u][x]; &#125; ++num[u]; pos[id]=u; &#125; inline void buildfail()&#123; int head=0,tail=0; for(map&lt;int,int&gt;::iterator i=to[0].begin();i!=to[0].end();++i)&#123; q[tail++]=i-&gt;second; &#125; while(head!=tail) &#123; int x=q[head];head++; for(map&lt;int,int&gt;::iterator i=to[x].begin();i!=to[x].end();++i) &#123; int t=i-&gt;first,k=fail[x]; while(k&amp;&amp;to[k].find(t)==to[k].end())&#123; k=fail[k]; &#125; if(to[k].find(t)!=to[k].end()) fail[i-&gt;second]=to[k][t]; q[tail++]=i-&gt;second; &#125; &#125; &#125; inline void get(int id,int x)&#123; for(int i=x;i;i=fail[i]) if(!vis[i]) &#123; vis[i]=1;V.push_back(i); ++ans1[i]; ans2[id]+=num[i]; &#125; else return; &#125; inline void solve(int x)&#123; int u=0; for(int i=0;i&lt;a[x].size();i++) &#123; int t=a[x][i]; while(u&amp;&amp;to[u].find(t)==to[u].end()) u=fail[u]; if(to[u].find(t)!=to[u].end()) u=to[u][t]; get(x,u); &#125; for(int i=0;i&lt;V.size();i++)vis[V[i]]=0; V.clear(); &#125;&#125;trie;int main()&#123; n=read();m=read(); int L,x; for(int i=1;i&lt;=n;i++) &#123; L=read(); while(L--)x=read(),a[i].push_back(x); a[i].push_back(-1); L=read(); while(L--)x=read(),a[i].push_back(x); &#125; for(int i=1;i&lt;=m;i++) trie.insert(i); trie.buildfail(); for(int i=1;i&lt;=n;i++) trie.solve(i); for(int i=1;i&lt;=m;i++)printf(&quot;%d\n&quot;,ans1[pos[i]]); for(int i=1;i&lt;=n;i++) &#123; printf(&quot;%d&quot;,ans2[i]); if(i!=n)printf(&quot; &quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ê†ëÁä∂Êï∞ÁªÑ</tag>
        <tag>acËá™Âä®Êú∫</tag>
        <tag>failÊ†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noiÊ®°ÊãüËµõ ÁãÆÈπ´ÊóÖË°å]]></title>
    <url>%2F2018%2F05%2F30%2Fnoi%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E7%8B%AE%E9%B9%AB%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[GriffinDescriptionÁãÆÈπ´ÊòØËÅîÁõüÁöÑ‰∏ªË¶Å‰∫§ÈÄöÂ∑•ÂÖ∑ÔºåÂú®ËâæÊ≥ΩÊãâÊñØÁöÑÂúüÂú∞‰∏äÊï£Â∏ÉÁùÄn‰∏™ÁãÆÈπ´Á´ôÁÇπÔºåÊúâmÊù°ÊúâÂêëÁöÑÈ£ûË°åÁ∫øË∑ØÔºå‰πüÂ∞±ÊòØÊûÑÊàê‰∫Ü‰∏ÄÂº†n‰∏™ÁÇπmÊù°ËæπÁöÑÊúâÂêëÂõæ„ÄÇËøômÊù°Á∫øË∑ØË¢´ÂàÜÊàê‰∫ÜcÁßçÁ≠âÁ∫ßÔºåÂØπ‰∫éÂÖ∂‰∏≠ÁöÑÁ¨¨iÁßçÁ≠âÁ∫ßÔºåÂè™ÊúâÂ£∞ÊúõËææÂà∞‰∫ÜwiÊâçËÉΩ‰πòÂùêÁãÆÈπ´È£ûËøáËøôÊù°Á∫øË∑Ø„ÄÇÂ∞èCÁé∞Âú®Âú®Êö¥È£éÂüéÔºà1Âè∑ÁÇπÔºâÔºå‰ªñË¶ÅËµ∂Âà∞ÊöóÊúàÈ©¨ÊàèÂõ¢ÔºànÂè∑ÁÇπÔºâÂèÇÂä†‰ªñÂ≠¶ÈïøÁöÑÁîµÈü≥Ë°®Êºî„ÄÇ‰Ωú‰∏∫‰∏Ä‰∏™ÂñúÊ¨¢ËóèÈîãÁöÑÂÅ•ÁæéÂÖàÁîüÔºåÂàùÂßãÊó∂‰ªñÂ£∞Êúõ‰∏∫0„ÄÇ‰ΩÜ‰ªñÂÆûÂú®ÊòØÂ§™ÂÅ•Áæé‰∫ÜÔºå‰ª•Ëá≥‰∫é‰ªñÊØè‰πòÂùê‰∏ÄÊ¨°ÁãÆÈπ´ÔºàÂç≥ÁªèËøá‰∏ÄÊù°ËæπÔºâÂ∞±ËÉΩ‰Ωø‰ªñÁöÑÂ£∞Êúõ +1 „ÄÇ‰∏∫‰∫ÜÊõ¥Â•ΩÂú∞ËóèÈîãÔºåÂ∞èC‰∏ç‰ºöÈÄöËøáÂÖ∂‰ªñÊñπÊ≥ïÊù•ÊèêÂçáÂ£∞Êúõ„ÄÇ Â∞èC‰∏çÂñúÊ¨¢Ê≠•Ë°åÔºå‰πü‰∏ç‰ºöÂºÄ‰º†ÈÄÅÈó®ÔºåÊâÄ‰ª•‰ªñ‰∏ç‰ºöÈÄöËøáÈô§‰πòÂùêÁãÆÈπ´‰ª•Â§ñÁöÑÂÖ∂‰ªñÊñπÊ≥ïÊù•Âà∞ËææÂè¶‰∏Ä‰∏™Á´ôÁÇπ„ÄÇÁé∞Âú®‰ªñÊÉ≥Áü•ÈÅìÊòØÂê¶ËÉΩÂà∞ËææÔºåÂ¶ÇÊûúËÉΩÔºå‰ªñËøòÊÉ≥Áü•ÈÅì‰ªñÊúÄÂ∞ëË¶ÅÁªèËøáÂ§öÂ∞ëÊù°ËæπÊâçËÉΩÂà∞Ëææ„ÄÇ Input‰ªéÊñá‰ª∂griffin.in‰∏≠ËØªÂÖ•Êï∞ÊçÆ.Á¨¨‰∏ÄË°å‰∏â‰∏™Êï¥Êï∞n, m, c.Êé•‰∏ãÊù•mË°åÔºåÊØèË°å‰∏â‰∏™Êï¥Êï∞u, v, lvÔºåË°®Á§∫Êúâ‰∏ÄÊù°uÂà∞vÁöÑÁ∫øË∑ØÔºåÁ≠âÁ∫ß‰∏∫lv.Êé•‰∏ãÊù•‰∏ÄË°åc‰∏™Êï¥Êï∞ÔºåÁ¨¨i‰∏™Ë°®Á§∫wi. OutputËæìÂá∫Âà∞Êñá‰ª∂griffin.out‰∏≠.Ëã•‰∏çËÉΩÂà∞ËææËæìÂá∫Impossible„ÄÇÂê¶ÂàôËæìÂá∫‰∏Ä‰∏™Êï¥Êï∞Ë°®Á§∫‰ªñÊúÄÂ∞ëË¶ÅÁªèËøáÁöÑËæπÊï∞„ÄÇ Sample1 Input3 2 21 2 12 3 20 2 OutputImpossibleSample2 Input3 3 21 2 12 1 12 3 20 2 Output4 12345678910111213%dyÂØπÁü©ÈòµÂíåÂõæÁöÑÂÖ≥Á≥ªÁöÑÁêÜËß£ÂèàÂä†Ê∑±‰∫ÜËøôÂº†Âõæ‰∏ÄÂºÄÂßãÊâÄÊúâËæπÈÉΩÊòØ‰∏äÈîÅÁöÑÂΩì‰Ω†ÊØèËææÂà∞‰∏ÄÂÆöÁ≠âÁ∫ßÂ∞±ËÉΩËß£ÈîÅËΩ¨ÁßªÁü©Èòµ‰ºöÈÄêÊ∏êÊâ©Â§ßËøáÁ®ãÂ§ßÊ¶ÇÊòØÔºöÂÖàËµ∞val[i]-val[i-1]Ê≠•ËΩ¨ÁßªÂà∞ÂΩìÂâçÂèØÁî®ÁöÑÁÇπ(state)Ôºà‰∏Ä‰∏™‰∏ÄÁª¥ÂêëÈáèÔºâËã•state‰∏∫Á©∫ÔºåËØ¥ÊòéÊó†Ëß£Âê¶ÂàôÂ∞±ÂèØ‰ª•Ëß£ÈîÅ‰∫ÜÔºåÊâ©Â±ï‰∏Ä‰∏ãËΩ¨ÁßªÁü©Èòµ(omat)Ëß£ÈîÅÂΩìÂâçÁ≠âÁ∫ßÂêéÂà§Êñ≠‰∏Ä‰∏ãËÉΩ‰∏çËÉΩÂà∞ËæænÔºåÁî®bfsÁî®bitset‰ºòÂåñ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=188,M=40008,C=58;int n,m,cn;int val[C];struct data&#123; int u,v,w; inline bool operator &lt;(const data &amp;b) const&#123; return w&lt;b.w; &#125;&#125;arr[M];bitset&lt;N&gt; state[N],omat[N],mat[N],tmp[N];//stateÂ∞±ÊòØ‰∏Ä‰∏™1Áª¥ÂêëÈáè int cur,ans;int q[N],dis[N];inline void update(bitset&lt;N&gt; *a,bitset&lt;N&gt; *b)&#123; for(int i=1;i&lt;=n;++i)&#123; tmp[i].reset(); &#125; for(int i=1;i&lt;=n;++i)&#123; for(int k=1;k&lt;=n;++k)&#123; if(a[i][k])&#123; tmp[i]|=b[k]; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]=tmp[i]; &#125;&#125; inline int bfs()&#123; int he=1,ta=1; memset(dis,0x3f,sizeof(dis)); for(int i=1;i&lt;=n;++i)&#123; if(state[1][i])&#123; q[ta]=i; ++ta; dis[i]=0; &#125; &#125; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=1;i&lt;=n;++i)&#123; if(omat[x][i]&amp;&amp;dis[i]&gt;dis[x]+1)&#123; dis[i]=dis[x]+1; q[ta]=i; ++ta; &#125; &#125; &#125; return dis[n];&#125;int main()&#123; n=read();m=read();cn=read(); for(int i=1;i&lt;=m;++i)&#123; arr[i].u=read(); arr[i].v=read(); arr[i].w=read(); &#125; sort(arr+1,arr+m+1); for(int i=1;i&lt;=cn;++i)&#123; val[i]=read(); &#125; state[1][1]=1; cur=1; ans=0x3f3f3f3f; for(int i=1;i&lt;=cn;++i)&#123; int x=val[i]-val[i-1]; for(int j=1;j&lt;=n;++j)&#123; mat[j]=omat[j]; &#125; while(x)&#123; if(x&amp;1) update(state,mat); update(mat,mat); x&gt;&gt;=1; &#125; for(int j=1;j&lt;=n;++j)&#123; if(state[j].any()) break; if(j==n)&#123; puts(&quot;Impossible&quot;); return 0; &#125; &#125; while(cur&lt;=m&amp;&amp;arr[cur].w&lt;=i)&#123; if(!omat[arr[cur].u][arr[cur].v])&#123; omat[arr[cur].u][arr[cur].v]=1; &#125; ++cur; &#125; int tmp=bfs(); ans=min(ans,tmp+val[i]); &#125; if(ans&lt;0x3f3f3f3f) printf(&quot;%d&quot;,ans); else puts(&quot;Impossible&quot;); return 0;&#125;]]></content>
      <tags>
        <tag>ÂõæËÆ∫</tag>
        <tag>Áü©Èòµ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3233 [HNOI2014]‰∏ñÁïåÊ†ë]]></title>
    <url>%2F2018%2F05%2F29%2Fluogu3233%20%5BHNOI2014%5D%E4%B8%96%E7%95%8C%E6%A0%91%2F</url>
    <content type="text"><![CDATA[123456789101112ÊòæÁÑ∂ÊòØËôöÊ†ëÁÑ∂ËÄåÊÄé‰πàdp„ÄÇ„ÄÇÁúãÈ¢òËß£ÁúãÈ¢òËß£„ÄÇ„ÄÇÂÖà‰∏§ÈÅçdfsÊ±ÇÂá∫ËôöÊ†ë‰∏äÊØè‰∏™ÁÇπÂà∞Âì™‰∏™ÁÇπÊúÄËøëÊ≥®ÊÑèÂà∞ËôöÊ†ë‰∏äÁöÑ‰∏ÄÊù°ÈìæÊâÄÂ±ûÁöÑÁÇπ‰∏ÄÂÆöÂíåÊüê‰∏Ä‰∏™Á´ØÁÇπÊòØ‰∏ÄÊ†∑ÁöÑÔºà‰∏∫‰ªÄ‰πàÊàëÊ≤°ÊúâÊ≥®ÊÑèÂà∞ÔºâÁÑ∂ÂêéÂ∞±ÊòØÁúã‰∏§‰∏™Á´ØÁÇπÊòØÂê¶ÊòØÂ±û‰∫éÂêå‰∏Ä‰∏™ÁÇπÊòØÁöÑËØùËØ¥ÊòéÊï¥Êù°ÈìæÂ∞±ÊòØËøô‰∏™ÁÇπÁöÑ‰∏çÊòØÁöÑËØùÂèØ‰ª•ÁÆóÂá∫‰∏≠Èó¥ÁöÑÂàÜÂâ≤ÁÇπÁöÑÊ∑±Â∫¶ÂÄçÂ¢ûÂèØ‰ª•Ê±ÇËäÇÁÇπaÁöÑÊ∑±Â∫¶‰∏∫xÁöÑÁ•ñÂÖàÂÄçÂ¢ûÂ§ßÊ¶ÇÊúâ3ÁßçÂÜôÊ≥ïÔºåËã•Áî®dep[fa[x][i]]&gt;=dep[y]ÔºåËØ∑Â∞ÜÊ†πËäÇÁÇπÁöÑdepËÆæ‰∏∫1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=300008;int num,n,m,qn;int x,y;int nume,head[N];struct edge&#123; int to,nxt;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;int dfn[N],dfc,sz[N],fa[N][20],dep[N];inline void dfs(int x)&#123; dfn[x]=++dfc; sz[x]=1; for(int i=1;(1&lt;&lt;i)&lt;=dep[x];++i)&#123; fa[x][i]=fa[fa[x][i-1]][i-1]; &#125; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x][0])&#123; fa[e[i].to][0]=x; dep[e[i].to]=dep[x]+1; dfs(e[i].to); sz[x]+=sz[e[i].to]; &#125; &#125;&#125;inline int lca(int x,int y)&#123; if(x==y) return x; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=19;i&gt;=0;--i)&#123; if(dep[x]&gt;=dep[y]+(1&lt;&lt;i))&#123;//dep[fa[x][i]]&gt;=dep[y] (1&lt;&lt;i)&amp;bin x=fa[x][i]; &#125; &#125; if(x==y) return x; for(int i=19;i&gt;=0;--i)&#123; if(fa[x][i]!=fa[y][i])&#123; x=fa[x][i]; y=fa[y][i]; &#125; &#125; return fa[x][0]; &#125;int a[N],t[N],ori[N];int s[N],ta;int par[N],dis[N];PII g[N];int rem[N];int ans[N];inline bool cmp(const int &amp;a,const int &amp;b)&#123; return dfn[a]&lt;dfn[b];&#125;inline void addedge_2(int x,int y)&#123; par[y]=x; dis[y]=dep[y]-dep[x];&#125;inline void dp()&#123; for(int i=n;i&gt;1;--i)&#123; int t1=t[i],t2=par[t1]; g[t2]=min(g[t2],mp(g[t1].first+dis[t1],g[t1].second)); &#125; for(int i=2;i&lt;=n;++i)&#123; int t1=t[i],t2=par[t1]; g[t1]=min(g[t1],mp(g[t2].first+dis[t1],g[t2].second)); &#125;&#125;inline int find(int x,int pos)&#123; for(int i=19;i&gt;=0;--i)&#123; if(dep[x]&gt;=pos+(1&lt;&lt;i))&#123; x=fa[x][i]; &#125; &#125; return x;&#125;inline void solve()&#123; m=read();n=0; for(int i=1;i&lt;=m;++i)&#123; t[++n]=ori[i]=a[i]=read(); g[a[i]]=mp(0,a[i]); &#125; sort(a+1,a+m+1,cmp); ta=0; for(int i=1;i&lt;=m;++i)&#123; if(!ta)&#123; s[++ta]=a[i]; &#125; else&#123; int tmp=lca(a[i],s[ta]); while(dfn[tmp]&lt;dfn[s[ta]])&#123; if(dfn[tmp]&gt;=dfn[s[ta-1]])&#123; addedge_2(tmp,s[ta]); --ta; if(s[ta]!=tmp)&#123; s[++ta]=tmp; t[++n]=tmp; g[tmp]=mp(0x3f3f3f3f,0); &#125; break; &#125; else&#123; addedge_2(s[ta-1],s[ta]); --ta; &#125; &#125; s[++ta]=a[i]; &#125; &#125; while(ta&gt;1)&#123; addedge_2(s[ta-1],s[ta]); --ta; &#125; sort(t+1,t+n+1,cmp); dp(); for(int i=1;i&lt;=n;++i)&#123; rem[t[i]]=sz[t[i]]; &#125; ans[g[t[1]].second]=num-sz[t[1]]; for(int i=2;i&lt;=n;++i)&#123; int t1=t[i],t2=par[t1];//par[t1]=0; int tmp=find(t1,dep[t2]-1); rem[t2]-=sz[tmp]; if(g[t1].second==g[t2].second)&#123; ans[g[t1].second]+=sz[tmp]-sz[t1]; &#125; else&#123; int len=g[t1].first+g[t2].first+dis[t1],mid=dep[t1]-(len/2-g[t1].first); if(!(len&amp;1)&amp;&amp;g[t1].second&gt;g[t2].second) ++mid; int tmp2=find(t1,mid); ans[g[t1].second]+=sz[tmp2]-sz[t1]; ans[g[t2].second]+=sz[tmp]-sz[tmp2]; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; ans[g[t[i]].second]+=rem[t[i]]; &#125; for(int i=1;i&lt;=m;++i)&#123; printf(&quot;%d &quot;,ans[ori[i]]); ans[ori[i]]=0; &#125; puts(&quot;&quot;);&#125;int main()&#123; num=n=read(); for(int i=1;i&lt;n;++i)&#123; x=read();y=read(); addedge(x,y); addedge(y,x); &#125; dfs(1); qn=read(); while(qn--)&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ËôöÊ†ë</tag>
        <tag>ÂÄçÂ¢û</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3320 [SDOI2015]ÂØªÂÆùÊ∏∏Êàè]]></title>
    <url>%2F2018%2F05%2F28%2Fluogu3320%20%5BSDOI2015%5D%E5%AF%BB%E5%AE%9D%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[123ÊØèÂä†ÂÖ•‰∏Ä‰∏™ÁÇπÔºåÂÖ∂ÂÆûÂ∞±ÊòØÂú®ËôöÊ†ë‰∏ä‰ªéÂâçÈ©±ÂíåÂêéÁªßÂêëËøô‰∏™ÁÇπËøûËæπËôöÊ†ë‰∏çÈúÄË¶ÅÂª∫ÔºåÁî®setÊ±ÇÂâçÈ©±ÂêéÁªßÁªÜËäÇÔºÅÔºÅ 1.ÊúâÁÇπÈ∫ªÁÉ¶ÔºåÁî®dfnÊ±ÇlcaË¶ÅÊ±Çfa,topfa,dep,dep2ÈÉΩ‰ª•dfn‰∏∫‰∏ãÊ†á123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int x,y,z;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;bool has[N];int num;int dfn[N],dfc,sz[N],fa[N],dep[N],heavyson[N],topfa[N];LL dep2[N];inline void dfs(int x,int f,int p)&#123; dfn[x]=++dfc; dep[dfn[x]]=dep[p]+1; dep2[dfn[x]]=dep2[p]+f; fa[dfn[x]]=p; sz[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(!dfn[e[i].to])&#123; dfs(e[i].to,e[i].f,dfn[x]); sz[x]+=sz[e[i].to]; if(sz[e[i].to]&gt;sz[heavyson[x]])&#123; heavyson[x]=e[i].to; &#125; &#125; &#125;&#125;inline void dfs2(int x,int anc)&#123; topfa[dfn[x]]=dfn[anc]; if(heavyson[x]) dfs2(heavyson[x],anc); for(int i=head[x];i;i=e[i].nxt)&#123; if(dfn[e[i].to]!=fa[dfn[x]]&amp;&amp;e[i].to!=heavyson[x]) dfs2(e[i].to,e[i].to); &#125;&#125;inline int lca(int x,int y)&#123; while(topfa[x]!=topfa[y])&#123; dep[topfa[x]]&gt;dep[topfa[y]]?x=fa[topfa[x]]:y=fa[topfa[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;set&lt;int&gt; s;set&lt;int&gt;::iterator it;LL ans;int t1,t2,t3;inline LL dis(int x,int y)&#123; return dep2[x]+dep2[y]-2*dep2[lca(x,y)];&#125;inline void solve()&#123; if(has[x])&#123; s.insert(dfn[x]); it=s.lower_bound(dfn[x]); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans+=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); &#125; else&#123; it=s.lower_bound(dfn[x]); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans-=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); s.erase(dfn[x]); &#125; printf(&quot;%lld\n&quot;,ans);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;n;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); addedge(y,x,z); &#125; dfs(1,0,0); dfs2(1,1); while(m--)&#123; x=read(); if(has[x])&#123; has[x]=0; --num; &#125; else&#123; has[x]=1; ++num; &#125; if(num&lt;=1)&#123; if(has[x])&#123; s.insert(dfn[x]); &#125; else&#123; s.erase(dfn[x]); &#125; puts(&quot;0&quot;); &#125; else&#123; solve(); &#125; &#125; return 0;&#125; 2.ËÆ∞ÂΩïÊØè‰∏™dfnÂØπÂ∫îÁöÑËäÇÁÇπÔºåËøôÊ†∑‰∏çÈúÄË¶ÅÊîπÊ†ëÂâñ‰∫ÜÔºå‰ΩÜÂ§öÂºÄ‰∏Ä‰∏™Êï∞ÁªÑÔºå‰ºöÊõ¥ÊÖ¢„ÄÇ„ÄÇ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int x,y,z;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;bool has[N];int num;int dfn[N],dfc,sz[N],fa[N],dep[N],heavyson[N],topfa[N],pos[N];LL dep2[N];inline void dfs(int x)&#123; dfn[x]=++dfc; pos[dfc]=x; sz[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(!dfn[e[i].to])&#123; fa[e[i].to]=x; dep[e[i].to]=dep[x]+1; dep2[e[i].to]=dep2[x]+e[i].f; dfs(e[i].to); sz[x]+=sz[e[i].to]; if(sz[e[i].to]&gt;sz[heavyson[x]])&#123; heavyson[x]=e[i].to; &#125; &#125; &#125;&#125;inline void dfs2(int x,int anc)&#123; topfa[x]=anc; if(heavyson[x]) dfs2(heavyson[x],anc); for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x]&amp;&amp;e[i].to!=heavyson[x]) dfs2(e[i].to,e[i].to); &#125;&#125;inline int lca(int x,int y)&#123; while(topfa[x]!=topfa[y])&#123; dep[topfa[x]]&gt;dep[topfa[y]]?x=fa[topfa[x]]:y=fa[topfa[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;set&lt;int&gt; s;set&lt;int&gt;::iterator it;LL ans;int t1,t2,t3;inline LL dis(int x,int y)&#123; x=pos[x];y=pos[y]; return dep2[x]+dep2[y]-2*dep2[lca(x,y)];&#125;inline void solve()&#123; if(has[x])&#123; s.insert(dfn[x]); it=s.lower_bound(dfn[x]); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans+=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); &#125; else&#123; it=s.lower_bound(dfn[x]); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans-=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); s.erase(dfn[x]); &#125; printf(&quot;%lld\n&quot;,ans);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;n;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); addedge(y,x,z); &#125; dfs(1); dfs2(1,1); while(m--)&#123; x=read(); if(has[x])&#123; has[x]=0; --num; &#125; else&#123; has[x]=1; ++num; &#125; if(num&lt;=1)&#123; if(has[x])&#123; s.insert(dfn[x]); &#125; else&#123; s.erase(dfn[x]); &#125; puts(&quot;0&quot;); &#125; else&#123; solve(); &#125; &#125; return 0;&#125; 3.setÂ±ÖÁÑ∂ÂèØ‰ª•Áî®struct‰ΩúcmpÔºåÂ≠¶‰π†‰∫ÜÔºåÂΩìÁÑ∂ÈÄüÂ∫¶Ë∂ÖÊÖ¢123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int x,y,z;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;bool has[N];int num;int dfn[N],dfc,sz[N],fa[N],dep[N],heavyson[N],topfa[N];LL dep2[N];inline void dfs(int x)&#123; dfn[x]=++dfc; sz[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(!dfn[e[i].to])&#123; fa[e[i].to]=x; dep[e[i].to]=dep[x]+1; dep2[e[i].to]=dep2[x]+e[i].f; dfs(e[i].to); sz[x]+=sz[e[i].to]; if(sz[e[i].to]&gt;sz[heavyson[x]])&#123; heavyson[x]=e[i].to; &#125; &#125; &#125;&#125;inline void dfs2(int x,int anc)&#123; topfa[x]=anc; if(heavyson[x]) dfs2(heavyson[x],anc); for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x]&amp;&amp;e[i].to!=heavyson[x]) dfs2(e[i].to,e[i].to); &#125;&#125;inline int lca(int x,int y)&#123; while(topfa[x]!=topfa[y])&#123; dep[topfa[x]]&gt;dep[topfa[y]]?x=fa[topfa[x]]:y=fa[topfa[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;struct cmp&#123; bool operator()(const int &amp;x,const int &amp;y)&#123; return dfn[x]&lt;dfn[y]; &#125;&#125;;set&lt;int,cmp&gt; s;set&lt;int,cmp&gt;::iterator it;LL ans;int t1,t2,t3;inline LL dis(int x,int y)&#123; return dep2[x]+dep2[y]-2*dep2[lca(x,y)];&#125;inline void solve()&#123; if(has[x])&#123; s.insert(x); it=s.lower_bound(x); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans+=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); &#125; else&#123; it=s.lower_bound(x); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans-=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); s.erase(x); &#125; printf(&quot;%lld\n&quot;,ans);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;n;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); addedge(y,x,z); &#125; dfs(1); dfs2(1,1); while(m--)&#123; x=read(); if(has[x])&#123; has[x]=0; --num; &#125; else&#123; has[x]=1; ++num; &#125; if(num&lt;=1)&#123; if(has[x])&#123; s.insert(x); &#125; else&#123; s.erase(x); &#125; puts(&quot;0&quot;); &#125; else&#123; solve(); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ËôöÊ†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1599 find the mincost route]]></title>
    <url>%2F2018%2F05%2F27%2Fhdu1599%20find%20the%20mincost%20route%2F</url>
    <content type="text"><![CDATA[12345Êó†ÂêëÂõæÊâæÊúÄÂ∞èÁéØfloyd O(n^3)Êûö‰∏æ‰∏âÁÇπÁöÑÁéØÔºå‰ΩÜË¶ÅÁ°Æ‰øùÊúâ‰∏ÄÁÇπ‰∏çÂú®ÂÖ∂‰ªñ‰∏§‰∏™ÁÇπÁöÑÊúÄÁü≠Ë∑Ø‰∏äÔºåÊâÄ‰ª•‰∏ÄËæπfloyd‰∏ÄËæπÊûö‰∏æÊ≥®ÊÑè0x3f3f3f3f*3‰ºöÁàÜint 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108;int n,m;int x,y,z;int w[N][N],dis[N][N],ans;int main()&#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)&#123; memset(dis,0x3f,sizeof(dis)); memset(w,0x3f,sizeof(w)); ans=0x3f3f3f3f; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read();z=read(); if(w[x][y]&gt;z) w[x][y]=w[y][x]=dis[x][y]=dis[y][x]=z; &#125; for(int k=1;k&lt;=n;++k)&#123; for(int i=1;i&lt;k;++i)&#123; for(int j=i+1;j&lt;k;++j)&#123; ans=min((LL)ans,0ll+dis[i][j]+w[i][k]+w[j][k]); &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; if(dis[i][k]&lt;0x3f3f3f3f)&#123; for(int j=1;j&lt;=n;++j)&#123; if(dis[i][k]+dis[k][j]&lt;dis[i][j])&#123; dis[i][j]=dis[i][k]+dis[k][j]; &#125; &#125; &#125; &#125; &#125; if(ans==0x3f3f3f3f) puts(&quot;It&apos;s impossible.&quot;); else printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ÂõæËÆ∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄêÂ≠¶‰π†Á¨îËÆ∞„ÄëËôöÊ†ë luogu2495 [SDOI2011]Ê∂àËÄóÊàò]]></title>
    <url>%2F2018%2F05%2F25%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%99%9A%E6%A0%91%20luogu2495%20%5BSDOI2011%5D%E6%B6%88%E8%80%97%E6%88%98%2F</url>
    <content type="text"><![CDATA[123456789Âú®Ê†ëÂΩ¢dpÁöÑÂü∫Á°Ä‰∏ä‰øùÁïôÂÖ≥ÈîÆÁÇπÊØè‰∏™ÁÇπËÆ∞ÂΩïÁöÑ‰ø°ÊÅØË¶ÅÊòØ‰ªéËøô‰∏™ÁÇπÂà∞Ê†πÁöÑÊûÑÈÄ†ÁöÑÊñπÊ≥ï1.Â∞ÜÂÖ≥ÈîÆÁÇπÊéíÂ∫èÔºåÁõ∏ÈÇªÁöÑ‰∏§ÁÇπÊ±ÇlcaÔºåËøôÊ†∑ÊâÄÊúâÁöÑÁÇπÂØπlcaÈÉΩÂåÖÂê´Âú®ÂÖ∂‰∏≠ÔºàÂèçËØÅÊ≥ïËØÅÊòéÔºâ„ÄÇÂú®Â∞ÜÂÆÉ‰ª¨Êîæ‰∏ÄËµ∑ÊéíÂ∫èÔºåÂéªÈáçÔºåÁî®Ê†àËøûËæπ„ÄÇÂ§çÊùÇÂ∫¶O(nlogn)ÔºàÂ∏∏Êï∞Â§ßÔºâ2.Ê†à‰∏≠Êó∂ÂàªÁª¥Êä§‰∏ÄÊù°ÈìæÔºåÊØèÂä†ÂÖ•‰∏Ä‰∏™ÁÇπË¶ÅÁª¥Êä§Âà∞Ëøô‰∏™Êñ∞ÁöÑÁÇπÁöÑÈìæÔºåËøáÁ®ã‰∏≠ËøûËæπ„ÄÇÂ§çÊùÇÂ∫¶O(nlogn)ÔºàÂ∏∏Êï∞Â∞èÔºåÈöæÁêÜËß£ÔºâÊñπÊ≥ï1Ê≥®ÊÑèÔºöÂåÖÊã¨lcaÁöÑÈÇ£‰∏™Êï∞ÁªÑË¶ÅÂºÄ‰∏§ÂÄçÂ§ßÔºàÊàñËÄÖËÆ∞ÂΩï‰∏Ä‰∏ãÂì™‰∫õÊï∞Â∑≤ÁªèÂá∫Áé∞‰∫ÜÔºâÔºåvectorË¶ÅÊ∏ÖÁ©∫ ÊñπÊ≥ï1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=250008;int n;int u,v,w;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int sz[N],fa[N],dep[N],heavyson[N],topfa[N];LL mini[N];int dfn[N],dfc;inline void dfs(int x)&#123; dfn[x]=++dfc; ++sz[x]; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x])&#123; fa[e[i].to]=x; dep[e[i].to]=dep[x]+1; mini[e[i].to]=min(mini[x],(LL)e[i].f); dfs(e[i].to); sz[x]+=sz[e[i].to]; if(sz[e[i].to]&gt;sz[heavyson[x]])&#123; heavyson[x]=e[i].to; &#125; &#125; &#125;&#125;inline void dfs2(int x,int anc)&#123; topfa[x]=anc; if(heavyson[x]) dfs2(heavyson[x],anc); for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x]&amp;&amp;e[i].to!=heavyson[x]) dfs2(e[i].to,e[i].to); &#125;&#125;inline int lca(int x,int y)&#123; while(topfa[x]!=topfa[y])&#123; dep[topfa[x]]&gt;dep[topfa[y]]?x=fa[topfa[x]]:y=fa[topfa[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;inline void build()&#123; mini[1]=LONG_LONG_MAX; dfs(1); dfs2(1,1);&#125;int qn;int s[N],ta;bool key[N];vector&lt;int&gt; vis;inline bool cmp(const int &amp;a,const int &amp;b)&#123; return dfn[a]&lt;dfn[b];&#125;inline void addedge_2(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;LL f[N];inline LL dp(int x)&#123; LL tmp=0; for(int i=head[x];i;i=e[i].nxt)&#123; tmp+=dp(e[i].to); &#125; if(key[x]) f[x]=mini[x]; else f[x]=min(mini[x],tmp); head[x]=0; return f[x];&#125;int a[N&lt;&lt;1];//// inline void solve()&#123; nume=0; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); key[a[i]]=1; vis.pb(a[i]); &#125; sort(a+1,a+n+1,cmp); for(int i=n;i&gt;1;--i)&#123; a[++n]=lca(a[i],a[i-1]); &#125; sort(a+1,a+n+1,cmp); n=unique(a+1,a+n+1)-a-1; ta=0; for(int i=1;i&lt;=n;++i)&#123; if(ta==0)&#123; s[++ta]=a[i]; &#125; else&#123; while(dfn[s[ta]]+sz[s[ta]]&lt;=dfn[a[i]])&#123; --ta; &#125; addedge_2(s[ta],a[i]); s[++ta]=a[i]; &#125; &#125; dp(a[1]); for(int i=0;i&lt;vis.size();++i)&#123; key[vis[i]]=0; &#125; vis.clear();//////////// printf(&quot;%lld\n&quot;,f[a[1]]);&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i)&#123; u=read();v=read();w=read(); addedge(u,v,w); addedge(v,u,w); &#125; build(); qn=read(); memset(head,0,sizeof(head)); while(qn--)&#123; solve(); &#125; return 0;&#125; ÊñπÊ≥ï2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=250008;int n;int u,v,w;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int sz[N],fa[N],dep[N],heavyson[N],topfa[N];LL mini[N];int dfn[N],dfc;inline void dfs(int x)&#123; dfn[x]=++dfc; ++sz[x]; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x])&#123; fa[e[i].to]=x; dep[e[i].to]=dep[x]+1; mini[e[i].to]=min(mini[x],(LL)e[i].f); dfs(e[i].to); sz[x]+=sz[e[i].to]; if(sz[e[i].to]&gt;sz[heavyson[x]])&#123; heavyson[x]=e[i].to; &#125; &#125; &#125;&#125;inline void dfs2(int x,int anc)&#123; topfa[x]=anc; if(heavyson[x]) dfs2(heavyson[x],anc); for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x]&amp;&amp;e[i].to!=heavyson[x]) dfs2(e[i].to,e[i].to); &#125;&#125;inline int lca(int x,int y)&#123; while(topfa[x]!=topfa[y])&#123; dep[topfa[x]]&gt;dep[topfa[y]]?x=fa[topfa[x]]:y=fa[topfa[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;inline void build()&#123; mini[1]=LONG_LONG_MAX; dfs(1); dfs2(1,1);&#125;int qn;int s[N],ta;bool key[N];inline bool cmp(const int &amp;a,const int &amp;b)&#123; return dfn[a]&lt;dfn[b];&#125;inline void addedge_2(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;LL f[N];inline LL dp(int x)&#123; LL tmp=0; for(int i=head[x];i;i=e[i].nxt)&#123; tmp+=dp(e[i].to); &#125; if(key[x]) f[x]=mini[x]; else f[x]=min(mini[x],tmp); head[x]=0; return f[x];&#125;int a[N&lt;&lt;1];//// inline void solve()&#123; nume=0; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); key[a[i]]=1; &#125; sort(a+1,a+n+1,cmp); ta=0; for(int i=1;i&lt;=n;++i)&#123; if(ta==0)&#123; s[++ta]=a[i]; &#125; else&#123; int tmp=lca(s[ta],a[i]); while(dfn[tmp]&lt;dfn[s[ta]])&#123; if(dfn[tmp]&gt;=dfn[s[ta-1]])&#123; addedge_2(tmp,s[ta]); --ta; if(s[ta]!=tmp) s[++ta]=tmp; break; &#125; else&#123; addedge_2(s[ta-1],s[ta]); --ta; &#125; &#125; s[++ta]=a[i]; &#125; &#125; while(ta!=1)&#123; addedge_2(s[ta-1],s[ta]); --ta; &#125; dp(s[1]); for(int i=1;i&lt;=n;++i)&#123; key[a[i]]=0; &#125; printf(&quot;%lld\n&quot;,f[s[1]]);&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i)&#123; u=read();v=read();w=read(); addedge(u,v,w); addedge(v,u,w); &#125; build(); qn=read(); memset(head,0,sizeof(head)); while(qn--)&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ê†ë‰∏ädp</tag>
        <tag>ËôöÊ†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguP2414 [NOI2011]ÈòøÁã∏ÁöÑÊâìÂ≠óÊú∫]]></title>
    <url>%2F2018%2F05%2F23%2FluoguP2414%20%5BNOI2011%5D%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[ÂÖàÂÅöÂÆåbzoj3172 [Tjoi2013]ÂçïËØçÂÜçÁúãËøôÈ¢òËßâÂæóÊÄùË∑ØÊ∏ÖÁàΩÂ§ö‰∫Ü Á≠îÊ°àÊòØxÂú®failÊ†ë‰∏äÁöÑÂ≠êÊ†ëÂíå‰ΩÜÊòØÂè™ËÉΩ‰øùÁïôÁ¨¨y‰∏™‰∏≤ÁöÑÂ≠óÁ¨¶ÊåâÁÖßÂ≠óÁ¨¶È°∫Â∫èÂ§ÑÁêÜÊ≠£Â•ΩËÉΩÊ±ÇÂá∫ÂΩìÂâç‰∏≤ÁöÑÂ≠óÁ¨¶ÊâÄ‰ª•ÊÉ≥Âà∞Á¶ªÁ∫øÂ§ÑÁêÜËØ¢ÈóÆÊåâyÊéíÂ∫èÂ∞ÜfailÊ†ëËΩ¨ÊàêdfsÂ∫èÂú®dfsÂ∫è‰∏äÂÅöÂçïÁÇπ‰øÆÊîπÔºåÂå∫Èó¥Ê±ÇÂíå Á¨¨‰∫åÊ¨°ÂÅöfailÊ†ëÊòØ‰∏Ä‰∏™ÂæàÈáçË¶ÅÁöÑ‰∏úË•øfaÊòØËá™Â∑±ÁöÑÊúÄÈïøÂêéÁºÄÊØè‰∏™ÁÇπÊòØ‰∏Ä‰∏™ÂâçÁºÄÂú®failÊ†ë‰∏äÊüê‰∏™ÁÇπÁöÑÂ≠©Â≠ê/Â≠ôÂ≠ê/ÊõæÂ≠ôË°®ÊòéËá™Â∑±Âú®ÂÆÉÂ≠©Â≠ê/Â≠ôÂ≠ê/ÊõæÂ≠ô‰∏≠‰Ωú‰∏∫Ëøô‰∏™ÂâçÁºÄÁöÑÂêéÁºÄÂá∫Áé∞Èîô‰∫Ü‰∏ÄÊ¨°ÊòØÂõ†‰∏∫dfnÂíåszÊêûÈîôtrieÁöÑszÊòØ‰∏çÂåÖÊã¨0ÁöÑfailÊ†ëÁöÑdfnÊòØÂåÖÊã¨0ÁöÑ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;char s[N];int n;struct node&#123; int ch[26],fail,fa;&#125;t[N];int sz,num,pos[N];int m;struct node_q&#123; int x,y,id;&#125;que[N];inline bool cmp(const node_q &amp;a,const node_q &amp;b)&#123; return a.y&lt;b.y;&#125;int ans[N];inline void build()&#123; int u=0,c; for(int i=1;i&lt;=n;++i)&#123; if(s[i]=='P')&#123; pos[++num]=u; &#125; else if(s[i]=='B')&#123; u=t[u].fa; &#125; else&#123; c=s[i]-'a'; if(!t[u].ch[c]) t[u].ch[c]=++sz; t[t[u].ch[c]].fa=u; u=t[u].ch[c]; &#125; &#125;&#125;int q[N],he,ta;int nume,head[N];struct edge&#123; int to,nxt;&#125;e[N];inline void addedge(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;inline void getAC()&#123; he=1;ta=1; for(int i=0;i&lt;26;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; addedge(0,t[0].ch[i]); &#125; &#125; int u,v; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;26;++i)&#123; v=t[u].ch[i]; if(!v)&#123; t[u].ch[i]=t[t[u].fail].ch[i]; continue; &#125; t[v].fail=t[t[u].fail].ch[i]; q[ta]=v; ++ta; addedge(t[v].fail,v); &#125; &#125;&#125;int din[N],dout[N],dfn;inline void dfs(int x)&#123; din[x]=++dfn; for(int i=head[x];i;i=e[i].nxt)&#123; dfs(e[i].to); &#125; dout[x]=dfn;&#125;int bit[N];inline void add(int pos,int x)&#123; for(int i=pos;i&lt;=dfn;i+=i&amp;-i)&#123; bit[i]+=x; &#125;&#125;inline int sum(int pos)&#123; int tmp=0; for(int i=pos;i;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125;inline void solve()&#123; int u=0,qn=0,p=1,c,l,r; for(int i=1;i&lt;=n;++i)&#123; if(s[i]=='P')&#123; ++qn; while(qn==que[p].y)&#123; l=din[pos[que[p].x]]; r=dout[pos[que[p].x]]; ans[que[p].id]=sum(r)-sum(l-1); ++p; &#125; &#125; else if(s[i]=='B')&#123; add(din[u],-1); u=t[u].fa; &#125; else&#123; c=s[i]-'a'; u=t[u].ch[c]; add(din[u],1); &#125; &#125;&#125;int main()&#123; scanf("%s",s+1); n=strlen(s+1); build(); getAC(); dfs(0); m=read(); for(int i=1;i&lt;=m;++i)&#123; que[i].x=read();que[i].y=read();que[i].id=i; &#125; sort(que+1,que+m+1,cmp); solve(); for(int i=1;i&lt;=m;++i)&#123; printf("%d\n",ans[i]); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;char s[N];struct trie&#123; int ch[26],f,fa;&#125;ac[N];int sz;int pos[N],num;inline void build()&#123; int u=0,c; for(int i=1;i&lt;=n;++i)&#123; if(s[i]=='B')&#123; u=ac[u].fa; &#125; else if(s[i]=='P')&#123; pos[++num]=u; &#125; else&#123; c=s[i]-'a'; if(!ac[u].ch[c]) ac[u].ch[c]=++sz; ac[ac[u].ch[c]].fa=u; u=ac[u].ch[c]; &#125; &#125; &#125;int q[N],he,ta;vector&lt;int&gt; e[N];inline void get_acam()&#123; he=ta=1; for(int i=0;i&lt;26;++i)&#123; if(ac[0].ch[i])&#123; q[ta]=ac[0].ch[i]; ++ta; e[0].pb(ac[0].ch[i]); &#125; &#125; while(he!=ta)&#123; int u=q[he];++he; for(int i=0;i&lt;26;++i)&#123; int v=ac[u].ch[i]; if(v)&#123; ac[v].f=ac[ac[u].f].ch[i]; q[ta]=v; ++ta; e[ac[v].f].pb(v); &#125; else&#123; ac[u].ch[i]=ac[ac[u].f].ch[i]; &#125; &#125; &#125;&#125;int in[N],out[N],dfn;inline void dfs(int x)&#123; in[x]=++dfn; for(int i=0;i&lt;e[x].size();++i)&#123; dfs(e[x][i]); &#125; out[x]=dfn;&#125;int qn;struct que&#123; int x,y,id;&#125;qx[N];inline bool cmp(const que &amp;a,const que &amp;b)&#123; return a.y&lt;b.y;&#125;int bit[N];inline void add(int pos,int x)&#123; if(!pos) return; for(int i=pos;i&lt;=dfn;i+=i&amp;-i)&#123;//dfn=sz+1ÔºåszÊ≤°ÊúâÁÆó0ÔºÅÔºÅ bit[i]+=x; &#125;&#125;inline int sum(int pos)&#123; int tmp=0; for(int i=pos;i&gt;0;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125;int ans[N];inline void solve()&#123; int u=0,c,cnt=0,t=1,l,r; for(int i=1;i&lt;=n;++i)&#123; if(s[i]=='B')&#123; add(in[u],-1); u=ac[u].fa; &#125; else if(s[i]=='P')&#123; ++cnt; while(cnt==qx[t].y)&#123; l=in[pos[qx[t].x]]; r=out[pos[qx[t].x]]; ans[qx[t].id]=sum(r)-sum(l-1); ++t; &#125; &#125; else&#123; c=s[i]-'a'; u=ac[u].ch[c]; add(in[u],1); &#125; &#125;&#125;int main()&#123; scanf("%s",s+1); n=strlen(s+1); build(); get_acam(); dfs(0); qn=read(); for(int i=1;i&lt;=qn;++i)&#123; qx[i].x=read(); qx[i].y=read(); qx[i].id=i; &#125; sort(qx+1,qx+qn+1,cmp); solve(); for(int i=1;i&lt;=qn;++i)&#123; printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ê†ëÁä∂Êï∞ÁªÑ</tag>
        <tag>acËá™Âä®Êú∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3172 [Tjoi2013]ÂçïËØç]]></title>
    <url>%2F2018%2F05%2F23%2Fbzoj3172%20%5BTjoi2013%5D%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[12345failÊåáÈíàË°®Á§∫ÊúÄÈïøÂêéÁºÄÊØè‰∏™ÂçïËØçÁöÑÊØè‰∏™‰ΩçÁΩÆÂØπÂÆÉÁöÑÊâÄÊúâÂêéÁºÄÈÉΩÊúâË¥°ÁåÆ‰πüÂ∞±ÊòØÊØè‰∏™ÂçïËØçÁöÑÁ≠îÊ°à‰∏∫failÊ†ë‰∏≠Ëøô‰∏™ÁÇπÁöÑÂ≠êÊ†ëÂíåÊ≥®ÊÑè‰∏Ä‰∏™ÂçïËØçÁöÑÊØè‰∏™‰ΩçÁΩÆÈÉΩÊúâ1ÁöÑÂàùÂÄºÂèØ‰ª•‰∏çÁî®ÊääfailÊ†ëÂçïÁã¨Âª∫Âá∫Êù•ÔºåÂ§ÑÁêÜbfsÂ∫èÂ∞±Ë°å 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1000008;int n;char s[N];struct node&#123; int ch[26],fail,num;&#125;t[N];int sz;int pos[208];inline void inser(int &amp;x)&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-&apos;a&apos;; if(!t[u].ch[c]) t[u].ch[c]=++sz; u=t[u].ch[c]; ++t[u].num; &#125; x=u;&#125;int q[N],he,ta;inline void getAC()&#123; he=1;ta=1; for(int i=0;i&lt;26;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; &#125; int u,v; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;26;++i)&#123; v=t[u].ch[i]; if(!v)&#123; t[u].ch[i]=t[t[u].fail].ch[i]; continue; &#125; t[v].fail=t[t[u].fail].ch[i]; q[ta]=v; ++ta; &#125; &#125; for(int i=ta-1;i;--i)&#123; t[t[q[i]].fail].num+=t[q[i]].num; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s+1); inser(pos[i]); &#125; getAC(); for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%d\n&quot;,t[pos[i]].num); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acËá™Âä®Êú∫</tag>
        <tag>failÊ†ë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2444 [POI2000]ÁóÖÊØí]]></title>
    <url>%2F2018%2F05%2F22%2Fluogu2444%20%5BPOI2000%5D%E7%97%85%E6%AF%92%2F</url>
    <content type="text"><![CDATA[12trieÂõæ‰∏äÈù¢Ë∑ëÁéØÂÖàÂõ†‰∏∫trieÊ†ëÂ§öÂä†continueË∑™‰∫ÜÔºåÁÑ∂ÂêéÂèëÁé∞Ê≤°ÊúâÊääfailÊåáÂêëÂç±Èô©ËäÇÁÇπÁöÑÁÇπÊ†á‰∏∫Âç±Èô©ÁöÑÔºàÂêéÁºÄ‰∏≠ÊúâÂç±Èô©ÁöÑÔºåËØ¥ÊòéËá™Ë∫´‰πüÊòØÂç±Èô©ÁöÑÔºâ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=30008;int n;char s[N];struct node&#123; int ch[2],fail; bool num;&#125;t[N];int sz;inline void inser()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-&apos;0&apos;; if(!t[u].ch[c])&#123; t[u].ch[c]=++sz; &#125; u=t[u].ch[c]; &#125; t[u].num=1;&#125;int q[N],he,ta;inline void getAC()&#123; he=1;ta=1; for(int i=0;i&lt;2;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; &#125; int u,v; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;2;++i)&#123; v=t[u].ch[i]; if(!v)&#123; t[u].ch[i]=t[t[u].fail].ch[i]; continue; &#125; t[v].fail=t[t[u].fail].ch[i]; t[v].num|=t[t[t[u].fail].ch[i]].num; q[ta]=v; ++ta; &#125; &#125;&#125;bool ins[N],vis[N];inline bool dfs(int x)&#123; ins[x]=1; vis[x]=1; for(int i=0;i&lt;2;++i)&#123; if(ins[t[x].ch[i]]) return 1; if(!t[t[x].ch[i]].num&amp;&amp;!vis[t[x].ch[i]])&#123; if(dfs(t[x].ch[i])) return 1; &#125; &#125; ins[x]=0; return 0;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s+1); inser(); &#125; getAC(); if(dfs(0))&#123; puts(&quot;TAK&quot;); &#125; else&#123; puts(&quot;NIE&quot;); &#125; return 0;&#125; ÈîôËØØ‰ª£Á†ÅÔºöÂ∞ÜÊ≤°ÊúâÁöÑËÆæ‰∏∫-1Âèç‰æãÔºö1012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=30008;int n;char s[N];struct node&#123; int ch[2],fail; bool num;&#125;t[N];int sz;inline void inser()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-&apos;0&apos;; if(!t[u].ch[c])&#123; t[u].ch[c]=++sz; &#125; u=t[u].ch[c]; &#125; t[u].num=1;&#125;int q[N],he,ta;inline void getAC()&#123; he=1;ta=1; for(int i=0;i&lt;2;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; else&#123; t[0].ch[i]=-1; &#125; &#125; int u,v,x; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;2;++i)&#123; v=t[u].ch[i]; if(!v)&#123; t[u].ch[i]=t[t[u].fail].ch[i]; continue; &#125; t[v].fail=t[t[u].fail].ch[i]; t[v].num|=t[t[t[u].fail].ch[i]].num; q[ta]=v; ++ta; &#125; &#125;&#125;bool ins[N],vis[N];inline bool dfs(int x)&#123; ins[x]=1; vis[x]=1; for(int i=0;i&lt;2;++i)&#123; if(t[x].ch[i]==-1) continue; if(ins[t[x].ch[i]]) return 1; if(!t[t[x].ch[i]].num&amp;&amp;!vis[t[x].ch[i]])&#123; if(dfs(t[x].ch[i])) return 1; &#125; &#125; ins[x]=0; return 0;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s+1); inser(); &#125; getAC(); if(dfs(0))&#123; puts(&quot;TAK&quot;); &#125; else&#123; puts(&quot;NIE&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acËá™Âä®Êú∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3808 „ÄêÊ®°Êùø„ÄëACËá™Âä®Êú∫ÔºàÁÆÄÂçïÁâàÔºâ]]></title>
    <url>%2F2018%2F05%2F21%2Fluogu3808%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[12acËá™Âä®Êú∫ÊàñËÄÖtrieÂõæÂ≠óÁ¨¶ÈõÜËøáÂ§ß‰∏çËÉΩÁî®trieÂõæÔºåÈúÄË¶ÅmapÁöÑacËá™Âä®Êú∫ acËá™Âä®Êú∫123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1000008;int n;char s[N];struct node&#123; int ch[26],fail,num;&#125;t[N];int sz;inline void ins()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-'a'; if(!t[u].ch[c]) t[u].ch[c]=++sz; u=t[u].ch[c]; &#125; ++t[u].num;&#125;int q[N],he,ta;inline void getAC()&#123; he=1;ta=1; int u,v,x; for(int i=0;i&lt;26;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; &#125; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;26;++i)&#123; v=t[u].ch[i]; if(v)&#123; x=t[u].fail; while(x!=0&amp;&amp;!t[x].ch[i]) x=t[x].fail; if(t[x].ch[i]) x=t[x].ch[i]; t[v].fail=x; q[ta]=v; ++ta; &#125; &#125; &#125;&#125;int ans;bool vis[N];inline void AC()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-'a'; while(u!=0&amp;&amp;!t[u].ch[c]) u=t[u].fail; if(t[u].ch[c])&#123; u=t[u].ch[c]; for(int v=u;v!=0&amp;&amp;!vis[v];v=t[v].fail)&#123; ans+=t[v].num; vis[v]=1; &#125; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; scanf("%s",s+1); ins(); &#125; getAC(); scanf("%s",s+1); AC(); printf("%d",ans); return 0;&#125; trieÂõæ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1000008;int n;char s[N];struct node&#123; int ch[26],fail,num;&#125;t[N];int sz;inline void ins()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-&apos;a&apos;; if(!t[u].ch[c]) t[u].ch[c]=++sz; u=t[u].ch[c]; &#125; ++t[u].num;&#125;int q[N],he,ta;inline void getAC()&#123; he=1;ta=1; int u,v,x; for(int i=0;i&lt;26;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; &#125; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;26;++i)&#123; v=t[u].ch[i]; if(!v)&#123; t[u].ch[i]=t[t[u].fail].ch[i]; continue; &#125; t[v].fail=t[t[u].fail].ch[i]; q[ta]=v; ++ta; &#125; &#125;&#125;int ans;bool vis[N];inline void AC()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-&apos;a&apos;; u=t[u].ch[c]; for(int v=u;v!=0&amp;&amp;!vis[v];v=t[v].fail)&#123; ans+=t[v].num; vis[v]=1; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s+1); ins(); &#125; getAC(); scanf(&quot;%s&quot;,s+1); AC(); printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>acËá™Âä®Êú∫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ËÆ°ËíúÂÆ¢ Ë¥ùÂ£≥ÊâæÊàøÊà∑Â§ñÊãìÂ±ïÔºà‰∏≠Á≠âÔºâ]]></title>
    <url>%2F2018%2F05%2F21%2F%E8%AE%A1%E8%92%9C%E5%AE%A2%20%E8%B4%9D%E5%A3%B3%E6%89%BE%E6%88%BF%E6%88%B7%E5%A4%96%E6%8B%93%E5%B1%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[12345678910111213‰∏ªÂäõÂº∫ÂïäËÄÉËØïÊó∂ÂÜôÂàÜÂùóÊ≤°Êó∂Èó¥Ë∞ÉËØï‰∫ÜxËΩ¥Êâ´ÊèèÁ∫ø+Âå∫Èó¥Áª¥Êä§‰∏ÄÊ¨°ÂáΩÊï∞Á∫øÊÆµÊ†ëÂïäÂÜôÂï•ÂàÜÂùó„ÄÇ„ÄÇÂõ∞ÈöæÁâàË¶Åk-d treeÔºå‰∏ç‰ºöÈáçÁÇπÂú®Âå∫Èó¥ÂèØ‰ª•Áª¥Êä§‰∏ÄÊ¨°ÂáΩÊï∞È°∫Â∫è‰∏çÈúÄË¶ÅÁÆ°Âõ†‰∏∫ÂêàÂπ∂Â∞±ÊòØ‰ªéÂ∑¶Âà∞Âè≥ÁöÑÔºàÊàëÂÇª‰∫ÜÔºâ‰∏Ä‰ΩçÁΩëÂèãË∑üÊàëËÆ≤ÂèØ‰ª•ÊåâyÊâ´ÊèèÁ∫ø‰ΩÜÊàë‰∏çÂ§™‰ºöÔºàËØ¢ÈóÆÂèØËÉΩÈáçÂè†‰ΩÜÊòØÊèíÂÖ•‰∏ç‰ºöÔºâ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008,mod=323232323;int n,m,qn;char ch;int an,tmp;struct node&#123; int l,r,y,p,q;&#125;a[N];inline bool cmpa(const node &amp;a,const node &amp;b)&#123; if(a.l!=b.l) return a.l&lt;b.l; return a.r&lt;b.r;&#125;bool vis[N];int bn;struct nodeq&#123; int x,l,r,id;&#125;b[N];inline bool cmpb(const nodeq &amp;a,const nodeq &amp;b)&#123; return a.x&lt;b.x;&#125;int ans[N],cnt;priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;struct node_tree&#123; int p,q;&#125;tree[N&lt;&lt;2];inline void pushup(int t)&#123; int lson=t&lt;&lt;1,rson=t&lt;&lt;1|1; tree[t].p=1ll*tree[lson].p*tree[rson].p%mod; tree[t].q=(1ll*tree[lson].q*tree[rson].p+tree[rson].q)%mod;&#125; inline void update(int t,int l,int r,int dest,int p,int q)&#123; if(l==dest&amp;&amp;r==dest)&#123; tree[t].p=p; tree[t].q=q; return; &#125; int mid=(l+r)&gt;&gt;1; if(dest&lt;=mid) update(t&lt;&lt;1,l,mid,dest,p,q); else update(t&lt;&lt;1|1,mid+1,r,dest,p,q); pushup(t); return;&#125;inline void query(int t,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; cnt=(1ll*cnt*tree[t].p+tree[t].q)%mod; return; &#125; int mid=(l+r)&gt;&gt;1; if(ll&lt;=mid) query(t&lt;&lt;1,l,mid,ll,rr); if(mid&lt;rr) query(t&lt;&lt;1|1,mid+1,r,ll,rr); return;&#125;int main()&#123; n=read();m=read();qn=read(); for(int i=1;i&lt;=m*4;++i)&#123; tree[i].p=1; &#125; while(qn--)&#123; ch=getchar(); while(ch&lt;&apos;A&apos;||ch&gt;&apos;Z&apos;) ch=getchar(); if(ch==&apos;I&apos;)&#123; ++an; a[an].l=read(); a[an].r=read(); a[an].y=read(); a[an].p=read(); a[an].q=read(); vis[an]=1; &#125; if(ch==&apos;D&apos;)&#123; tmp=read(); vis[tmp]=0; &#125; if(ch==&apos;Q&apos;)&#123; ++bn; b[bn].x=read(); b[bn].l=read(); b[bn].r=read(); b[bn].id=bn; &#125; &#125; tmp=an;an=0; for(int i=1;i&lt;=tmp;++i)&#123; if(vis[i])&#123; a[++an]=a[i]; &#125; &#125; sort(a+1,a+an+1,cmpa); sort(b+1,b+bn+1,cmpb); tmp=1; for(int i=1;i&lt;=bn;++i)&#123; while(a[tmp].l&lt;=b[i].x&amp;&amp;tmp&lt;=an)&#123; q.push(mp(a[tmp].r,tmp)); update(1,1,m,a[tmp].y,a[tmp].p,a[tmp].q); ++tmp; &#125; while(!q.empty()&amp;&amp;q.top().first&lt;b[i].x)&#123; update(1,1,m,a[q.top().second].y,1,0); q.pop(); &#125; cnt=0; query(1,1,m,b[i].l,b[i].r); ans[b[i].id]=cnt; &#125; for(int i=1;i&lt;=bn;++i)&#123; printf(&quot;%d\n&quot;,ans[i]); &#125; return 0;&#125; ÂàÜÂùóÁªà‰∫éËøá‰∫ÜÂçÉ‰∏á‰∏çË¶ÅÂ∞Ü0‰πüÊêûÂà∞ÂùóÈáåÈù¢ÔºàÂæàÈ∫ªÁÉ¶ËØ∑ËøôÊ†∑ÂÜôbe[i]=(i-1)/blk+1;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008,mod=323232323,BLK=330;int n,m,qn,blk;int be[N];char ch;int an,tmp;struct node&#123; int l,r,y,p,q;&#125;a[N];inline bool cmpa(const node &amp;a,const node &amp;b)&#123; if(a.l!=b.l) return a.l&lt;b.l; return a.r&lt;b.r;&#125;bool vis[N];int bn;struct nodeq&#123; int x,l,r,id;&#125;b[N];inline bool cmpb(const nodeq &amp;a,const nodeq &amp;b)&#123; return a.x&lt;b.x;&#125;int ans[N];LL cnt;priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;struct node_blk&#123; LL p,q;&#125;c[N],block[BLK];inline void update(int dest,int p,int q)&#123; c[dest].p=p;c[dest].q=q; int l=(be[dest]-1)*blk+1,r=min(m,be[dest]*blk); p=1;q=0; for(int i=l;i&lt;=r;++i)&#123; p=1ll*p*c[i].p%mod; q=(1ll*q*c[i].p+c[i].q)%mod; &#125; block[be[dest]].p=p; block[be[dest]].q=q;&#125;inline void query(int l,int r)&#123; cnt=0; if(be[l]==be[r])&#123; for(int i=l;i&lt;=r;++i)&#123; cnt=(1ll*cnt*c[i].p+c[i].q)%mod; &#125; &#125; else&#123; for(int i=l;i&lt;=be[l]*blk;++i)&#123; cnt=(1ll*cnt*c[i].p+c[i].q)%mod; &#125; for(int i=be[l]+1;i&lt;be[r];++i)&#123; cnt=(1ll*cnt*block[i].p+block[i].q)%mod; &#125; for(int i=(be[r]-1)*blk+1;i&lt;=r;++i)&#123; cnt=(1ll*cnt*c[i].p+c[i].q)%mod; &#125; &#125;&#125;int main()&#123; n=read();m=read();qn=read(); blk=sqrt(m); for(int i=1;i&lt;=m;++i)&#123; be[i]=(i-1)/blk+1; c[i].p=1; &#125; for(int i=1;i&lt;=m/blk+1;++i)&#123;//m/blk+1ÊâçÊòØÂùóÊï∞ block[i].p=1; &#125; while(qn--)&#123; ch=getchar(); while(ch&lt;&apos;A&apos;||ch&gt;&apos;Z&apos;) ch=getchar(); if(ch==&apos;I&apos;)&#123; ++an; a[an].l=read(); a[an].r=read(); a[an].y=read(); a[an].p=read(); a[an].q=read(); vis[an]=1; &#125; if(ch==&apos;D&apos;)&#123; tmp=read(); vis[tmp]=0; &#125; if(ch==&apos;Q&apos;)&#123; ++bn; b[bn].x=read(); b[bn].l=read(); b[bn].r=read(); b[bn].id=bn; &#125; &#125; tmp=an;an=0; for(int i=1;i&lt;=tmp;++i)&#123; if(vis[i])&#123; a[++an]=a[i]; &#125; &#125; sort(a+1,a+an+1,cmpa); sort(b+1,b+bn+1,cmpb); tmp=1; for(int i=1;i&lt;=bn;++i)&#123; while(a[tmp].l&lt;=b[i].x&amp;&amp;tmp&lt;=an)&#123; q.push(mp(a[tmp].r,tmp)); update(a[tmp].y,a[tmp].p,a[tmp].q); ++tmp; &#125; while(!q.empty()&amp;&amp;q.top().first&lt;b[i].x)&#123; update(a[q.top().second].y,1,0); q.pop(); &#125; query(b[i].l,b[i].r); ans[b[i].id]=cnt; &#125; for(int i=1;i&lt;=bn;++i)&#123; printf(&quot;%d\n&quot;,ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Á∫øÊÆµÊ†ë</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F05%2F20%2F%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[title:È¢òÁõÆÁΩëÁªúÊµÅ luogu4249 [WC2007]Ââ™ÂàÄÁü≥Â§¥Â∏ÉS - (1,0) - Ëæπ - (1,0) - ÁÇπ - (1,0)/(1,1)/‚Ä¶/(1,n-1) - TË∑ë10000ÁöÑË¥πÁî®ÊµÅÔºåÊï∞ÊçÆËæÉÊ∞¥ËÉΩËøá luogu3973 [TJOI2015]Á∫øÊÄß‰ª£Êï∞ÊØè‰∏™Êï∞Âèñ0/1ÔºåÂª∫ÂõæÂ¶ÇÂõæ bzoj3894 ÊñáÁêÜÂàÜÁßëÂõæ bzoj3232 ÂúàÂú∞Ê∏∏Êàè1.‰∫åÂàÜ+spfaÂà§Ë¥üÁéØ2.‰∫åÂàÜ+[Á∫øÊÄß‰ª£Êï∞]Âª∫ÂõæÔºåË¶ÅËß£ÊñπÁ®ã bzoj2229 [Zjoi2011]ÊúÄÂ∞èÂâ≤gomory hu tree O(n*flow) ÊúÄÂ∞èÂâ≤Ê†ëÂª∫Ê†ëÊúâ‰∏§Áßç1.‰ªªÈÄâs,tË∑ëÊúÄÂ∞èÂâ≤ÔºåÁÑ∂ÂêéÂàÜÊ≤ªÔºàÈÄíÂΩíÔºâ2.1‰∏ãÈù¢Ëøû2Âà∞nÔºå‰ªé2Âà∞nÔºås=fa[x],t=xË∑ëÁΩëÁªúÊµÅÔºåÊØèÊ¨°Â∞ÜÂíåxÁõ∏ËøûÁöÑÁÇπÁöÑfaÊåáÂêëx „ÄêBZOJ2085„Äë[Poi2010]Hamsters hash+ÂÄçÂ¢ûfloyd bzoj2795 [Poi2012]A Horrible PoemÂà§Êñ≠‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÁöÑÂæ™ÁéØËäÇÔºöÊûö‰∏ælenÔºàlenÊï¥Èô§|s|)ÁÑ∂ÂêéÂà§Êñ≠Ââç|s|-lenÂíåÂêé|s|-len‰∏™ÁöÑhashÂÄºÊòØÂê¶Áõ∏ÂêåÂØπÊØè‰∏™ËØ¢ÈóÆÔºå‰∏çÊñ≠Èô§‰ª•ÈïøÂ∫¶ÁöÑË¥®Âõ†Êï∞Âπ∂Âà§Êñ≠ÊÄªÂ§çÊùÇÂ∫¶ÊòØO(n+qlogn)ÂÖàÁ∫øÊÄßÁ≠õÊ±ÇÂá∫ÊØè‰∏™Êï∞ÁöÑÊúÄÂ∞èË¥®Âõ†Êï∞ÔºåÁÑ∂ÂêéÂèØ‰ª•Âú®O(ÊÄªÂõ†Êï∞‰∏™Êï∞)ÂÜÖÊ±ÇÂá∫1Âà∞nÁöÑÂõ†Êï∞‰∏™Êï∞ [BZOJ 4416][Shoi2013]Èò∂‰πòÂ≠óÁ¨¶‰∏≤Â∫èÂàóËá™Âä®Êú∫Â∞±ÊòØdpÔºànextÔºâ„ÄÇ„ÄÇËÆ∞ÂΩïnext[i][26]ÔºåO(26n)ÁöÑÈ¢ÑÂ§ÑÁêÜÔºå‰ªénÂà∞1ÔºåÊØèÊ¨°a[26]ËÆ∞ÂΩïÊúÄÂêéÂá∫Áé∞ÁöÑ‰ΩçÁΩÆÔºåÁÑ∂ÂêéÂ§çÂà∂ÁªônextÂ∞±ÂèØ‰ª•‰∫ÜÔºànextÊòØdagÔºâÁä∂ÂéãÂä†ÊâãÁÆó‰ºòÂåñÔºàÂ§ß‰∫é21Â∞±Êó†Ëß£Êàë‰πü‰∏ç‰ºöËØÅÔºâ hihocoder1412 : Rikka with Subsequence‰∏çËÄÉËôëÂà†Èô§ÔºåÂª∫Âá∫nextÔºåÈóÆÈ¢òÁ≠â‰ª∑‰∫édag‰∏≠‰ª•Ëµ∑ÁÇπÂºÄÂßãÁöÑ‰∏çÂêåË∑ØÂæÑÁöÑ‰∏™Êï∞ÔºådpÂç≥ÂèØËÄÉËôëÂà†Èô§ÊñπÁ®ãÂèòÊàêÔºö$c[ch]=\sum{j&lt;i}$$(f[j]*\prod{(j&lt;k&lt;i\bigcup a[k]=ch)}a_k)$ c[ch]Ë°®Á§∫Âà∞i‰ΩçÁΩÆÂâçÈù¢ÁöÑfÂØπÁ¨¨i‰ΩçÂ≠óÁ¨¶‰∏∫chÁöÑË¥°ÁåÆ$f[i]=c[s[i]]*(1-ai)$ f[i]Ë°®Á§∫Á¨¨i‰ΩçÂØπÁ≠îÊ°àÁöÑË¥°ÁåÆÔºàÂ§ßÊ¶ÇÊòØËøôÊ†∑ËØ∑ÊâãÊé®Ôºâ [NOI2015]ÂìÅÈÖíÂ§ß‰ºöcodeforces 452E ÂíåÂìÅÈÖíÂ§ß‰ºöÂ∑Æ‰∏çÂ§ö bzoj4516 [Sdoi2016]ÁîüÊàêÈ≠îÂíí‰∏çÂêåÂ≠ê‰∏≤ÁöÑ‰∏™Êï∞‰∏∫n(n+1)/2-sum(height) [AHOI2014/JSOI2014]È™ëÂ£´Ê∏∏ÊàèÊúÄÁü≠Ë∑ØÂ∞±ÊòØÊüêÁßçÊÑè‰πâ‰∏äÁöÑdpÔºàÊó†Ë¥üËæπÔºâÔºåÊØèÊ¨°Áî®ÊúÄÂ∞èÂÄºÊõ¥Êñ∞ËøôÈ¢ò‰πüÊòØÊØèÊ¨°Áî®ÊØè‰∏™ÁÇπÁöÑÊúÄÂ∞èÂÄºÊõ¥Êñ∞ÂÖ∂‰ªñÁÇπÔºå‰∏ÄÂºÄÂßãÂ∞ÜÊâÄÊúâÁÇπÁöÑÈ≠îÊ≥ïÂÄºÂÖ•Â†Ü [AHOI2014/JSOI2014]ÊîØÁ∫øÂâßÊÉÖ‰∏ä‰∏ãÁïåÁΩëÁªúÊµÅ [AHOI2014/JSOI2014]Â•áÊÄ™ÁöÑËÆ°ÁÆóÂô®ÂÖà‰∫åÂàÜÂá∫ÂÖ®ÂèòÊàêlÂíårÁöÑÂú∞Êñπ‰∏≠Èó¥ÁöÑÂú®Á∫øÊÆµÊ†ë‰∏äÂÅöÔºåÂä†„ÄÅ‰πò„ÄÅat‰∏â‰∏™Ê†áËÆ∞ [AHOI2014/JSOI2014]ÊãºÂõæÂÖàÊûö‰∏æÂ∫ïÂú®Á¨¨iË°åÔºåÂÜçÊûö‰∏æÈ´òÂ∫¶‰∏∫jÔºåÊúÄÂêéÊØè‰∏ÄÂàóÊâ´‰∏ÄÈÅçÂ§çÊùÇÂ∫¶$O(nmmin(m,n))$ [Jsoi2014]ÁóÖÊØíÂàÜÁ±ªtrieÊ†ë‰∏äÊêûÂá∫ÊØè‰∏™‰∏≤Â±û‰∫éÁöÑ‰∏§‰∏™ÈõÜÂêàÊØè‰∏™‰∏≤ÂèòÊàêËæπÊ±ÇÊúÄÂ∞èÁÇπË¶ÜÁõñ È¢òÁõÆÔºöÂå∫Èó¥ÊúâÊØè‰∏™Êï∞ÁöÑÂá∫Áé∞Ê¨°Êï∞ÈôêÂà∂ÔºåÊ±ÇÊï∞ÁöÑÊúÄÂ∞èÊ¨°Êï∞Â∑ÆÂàÜÁ∫¶Êùü [Jsoi2014]ÊîØÁ∫øÂâßÊÉÖ2 [Jsoi2014]ÊâìÂÖîÂ≠êËßÇÂØüÂèëÁé∞ÂèëÊû™È°∫Â∫èÊ≤°ÊúâÂΩ±ÂìçÔºå‰∏î‰∏ç‰ºöÂèëÁõ∏ÈÇªÁöÑÊû™dp[i][j][0/1]Ë°®Á§∫Âà∞iÊâìjÊû™‰∏îiÂ§ÑÊòØÂê¶ÂèëÊû™Â§ödpÂá†ÈÅçÔºåËÄÉËôëÁ¨¨1‰∏™‰ΩçÁΩÆÂíåÁ¨¨2‰∏™‰ΩçÁΩÆÊîæ‰∏çÊîæ 2118: Â¢®Â¢®ÁöÑÁ≠âÂºèÂ•óË∑ØdpËÄÉËôëB%aiÁöÑÂÄº,0~ai-1ÂØπÊØè‰∏™‰ΩôÊï∞iËøõË°ådpÔºåÊ±ÇÂá∫ÊúÄÂ∞èÁöÑ‰ΩôÊï∞‰∏∫iÁöÑBf[i]=min(f[j]+ak|(j+ak%ai)%ai==i)dpÁöÑÈ°∫Â∫è‰∏çÁü•ÈÅìÂèòÊàêÊúÄÁü≠Ë∑ØÂç≥ÂèØÂª∫ÂõæÁöÑÂ§çÊùÇÂ∫¶ÊòØO(na)Ë∑ëspfaÊàñËÄÖdijkÁöÑÂ§çÊùÇÂ∫¶ÊòØO(ËÉΩËøá)ÊòæÁÑ∂Áî®aiÊúÄÂ∞èÁöÑÂÄº‰ΩúÈô§Êï∞ 4082: [Wf2014]SurveillanceÂéªÊéâÂåÖÂê´ÁöÑÂå∫Èó¥ÔºöÂÖàÊéíÂ∫èÔºåR[i]=max(R[i-1],end[i])Ë°®Á§∫Â∑¶Á´ØÁÇπÂú®iÂèäÂ∑¶ËæπÔºåÂè≥Á´ØÁÇπÁöÑÊúÄËøúÂÄºÔºåÂàôÂØπ‰∫éÂå∫Èó¥[l,r]ÔºåÂè™Ë¶ÅÂà§Êñ≠R[l]ÂíårÁöÑÂÖ≥Á≥ªÂç≥ÂèØÂÖàÂèòÊàêÈìæÔºàÁøª‰∏§ÂÄçÔºâÔºåÂéªÊéâÂåÖÂê´ÁöÑÂå∫Èó¥ O(nlogn)Âú®ÁéØ‰∏äÈ¢ÑÂ§ÑÁêÜÂêéÁªßÁöÑÂå∫Èó¥ O(nlogn)ÂÜçÂèòÊàêÈìæÂÄçÂ¢ûÊ±ÇÂá∫f[i][j]Ë°®Á§∫‰ªéÁ¨¨i‰∏™Âå∫Èó¥/Á¨¨i‰∏™‰ΩçÁΩÆËµ∞jÊ≠•Âà∞ËææÁöÑÊúÄËøúË∑ùÁ¶ªÁÑ∂ÂêéÊØè‰∏™Âå∫Èó¥ÁöÑÈ¶ñ‰ΩçÁΩÆÂÜçÂà§‰∏ÄÈÅç 2303: [Apio2011]ÊñπÊ†ºÊüìËâ≤Ê≥®ÊÑèÂà∞Á¨¨‰∏ÄË°åÂíåÁ¨¨‰∏ÄÂàóÁ°ÆÂÆöÂêéÂèØ‰ª•Á°ÆÂÆöÊï¥‰∏™ÂõæÂõæ‰∏≠ÊØè‰∏™ÁÇπ(i,j)ÂèØ‰ª•ÂàóÂá∫ÂºÇÊàñÊñπÁ®ãÔºöa11^a1j^ai1^aij=[i,jÈÉΩÊòØÂÅ∂Êï∞]aijÂíåa11ÈÉΩÂèØ‰ª•ÂéªÊéâÁÑ∂ÂêéÂπ∂Êü•ÈõÜ 3150: [Ctsc2013]Áå¥Â≠êÂÖàËÄÉËôën=10‰∏Ä‰∏™Áä∂ÊÄÅÂèØ‰ª•ÂèòÊàêÂ•ΩÂ§öÁä∂ÊÄÅÂïäÂàóÊñπÁ®ãÂêßf(s)Ë°®Á§∫sÁä∂ÊÄÅÁöÑËÉúÁéáÁªìËÆ∫Ôºöf(s)‚à©f(t)=‚àÖÔºåf(s)+f(t)=f(s+t)ËØÅÊòé:s=s1+s2,f(s1)+f(s2)+f(t)=1,f(s)+f(t)=1 =&gt; f(s)=f(s1)+f(s2)ÊâÄ‰ª•Â§ÑÁêÜÊâÄÊúâÂè™Êúâ‰∏Ä‰∏™1ÁöÑÁä∂ÊÄÅÂ∞±ÂèØ‰ª•‰∫Ü 4237: Á®ªËçâ‰∫∫ÂàÜÊ≤ªÂä†Âπ≥Ë°°Ê†ëO(nlognlogn) hdu5800 To My Girlfriendf[i][j][f1][f2]Ë°®Á§∫Âà∞Á¨¨i‰∏™Âíå‰∏∫jÂ∑≤Áªè‚ÄôÈí¶ÂÆö‚ÄôÁöÑÈÄâÁöÑ‰∏™Êï∞‰∏∫f1Ôºå‚ÄôÈí¶ÂÆö‚Äô‰∏çÈÄâÁöÑ‰∏∫f2 Â§öÂå∫Èó¥ÈóÆÈ¢òÔºåÊØè‰∏™Âå∫Èó¥ÊúâË¶ÅÊ±ÇÔºåÂ¶ÇÔºö2018 ËÆ°Ëíú‰πãÈÅì ÂàùËµõ Á¨¨ÂõõÂú∫ Ë¥ùÂ£≥ÊâæÊàøÊêúÊàø[USACO13OPEN]ÁÖßÁâáPhoto 18-7-1b. sigma(g[i](n-i)-g[i+1](n-i-1)*(i+1))f.Âå∫Èó¥ÊéíÂ∫èÁöÑÂ•óË∑ØÔºö‰∫åÂàÜÔºå‰ΩøÂ∫èÂàóÂèòÊàê0/1 18-7-4d.Â•óË∑ØÂàÜÂùó f[i][x]Ë°®Á§∫‰ªéiÂà∞Á¨¨xÂùóÁªìÊùüÁöÑÁ≠îÊ°à f[x][i]Ë°®Á§∫‰ªéÁ¨¨xÂùóÂºÄÂßãÂà∞iÁöÑÁ≠îÊ°à O(nsqrtnlogn)a.f[i][j][x]Ë°®Á§∫iÂà∞jÊúÄÁªàÂèòÊàêÂ≠óÁ¨¶xÔºåËΩ¨ÁßªÊòØÊûö‰∏æi,j,ÂàÜÁïåÁÇπk,ÂíåÂèòÂåñËßÑÂàôÔºåO(n^4) g[i][j]Ë°®Á§∫Á¨¨‰∏Ä‰∏™Âà∞iÔºåÁ¨¨‰∫å‰∏™Âà∞jÔºåÁöÑÊúÄÁü≠ÈïøÂ∫¶ÔºåËΩ¨ÁßªÂÜçÊûö‰∏æp,q,O(n^4)b.È¢ÑÂ§ÑÁêÜÊíûÂà∞ÊØè‰∏™Á∫¢ÁÅØÁöÑÊó∂Èó¥Âå∫Èó¥Ôºå‰ªéÂêéÂæÄÂâçÂÅöÔºåÂú®Á∫øÊÆµÊ†ë‰∏äË¶ÜÁõñÔºàÂä®ÊÄÅÂºÄÁÇπÔºâÔºåÁÑ∂ÂêéÊ±ÇÂá∫ÊØè‰∏™Á∫¢ÁÅØÂà∞ÁªàÁÇπÁöÑÁ≠îÊ°àÔºàÁõ∏ÂΩì‰∫éÊ±Ç‰∏ÄËæÜËΩ¶Âà∞ÁöÑ‰∏ã‰∏Ä‰∏™Á∫¢ÁÅØÔºâc.ÂíåÊúÄÂ§ßÁöÑÊÉÖÂÜµ‰∏ãx1ÊúÄÂ∞èÔºåÁ≠â‰ª∑‰∫éx2ÊúÄÂ§ßÔºåÊâÄ‰ª•ÈáçÊñ∞ÂÆö‰πâ‰ºòÂÖàÁ∫ßÂêéÔºåÂÜçÊ±ÇÁ∫øÊÄßÂü∫ÔºåÁ∫øÊÄßÂü∫‰∏≠ÁöÑÊâÄÊúâÊï∞ÈÉΩÁªôx2ÔºåÂÖ∂‰ªñÁªôx1e.Âª∫ÂõæÂ∞èÊäÄÂ∑ßÔºöË¶ÅËøûnmÊù°ËæπÁöÑÊó∂ÂÄôÔºåËÄÉËôëÊØè‰∏™aiÂä†ËæÖÂä©ÁÇπciÔºåÊéíÂ∫èÔºåÊØè‰∏™ÁÇπÂêëËá™Â∑±ÁöÑËæÖÂä©ÁÇπËøûwiÔºåËæÖÂä©ÁÇπÂêëËá™Â∑±Ëøû0ÔºåciÂêëci+1ËøûÂ∑ÆÔºåci+1ÂêëciËøû0ÔºåËøôÊ†∑Âè™ÊúâO(n)Êù°ËæπÔºåÂú®Ëµ∑ÁÇπÂâçÂä†‰∏Ä‰∏™0ÁÇπÔºåÈáçÁÇπÂêéÂä†‰∏§‰∏™0ÁÇπÔºàÂõ†‰∏∫Âú®Êñ∞Âõæ‰∏äËµ∞‰∏ÄÊ≠•Â∞±ÊòØËµ∞‰∏§Êù°ËæπÔºâÊúÄÁªàÁ≠îÊ°à‰∏∫ÊúÄÂêé‰∏§‰∏™0ÁÇπ‰∏≠ÁöÑËæÉÂ∞èÂÄº Á∫¶ÁëüÂ§´ÈóÆÈ¢ò1)n‰∏™‰∫∫ÔºåÈ°∫ÁùÄÊùÄÂíåÂÄíÁùÄÊùÄk‰∏™‰∫∫ È°∫ÁùÄÊùÄÔºö m=1(mod n) m=1(mod n-1) . . . m=1(mod n-k+1) ÂÄíÁùÄÊùÄÔºö m=0(mod n) m=0(mod n-1) . . . m=0(mod n-k+1)2)n‰∏™‰∫∫ÔºåË¶ÅÊ±ÇËÆ©Á¨¨k‰∏™‰∫∫Ê¥ª‰∏ãÊù•ÔºåÊ±Çm Ëã•n‰∏∫Ë¥®Êï∞Ôºö m=k-1(mod n) m=0(mod 1) m=0(mod 2) . . . m=0(mod n-1) ÊàñËÄÖ m=k+1(mod n) m=1(mod 1) m=1(mod 2) . . . m=1(mod n-1) Ëã•n‰∏∫‰∏çÊòØË¥®Êï∞Ôºö ‰ºØÁâπÂÖ∞‚ÄîÂàáÊØîÈõ™Â§´ÂÆöÁêÜËØ¥ÊòéÔºöËã•Êï¥Êï∞n &gt; 3ÔºåÂàôËá≥Â∞ëÂ≠òÂú®‰∏Ä‰∏™Ë¥®Êï∞pÔºåÁ¨¶Âêàn &lt; p &lt; 2n ‚àí 2„ÄÇÂè¶‰∏Ä‰∏™Á®çÂº±ËØ¥Ê≥ïÊòØÔºöÂØπ‰∫éÊâÄÊúâÂ§ß‰∫é1ÁöÑÊï¥Êï∞nÔºåÂ≠òÂú®‰∏Ä‰∏™Ë¥®Êï∞pÔºåÁ¨¶Âêàn &lt; p &lt; 2n„ÄÇ ‰∏çÂ¶®ËÆæk&gt;n/2 m=1(mod lcm(1,2,‚Ä¶,n)/p) m=k+1-n(mod p) 18-7-6a.Ê¨ßÊãâÂáΩÊï∞ÂèØ‰ª•‰∏çÁÆ°ÊåáÊï∞ÔºÅÁî®LLËÆ∞ÂΩï60‰∏™Ë¥®Êï∞ÊòØÂê¶Âá∫Áé∞ËøáÔºåÂ§çÊùÇÂ∫¶Â∞ë‰∏Ä‰∏™60b.f(S)Ë°®Á§∫ÈõÜÂêàS‰∏≠ËøûÈÄöÂùóÁöÑ‰∏™Êï∞ÔºàSÂåÖÂê´1ÔºâÔºå$f(S)=\prod (C{ij}+1)-f(S‚Äô)*(C{i‚Äôj‚Äô}+1)$(S‚ÄôÂ±û‰∫éS,i‚Äô,j‚ÄôÂ±û‰∫éS/S‚Äô) d.1e12‰ª•ÂÜÖÂõ†Êï∞ÊúÄÂ§öÁöÑÊï∞Â§ßÊ¶ÇÊúâ6000‰∏™Âõ†Êï∞Ôºåf[i][x]={a,b}Ë°®Á§∫Ââçi‰∏™Êï∞ÈÄâ‰∫Üa‰∏™ÔºåÊÄªÂíå‰∏∫bÔºå‰∏î‰∏ékÁöÑÊúÄÂ§ßÂÖ¨Âõ†Êï∞‰∏∫xÔºåf[i][x] - a[i+1] -&gt; f[i+1][gcd(x*a[i+1],k)] Á≠îÊ°à‰∏∫f[n][k]ÔºåËÆ∞ÂΩïÊØè‰∏™f‰ªéÂì™‰∏™Áä∂ÊÄÅËΩ¨ÁßªËøáÊù•ÁöÑÔºåÂÄíÊé®ÂèØ‰ª•Ê±ÇÂá∫Â∫èÂàóf.n(n&gt;=3)ÂèØ‰ª•ÔºåÂàôn+2ÂèØ‰ª•„ÄÇn=3Ôºå6ÂèØ‰ª•Ôºån=4‰∏çÂèØ‰ª•e.Á∫øÊÆµÊ†ëÔºåÁª¥Êä§Âä†Ê†áËÆ∞ÂíåÁõ∏ÂêåÊ†áËÆ∞ÂíåÈ¢úËâ≤Ê†áËÆ∞(Â¶ÇÊûúÁõ∏ÂêåÊ†áËÆ∞=1)ÔºåÂØπ‰∫éÂå∫Èó¥‰øÆÊîπÔºåËã•ËØ•Âå∫Èó¥Áõ∏ÂêåÊ†áËÆ∞=1,Áõ¥Êé•ÊîπÔºåÂê¶ÂàôÈÄíÂΩí‰∏ãÂéªÂ§ÑÁêÜ„ÄÇÂ§çÊùÇÂ∫¶Á≠â‰∫éÊ∑ªÂä†Ê†áËÆ∞ÁöÑÊ¨°Êï∞‰∏∫O(nlogn) 18-7-8a.Áî®hashÂèØ‰ª•Âéª‰∏Ä‰∏™logb.Âü∫Â∞îÈúçÂ§´Áü©ÈòµÂéª‰∏ÄË°å‰∏ÄÂàóÁöÑË°åÂàóÂºèÁöÑÂÄºÁ≠â‰∫éÈÄân-1Êù°ËæπÊûÑÊàêÊ†ëÔºåÊØèÊù°ËæπÊùÉÁöÑ‰πòÁßØÁöÑÂíå„ÄÇÊúÄÂÇªÁöÑÂÅöÊ≥ï‰ºöÂèëÁé∞Ê≤°ÊúâËÄÉËôëÂÖ∂‰ªñËæπË¢´Âà†ÊéâÁöÑÊÉÖÂÜµÔºåÊâÄ‰ª•ÂÖàÊääÊâÄÊúâËæπÈÉΩÂà†ÊéâÔºåÂÜçÂú®Áü©Èòµ‰∏≠Ë°•‰∏ä$ans=\prod(1-p{ij})*|p{ij}/(1-p_{ij})|$ c.‰∫åÁª¥Á∫øÊÆµÊ†ëÂèØ‰ª•ÊîπÊàê‰∏ÄÁª¥Á∫øÊÆµÊ†ëÔºåÊåârÂª∫Á∫øÊÆµÊ†ëÔºåÂè∂Â≠êËäÇÁÇπÂºÄvectorËÆ∞ÂΩïÊâÄÊúâlÔºåÈùûÂè∂Â≠êËÆ∞ÂΩïÂ≠êÊ†ë‰∏≠lÁöÑÊúÄÂ§ßÂÄºÔºåÂà†Èô§ÁöÑËØùÂ∞±Êö¥ÂäõÂà†ÔºåÂèçÊ≠£Âè™Êúâm‰∏™Âå∫Èó¥d.ÊåâdfsÂ∫èÊéíÂ∫èÔºåÂÄºÁ≠â‰∫éÁõ∏ÈÇªÁÇπÁöÑË∑ùÁ¶ªÂä†Ëµ∑Êù•/2e.ËÆ∞ÂΩïÊØè‰∏™ÁÇπÂêëÂâçÊúÄËøúÂà∞ÈÇ£+ÂÄçÂ¢ûf.Âç°Á©∫Èó¥„ÄÇ‰∏§ÁßçÂÅöÊ≥ïÔºö1.ÂàÜÂùóÔºåÊØèsqrt(n)Ë°åËÆ∞ÂΩï‰∏ÄÊ¨°dpÂÄºÔºåÊ±ÇË∑ØÂæÑÁöÑËØùÂ∞±ÂÜçÁî®O(sqrt(n))ÁöÑÁ©∫Èó¥Êö¥ÂäõÊ±Ç2.ÂàÜÊ≤ªÔºåÂØπ‰∫éË°å(l,r)ÔºåÊâæÂá∫‰∏≠Èó¥Ë°åÁöÑÊúÄ‰ºò‰ΩçÁΩÆÔºåÊØèÊ¨°Èù¢ÁßØ/2 18-7-10a.Â§öÈ°πÂºèc.Ë∞ÅÊÉ≥ÂÜôË∞ÅÂÜô„ÄÇ„ÄÇf[i][sta][s]Ë°®Á§∫Âà∞Á¨¨i‰∏™Êï∞ÁöÑÔºåÂâçi‰∏™Êï∞ÁöÑÈõÜÂêà‰∏∫sÔºåÂçïË∞ÉÊ†à‰∏≠ÁöÑÈõÜÂêà‰∏∫staÔºåO(n)ËΩ¨Áßªd.n^2ÊûÑÈÄ†ÔºåÂØπ‰∏Ä‰∏™ËøûÈÄöÂùóÔºåyes &lt;=&gt; sigma(ai)=sigma(bi)ÔºådfsÂà∞Âè∂Â≠êÔºå‰ª•Âè∂Â≠ê‰∏∫Ê†πÂÜçdfsÔºåËÉΩÊµÅÂ∞±ÊµÅe.dp‰ºòÂåñÁΩëÁªúÊµÅÔºå0‰ª£Ë°®‰∏ésÁõ∏ËøûÔºå1‰ª£Ë°®‰∏étÁõ∏ËøûÔºå1ÁöÑÂâçÈù¢Êúâ0ÁöÑËØùÂ∞±Ë¶ÅÊúâ‰∏Ä‰∏™cÁöÑË¥°ÁåÆÔºådp[i][j]Ë°®Á§∫Ââçi‰∏™ÁÇπ‰∏≠Êúâj‰∏™1ÔºåO(1)ËΩ¨Áßª 18-7-11e.Âíå[ÊñáÁêÜÂàÜÁßë]ÂæàÊÉ≥Ôºå‰∏ÄÂè™ÁãóÂèØ‰ª•ÈÄâÊã©ÂÖ¨ÁöÑÊàñËÄÖÊØçÁöÑÔºå‰∏Ä‰∏™‰∫∫Â∏åÊúõÊüê‰∫õÁãóÊòØÂÖ¨ÁöÑÊàñËÄÖÊØçÁöÑ„ÄÇÊúÄÂ∞èÂâ≤ÔºåÁãóÂêës,tËøûËæπÔºå‰∫∫Âêë‰ªñÂ∏åÊúõÁöÑÈÇ£‰∫õÁãóËøûËæπ„ÄÇËÅîÁ≥ªÊúÄÂ∞èÂâ≤ÁöÑÂê´‰πâÂª∫Âõæ„ÄÇf.n=3,4Êó†Ëß£Ôºån&gt;4ÔºåÁ¨¨‰∏ÄÊù°ËæπÈïø1000Ôºå‰ª•ÂêéÊØèÊù°ËæπÂáè0.1ÔºåÊúÄÂêé‰∏§Êù°ËæπÁõ¥Êé•ÁÆóÔºåÊúâÁõ∏Á≠âÁöÑÊ¶ÇÁéáÂæàÂ∞è„ÄÇ„ÄÇd.f[i][j][k]Ë°®Á§∫Ââçi‰∏™‰∫∫‰∏≠ÔºåÊúâjÁªÑÊú™Èó≠ÂêàÔºå‰ª£‰ª∑Âíå‰∏∫k„ÄÇ 1Âà∞nÊØè‰∏™‰ΩçÁΩÆ‰∏äÊúâ‰∏ÄÁõèÁÅØÔºåÁÇπ‰∫ÆiË¶Åw[i]ÁöÑ‰ª£‰ª∑ÔºåÊØè‰∏™‰ΩçÁΩÆ‰ºöË¢´Ëá™Â∑±ÂèäÂ∑¶Âè≥ÁÖß‰∫ÆÔºåË¶ÅÊ±ÇÊØè‰∏™‰ΩçÁΩÆÈÉΩ‰∫ÆÁöÑÊúÄÂ∞è‰ª£‰ª∑„ÄÇdp[i][0/1/2]Ë°®Á§∫Âà∞iÔºå0ÔºöiÁÇπ‰∫Æ‰∫ÜÔºå1ÔºöiÊ≤°ÁÇπ‰∫Æi-1ÁÇπ‰∫Æ‰∫ÜÔºå2ÔºöiÊ≤°ÁÇπ‰∫Æi-1Ê≤°ÁÇπ‰∫ÆÂ§çÊùÇÂ∫¶O(n)Âä†Âº∫ÔºöÂèØ‰ª•‰∫§Êç¢kÔºàk&lt;=9)ÂØπ‰ΩçÁΩÆÁöÑ‰ª£‰ª∑ÔºåÊ±ÇÊúÄÂ∞è‰ª£‰ª∑f[i][j][k][0/1/2]Ë°®Á§∫Âà∞iÔºåÂâçÈù¢Êúâj‰∏™Â∑≤ÁªèÈí¶ÁÇπ‰∫ÜÔºàÂèØ‰ª•ÊòØË¥üÊï∞ÔºâÔºåÂ∑≤ÁªèÊç¢‰∫ÜkÂØπÔºå0/1/2Âêå‰∏äÂÖ∂ÂÆûÂ∞±ÊòØÂ∑≤ÁªèÈÄâ‰∫ÜÊüê‰∫õ‰ΩçÁΩÆÁöÑÈõÜÂêà‰∏çÂ•ΩË°®Á§∫ÔºåÁî®ËÉåÂåÖÊù•ÂÅöÂ§çÊùÇÂ∫¶O(nk^2)]]></content>
  </entry>
  <entry>
    <title><![CDATA[„ÄêÂ≠¶‰π†Á¨îËÆ∞„Äësplay]]></title>
    <url>%2F2018%2F05%2F09%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91splay%2F</url>
    <content type="text"><![CDATA[splayÊòØ‰∏™Â•Ω‰∏úË•øÂ§çÊùÇÂ∫¶O(nlogn)ÔºàÂäøËÉΩÂàÜÊûêÊàë‰∏ç‰ºöÔºâÂ∏∏Êï∞ËæÉÂ§ßËØ∑ÂÜôËø≠‰ª£ÊØèÊ¨°ËØ¢ÈóÆÂêéÈÉΩË¶ÅÂÅösplayÊìç‰ΩúÔºà‰∏ÄÁõ¥ËØ¢ÈóÆÊ∑±Â∫¶‰∏∫O(n)ÁöÑÁÇπÂ∞±ÊåÇ‰∫ÜÔºå‰æãÂ¶Ç‰æùÊ¨°ÊèíÂÖ•1Âà∞nÔºâ‰∏Ä‰∏™Â∏∏Êï∞‰∏çÂ§™Â§ßÁöÑÊ®°Êùø123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;int opt,x;int tot,rt,ch[N][2],fa[N],key[N],num[N],sum[N];inline void newnode(int &amp;pos,int p,int x)&#123; pos=++tot; fa[pos]=p; key[pos]=x; num[pos]=sum[pos]=1; ch[pos][0]=ch[pos][1]=0;&#125;inline void pushup(int x)&#123; sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+num[x];&#125;inline void rotate(int x,int op)&#123; int y=fa[x]; ch[y][!op]=ch[x][op]; fa[ch[x][op]]=y; if(fa[y])&#123; ch[fa[y]][ch[fa[y]][1]==y]=x; &#125; fa[x]=fa[y]; ch[x][op]=y; fa[y]=x; pushup(y); pushup(x); &#125;inline void splay(int x,int goal)&#123; while(fa[x]!=goal)&#123; if(fa[fa[x]]==goal)&#123; rotate(x,ch[fa[x]][0]==x); &#125; else&#123; int y=fa[x]; bool op=ch[fa[y]][0]==y; if(ch[y][op]==x)&#123; rotate(x,!op); rotate(x,op); &#125; else&#123; rotate(y,op); rotate(x,op); &#125; &#125; &#125; if(goal==0)&#123; rt=x; &#125;&#125;inline void insert(int x)&#123; if(rt==0)&#123; newnode(rt,0,x); return; &#125; int tmp=rt; while(1)&#123; if(key[tmp]==x)&#123; ++num[tmp]; splay(tmp,0); return; &#125; if(ch[tmp][key[tmp]&lt;x]==0) break; tmp=ch[tmp][key[tmp]&lt;x]; &#125; newnode(ch[tmp][key[tmp]&lt;x],tmp,x); splay(tot,0); return;&#125;inline bool find(int x)&#123; int tmp=rt; while(tmp)&#123; if(key[tmp]==x)&#123; splay(tmp,0); return 1; &#125; if(key[tmp]&gt;x)&#123; tmp=ch[tmp][0]; &#125; else&#123; tmp=ch[tmp][1]; &#125; &#125; return 0;&#125;inline void pop()&#123; if(num[rt]&gt;1)&#123; --num[rt];--sum[rt];return; &#125; if(!ch[rt][0])&#123; fa[ch[rt][1]]=0; rt=ch[rt][1]; return; &#125; if(!ch[rt][1])&#123; fa[ch[rt][0]]=0; rt=ch[rt][0]; return; &#125; int tmp=ch[rt][0]; while(ch[tmp][1]) tmp=ch[tmp][1]; splay(tmp,rt); ch[tmp][1]=ch[rt][1]; rt=tmp; fa[tmp]=0; fa[ch[rt][1]]=rt; pushup(rt);&#125;inline void del(int x)&#123; if(find(x))&#123; pop(); &#125; &#125;inline int get_pre(int x)&#123; int tmp=rt,ans=INT_MIN; while(1)&#123; if(key[tmp]&lt;x)&#123; ans=max(ans,key[tmp]); if(!ch[tmp][1])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][1]; &#125; else&#123; if(!ch[tmp][0])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][0]; &#125; &#125; return ans;&#125;inline int get_nxt(int x)&#123; int tmp=rt,ans=INT_MAX; while(1)&#123; if(key[tmp]&gt;x)&#123; ans=min(ans,key[tmp]); if(!ch[tmp][0])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][0]; &#125; else&#123; if(!ch[tmp][1])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][1]; &#125; &#125; return ans;&#125;inline int rank(int x)&#123; int tmp=rt,ans=0; while(1)&#123; if(key[tmp]&gt;=x)&#123; if(!ch[tmp][0])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][0]; &#125; else&#123; ans+=sum[ch[tmp][0]]+num[tmp]; if(!ch[tmp][1])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][1]; &#125; &#125; return ans+1;&#125;inline int kth(int x)&#123; int tmp=rt; while(x)&#123; if(sum[ch[tmp][0]]&gt;=x)&#123; tmp=ch[tmp][0]; &#125; else&#123; x-=sum[ch[tmp][0]]; if(x&lt;=num[tmp])&#123; splay(tmp,0); return key[tmp]; &#125; x-=num[tmp]; tmp=ch[tmp][1]; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; opt=read();x=read(); switch (opt)&#123; case 1:&#123; insert(x); break; &#125; case 2:&#123; del(x); break; &#125; case 3:&#123; printf(&quot;%d\n&quot;,rank(x)); break; &#125; case 4:&#123; printf(&quot;%d\n&quot;,kth(x)); break; &#125; case 5:&#123; printf(&quot;%d\n&quot;,get_pre(x)); break; &#125; case 6:&#123; printf(&quot;%d\n&quot;,get_nxt(x)); break; &#125; &#125; &#125; return 0;&#125; splayÊúÄÁâπËâ≤ÁöÑÂå∫Èó¥ÁøªËΩ¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int l,r,rt,tot;int fa[N],sz[N],ch[N][2];bool rev[N];inline void pushup(int x)&#123; sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1;&#125;inline void rotate(int x,int op)&#123; int y=fa[x]; ch[y][!op]=ch[x][op]; fa[ch[x][op]]=y; if(fa[y])&#123; ch[fa[y]][ch[fa[y]][1]==y]=x; &#125; fa[x]=fa[y]; ch[x][op]=y; fa[y]=x; pushup(y); pushup(x);&#125;inline void splay(int x,int goal)&#123; while(fa[x]!=goal)&#123; if(fa[fa[x]]==goal)&#123; rotate(x,ch[fa[x]][0]==x); &#125; else&#123; int y=fa[x]; bool op=ch[fa[y]][0]==y; if(ch[y][op]==x)&#123; rotate(x,!op); rotate(x,op); &#125; else&#123; rotate(y,op); rotate(x,op); &#125; &#125; &#125; if(goal==0)&#123; rt=x; &#125;&#125;inline void pushdown(int x)&#123; if(rev[x])&#123; swap(ch[x][0],ch[x][1]); rev[ch[x][0]]^=1; rev[ch[x][1]]^=1; rev[x]=0; &#125;&#125;inline int find(int x)&#123; int tmp=rt,cnt=0; while(1)&#123; pushdown(tmp); if(sz[ch[tmp][0]]+1==x) return tmp; if(sz[ch[tmp][0]]&gt;=x)&#123; tmp=ch[tmp][0]; &#125; else&#123; x-=sz[ch[tmp][0]]+1; tmp=ch[tmp][1]; &#125; &#125;&#125;inline void rever(int l,int r)&#123; int x=find(l-1),y=find(r+1); splay(x,0); splay(y,rt); rev[ch[y][0]]^=1;&#125;inline void build(int p,int l,int r)&#123; if(l&gt;r) return; if(l==r)&#123; fa[l]=p; sz[l]=1; if(l&lt;p)&#123; ch[p][0]=l; &#125; else&#123; ch[p][1]=l; &#125; return; &#125; int mid=(l+r)&gt;&gt;1; fa[mid]=p; build(mid,l,mid-1); build(mid,mid+1,r); pushup(mid); if(mid&lt;p)&#123; ch[p][0]=mid; &#125; else&#123; ch[p][1]=mid; &#125;&#125;int main()&#123; n=read();m=read(); build(0,1,n+2); rt=(n+3)&gt;&gt;1; while(m--)&#123; l=read()+1;r=read()+1; if(l==r) continue; rever(l,r); &#125; //‰∏çËÉΩprintÔºÅÔºÅÊúâÊ†áËÆ∞ËøòÊ≤°‰∏ãÊîæÔºÅÔºÅ for(int i=2;i&lt;=n+1;++i)&#123; printf(&quot;%d &quot;,find(i)-1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2985The k-th Largest Group]]></title>
    <url>%2F2018%2F05%2F07%2Fpoj2985The%20k-th%20Largest%20Group%2F</url>
    <content type="text"><![CDATA[123456ÂçïÁÇπ‰øÆÊîπÊâæÁ¨¨kÂ§ß‰∫åÂàÜ+Ê†ëÁä∂Êï∞ÁªÑÔºåÂ§çÊùÇÂ∫¶O(nlog^2n)Ê†ëÁä∂Êï∞ÁªÑ‰∏ä‰∫åÂàÜÔºåÂ§çÊùÇÂ∫¶O(nlogn)Â¶ôÊûÅ‰∫ÜÊ†ëÁä∂Êï∞ÁªÑ‰∫åÂàÜÂíåÁ∫øÊÆµÊ†ë‰∫åÂàÜÂ∑Æ‰∏çÂ§ö ‰∫åÂàÜ+Ê†ëÁä∂Êï∞ÁªÑ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=300008;int n,m;int op,x,y;int p[N],p1,p2;int a[N],bit[N];int num;int l,r,mid,k,ans;inline void add(int pos,int x)&#123; for(int i=pos;i&lt;=n;i+=i&amp;-i)&#123; bit[i]+=x; &#125;&#125;inline int sum(int pos)&#123; int tmp=0; for(int i=pos;i;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125;inline int find(int x)&#123; return x==p[x]?x:p[x]=find(p[x]);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; p[i]=i; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]=1; &#125; add(1,n); num=n; while(m--)&#123; op=read(); if(op==0)&#123; x=read();y=read(); p1=find(x); p2=find(y); if(p1==p2) continue; add(a[p1],-1); add(a[p2],-1); add(a[p2]=a[p1]+a[p2],1); p[p1]=p2; --num; &#125; else&#123; k=read(); k=num-k+1; l=1; r=n; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(sum(mid)&gt;=k)&#123; r=mid-1; ans=mid; &#125; else&#123; l=mid+1; &#125; &#125; printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; Ê†ëÁä∂Êï∞ÁªÑ‰∏ä‰∫åÂàÜ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=300008;int n,m;int op,x,y;int p[N],p1,p2;int a[N],bit[N];int num;int k;inline void add(int pos,int x)&#123; for(int i=pos;i&lt;=n;i+=i&amp;-i)&#123; bit[i]+=x; &#125;&#125;inline int sum(int pos)&#123; int tmp=0; for(int i=pos;i;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125;inline int find(int x)&#123; return x==p[x]?x:p[x]=find(p[x]);&#125;inline int query(int pos)&#123; int tmp=0,cnt=0; for(int i=20;i&gt;=0;--i)&#123; tmp+=1&lt;&lt;i; if(tmp&gt;=n||cnt+bit[tmp]&gt;=pos)&#123; tmp-=1&lt;&lt;i; &#125; else&#123; cnt+=bit[tmp]; &#125; &#125; return tmp+1;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; p[i]=i; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]=1; &#125; add(1,n); num=n; while(m--)&#123; op=read(); if(op==0)&#123; x=read();y=read(); p1=find(x); p2=find(y); if(p1==p2) continue; add(a[p1],-1); add(a[p2],-1); add(a[p2]=a[p1]+a[p2],1); p[p1]=p2; --num; &#125; else&#123; k=read(); printf(&quot;%d\n&quot;,query(num-k+1)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ê†ëÁä∂Êï∞ÁªÑ</tag>
        <tag>‰∫åÂàÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1903 [ÂõΩÂÆ∂ÈõÜËÆ≠Èòü]Êï∞È¢úËâ≤]]></title>
    <url>%2F2018%2F05%2F02%2Fluogu1903%20%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E6%95%B0%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[1234567891011Â∏¶‰øÆÊîπÁöÑËé´ÈòüËÆæÂùóÈïø‰∏∫blkÂàôÂ§çÊùÇÂ∫¶‰∏∫O(n*blk+n*n/blk+(n/blk)*(n/blk)*n)ÂùáÂÄºÊ±ÇÂá∫blk=n^(2/3)ÊÄªÂ§çÊùÇÂ∫¶‰∏∫O(n^5/3)ÊéíÂ∫èÁöÑÊó∂ÂÄô‰∏ÄÂÆöË¶ÅÊ±ÇÂá∫ÊØè‰∏™ÁÇπÊâÄÂ±ûÁöÑÂùó‰∏çË¶ÅÁî®Èô§Ê≥ïÔºÅ‰∏çË¶ÅÁî®Èô§Ê≥ïÔºÅ‰∏çË¶ÅÁî®Èô§Ê≥ïÔºÅÔºàtÂà∞Ê≠ªÔºâ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=50008,MAX=1000008;int n,m,blk;int a[N],b[N],be[N];char ch;int idxq,idxc;int curl,curr,curt;int tmp,ans[N],cnt[MAX];struct node&#123; int l,r,tim,id;&#125;q[N];struct node2&#123; int pos,now,pre;&#125;c[N];inline bool cmp(const node &amp;a,const node &amp;b)&#123; return (be[a.l]==be[b.l])?((be[a.r]==be[b.r])?a.tim&lt;b.tim:a.r&lt;b.r):a.l&lt;b.l;&#125;inline void add(int x)&#123; if(!cnt[x]) ++tmp; ++cnt[x];&#125;inline void remove(int x)&#123; --cnt[x]; if(!cnt[x]) --tmp;&#125;inline void going(int pos,int x)&#123; if(curl&lt;=pos&amp;&amp;pos&lt;=curr)&#123; remove(a[pos]); add(x); &#125; a[pos]=x;&#125;int main()&#123; n=read();m=read(); blk=pow(n,0.666666); for(int i=1;i&lt;=n;++i)&#123; b[i]=a[i]=read(); be[i]=i/blk+1; &#125; for(int i=1;i&lt;=m;++i)&#123; ch=getchar(); while(ch!=&apos;Q&apos;&amp;&amp;ch!=&apos;R&apos;) ch=getchar(); if(ch==&apos;Q&apos;)&#123; q[++idxq].l=read(); q[idxq].r=read(); q[idxq].tim=idxc; q[idxq].id=idxq; &#125; else&#123; c[++idxc].pos=read(); c[idxc].pre=b[c[idxc].pos]; b[c[idxc].pos]=c[idxc].now=read(); &#125; &#125; sort(q+1,q+idxq,cmp); for(int i=1;i&lt;=idxq;++i)&#123; while(curt&lt;q[i].tim)&#123; ++curt; going(c[curt].pos,c[curt].now); &#125; while(curt&gt;q[i].tim)&#123; going(c[curt].pos,c[curt].pre); --curt; &#125; while(curl&gt;q[i].l)&#123; add(a[--curl]); &#125; while(curr&lt;q[i].r)&#123; add(a[++curr]); &#125; while(curl&lt;q[i].l)&#123; remove(a[curl]); ++curl; &#125; while(curr&gt;q[i].r)&#123; remove(a[curr]); --curr; &#125; ans[q[i].id]=tmp; &#125; for(int i=1;i&lt;=idxq;++i)&#123; printf(&quot;%d\n&quot;,ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ëé´Èòü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2709 Â∞èBÁöÑËØ¢ÈóÆ]]></title>
    <url>%2F2018%2F05%2F01%2Fluogu2709%20%E5%B0%8FB%E7%9A%84%E8%AF%A2%E9%97%AE%2F</url>
    <content type="text"><![CDATA[1234567ÂÖ≥‰∫éÊéíÂ∫èÁöÑÈÄüÂ∫¶Ôºöcmp&lt;ÈáçËΩΩ&lt;ÂèãÂÖÉÈáçËΩΩÔºàÈÉ®ÂàÜÊï∞ÊçÆÂç≥ÂÆûÈ™åÁªìÊûúÔºâËé´ÈòüË£∏È¢òÂ∞è‰ºòÂåñÔºöÂØπÂ•áÊï∞ÂùóÔºår‰ªéÂ∞èÂà∞Â§ßÂØπÂÅ∂Êï∞Âø´Ôºår‰ªéÂ§ßÂà∞Â∞è 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=50008;int n,m,k,blk;int a[N];int curl,curr;int tmp,ans[N],cnt[N];struct node&#123; int l,r,id;&#125;q[N];inline bool cmp(const node &amp;a,const node &amp;b)&#123; //return (a.l/blk==b.l/blk)?a.r&lt;b.r:a.l&lt;b.l; if(a.l/blk!=b.l/blk) return a.l&lt;b.l; if(a.l/blk%2) return a.r&lt;b.r; return a.r&gt;b.r;&#125;inline void add(int x)&#123; tmp+=2*cnt[a[x]]+1; ++cnt[a[x]];&#125;inline void remove(int x)&#123; tmp-=2*cnt[a[x]]-1; --cnt[a[x]];&#125;int main()&#123; n=read();m=read();k=read(); blk=sqrt(n); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;=m;++i)&#123; q[i].l=read();q[i].r=read();q[i].id=i; &#125; sort(q+1,q+m+1,cmp); curl=1;curr=0; for(int i=1;i&lt;=m;++i)&#123; while(curl&gt;q[i].l)&#123; add(--curl); &#125; while(curr&lt;q[i].r)&#123; add(++curr); &#125; while(curl&lt;q[i].l)&#123; remove(curl); ++curl; &#125; while(curr&gt;q[i].r)&#123; remove(curr); --curr; &#125; ans[q[i].id]=tmp; &#125; for(int i=1;i&lt;=m;++i)&#123; printf(&quot;%d\n&quot;,ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ëé´Èòü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1198 [JSOI2008]ÊúÄÂ§ßÊï∞]]></title>
    <url>%2F2018%2F04%2F30%2Fluogu1198%20%5BJSOI2008%5D%E6%9C%80%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1234567ÂÅöÊ≥ïÂæàÂ§öÊääÊùøÂ≠êÂ§ç‰π†‰∏Ä‰∏ã1.ÂçïË∞ÉÈòüÂàóÔºåÁÑ∂Âêé‰∫åÂàÜ2.ÂçïË∞ÉÈòüÂàóÔºåÁÑ∂ÂêéÁª¥Êä§ÊØè‰∏™‰ΩçÁΩÆÁöÑÊõ¥‰ºòËß£ÔºåÂä†‰∏äË∑ØÂæÑÂéãÁº©3.Ê†ëÁä∂Êï∞ÁªÑÔºåÈúÄË¶Å‰ªéÂêéÂæÄÂâçÂä†ÔºåÊúÄÂ§ßÂÄº‰∏çËÉΩ‰ΩúÂáèÊ≥ï4.Á∫øÊÆµÊ†ë5.ÂàÜÂùó 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int M=200008;int m,d,a;char c[1];int t,l;int q[M],ta,tim[M];int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;d); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%s%d&quot;,c,&amp;a); if(c[0]==&apos;A&apos;)&#123; a=(0ll+a+t)%d; while(ta&amp;&amp;q[ta]&lt;=a) --ta; q[++ta]=a; tim[ta]=++l; &#125; else&#123; if(a)&#123; printf(&quot;%d\n&quot;,t=q[lower_bound(tim+1,tim+ta+1,l-a+1)-tim]); &#125; else&#123; puts(&quot;0&quot;); &#125; &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int M=200008;int m,d,a;char c[1];int t;int q[M],ta,fa[M],num[M],id[M],len;inline int find(int x)&#123; return x==fa[x]?x:fa[x]=find(fa[x]);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;d); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%s%d&quot;,c,&amp;a); if(c[0]==&apos;A&apos;)&#123; a=(0ll+a+t)%d; ++len; num[len]=a; fa[len]=len; while(ta&amp;&amp;q[ta]&lt;=a)&#123; fa[id[ta]]=len; --ta; &#125; q[++ta]=a; id[ta]=len; &#125; else&#123; if(a)&#123; printf(&quot;%d\n&quot;,t=num[find(len-a+1)]); &#125; else&#123; puts(&quot;0&quot;); &#125; &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int M=200008;int m,d,a;char c[1];int t,num,b[M];inline void add(int p,int x)&#123; for(int i=p;i&lt;=m;i+=i&amp;-i)&#123; b[i]=max(b[i],x); &#125;&#125;inline int query(int p)&#123; int tmp=INT_MIN; for(int i=p;i;i-=i&amp;-i)&#123; tmp=max(tmp,b[i]); &#125; return tmp;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;d); num=m; for(int i=1;i&lt;=m;++i)&#123; b[i]=INT_MIN; &#125; for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%s%d&quot;,c,&amp;a); if(c[0]==&apos;A&apos;)&#123; a=(0ll+a+t)%d; add(num,a); --num; &#125; else&#123; if(a)&#123; printf(&quot;%d\n&quot;,t=query(num+a)); &#125; else&#123; puts(&quot;0&quot;); &#125; &#125; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int M=200008;int m,d,a;char c[1];int len,t;int tree[M&lt;&lt;2];inline void update(int x,int l,int r)&#123; if(l==len&amp;&amp;r==len)&#123; tree[x]=a; return; &#125; int mid=(l+r)&gt;&gt;1; if(len&lt;=mid) update(x&lt;&lt;1,l,mid); else update(x&lt;&lt;1|1,mid+1,r); tree[x]=max(tree[x&lt;&lt;1],tree[x&lt;&lt;1|1]);&#125;inline int query(int x,int l,int r)&#123; if(len-a+1&lt;=l&amp;&amp;r&lt;=len)&#123; return tree[x]; &#125; int mid=(l+r)&gt;&gt;1; if(len&lt;=mid) return query(x&lt;&lt;1,l,mid); if(len-a+1&gt;mid) return query(x&lt;&lt;1|1,mid+1,r); return max(query(x&lt;&lt;1,l,mid),query(x&lt;&lt;1|1,mid+1,r));&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;d); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%s%d&quot;,c,&amp;a); if(c[0]==&apos;A&apos;)&#123; a=(0ll+a+t)%d; ++len; update(1,1,m); &#125; else&#123; if(a)&#123; printf(&quot;%d\n&quot;,t=query(1,1,m)); &#125; else&#123; puts(&quot;0&quot;); &#125; &#125; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int M=200008;int m,d,a,t;char c[1];int blk,len;int num[M],bl[M],maxi[M];inline void update()&#123; ++len; bl[len]=(len-1)/blk+1; num[len]=a; maxi[bl[len]]=max(maxi[bl[len]],a);&#125;inline int query(int l,int r)&#123; int tmp=INT_MIN; for(int i=min(r,bl[l]*blk);i&gt;=l;--i)&#123; tmp=max(tmp,num[i]); &#125; for(int i=bl[l]+1;i&lt;bl[r];++i)&#123; tmp=max(tmp,maxi[i]); &#125; for(int i=max(l,(bl[r]-1)*blk+1);i&lt;=r;++i)&#123; tmp=max(tmp,num[i]); &#125; return tmp;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;d); blk=sqrt(m); for(int i=m/blk+1;i;--i)&#123; maxi[i]=INT_MIN; &#125; for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%s%d&quot;,c,&amp;a); if(c[0]==&apos;A&apos;)&#123; a=(0ll+a+t)%d; update(); &#125; else&#123; if(a)&#123; printf(&quot;%d\n&quot;,t=query(len-a+1,len)); &#125; else&#123; puts(&quot;0&quot;); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Á∫øÊÆµÊ†ë</tag>
        <tag>Ê†ëÁä∂Êï∞ÁªÑ</tag>
        <tag>ÂçïË∞ÉÈòüÂàó</tag>
        <tag>Âπ∂Êü•ÈõÜ</tag>
        <tag>ÂàÜÂùó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1484 ÁßçÊ†ë]]></title>
    <url>%2F2018%2F04%2F30%2Fluogu1484%20%E7%A7%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[12345678910111213Â§ßÊ†πÂ†ÜË¶ÅËÉΩÂ§üÂèçÊÇîÊ≥®ÊÑèÂà∞ÈÄâ‰∫Ü‰∏Ä‰∏™ÔºåÂÆÉ‰∏ÄÂÆöÊØî‰∏§ËæπÁöÑ‰ºòÊâÄ‰ª•Ë¶Å‰πàÈÄâÂÆÉÔºåË¶Å‰πà‰∏§ËæπÂêåÊó∂ÈÄâÈÄâ‰∏Ä‰∏™ÁÇπ‰πãÂêéÂ∞ÜÂÆÉ‰∏§ËæπÁöÑÂÄºÂáèÂéªÂÆÉÔºåÊõ¥Êñ∞Âà∞Ëøô‰∏™ÁÇπÔºåÂà†Âéª‰∏§ËæπÁöÑÁÇπËøôÊ†∑ÊØèËΩÆËøòÊòØÁõ∏ÂΩì‰∫éÈÄâ‰∏Ä‰∏™ÁÇπÊ≥®ÊÑèËæπÁïåÂ§ÑÁêÜË∞É‰∫Ü‰∏ÄÂ§©Ë¶ÅÂÖàÂºπÂÆåÁî®ËøáÁöÑÂÜçÂà§Ë¥üÈ°∫Â∫èÂæàÈáçË¶ÅÔºÅÈ°∫Â∫èÂæàÈáçË¶ÅÔºÅÈ°∫Â∫èÂæàÈáçË¶ÅÔºÅ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008;int n,k;int pre[N],nxt[N];LL a[N];priority_queue&lt;pair&lt;LL,int&gt; &gt; q;LL ans;bool vis[N];int main()&#123; n=read();k=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); q.push(mp(a[i],i)); pre[i]=i-1; nxt[i]=i+1; &#125; while(k--)&#123; while(vis[q.top().second])&#123;//Ë¶ÅÁî®whileÔºåifÁöÑËØù‰ºöÊ∂àËÄók q.pop(); &#125; if(q.top().first&lt;=0) break; ans+=q.top().first; int x=q.top().second; q.pop(); a[x]=a[pre[x]]+a[nxt[x]]-a[x]; if(pre[x]!=0)&#123; vis[pre[x]]=1; pre[x]=pre[pre[x]]; nxt[pre[x]]=x; &#125; if(nxt[x]!=n+1)&#123; vis[nxt[x]]=1; nxt[x]=nxt[nxt[x]]; pre[nxt[x]]=x; &#125; q.push(mp(a[x],x)); &#125; printf(&quot;%lld&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>ÊÄùÁª¥</tag>
        <tag>Â†Ü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊäÄÂ∑ß]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[ÂÜÖÂï°ËÇΩÔºöÂÜ∑Èùô‰ΩúÁî®‰øÉËøõÂÜÖÂï°ËÇΩÂàÜÊ≥åÁöÑÊñπÂºèÔºöËøêÂä®ÔºåÂÜ•ÊÉ≥ÔºåÊ∑±ÂëºÂê∏ÔºåÁ¨ë Â§öÂ∑¥ËÉ∫ÔºöÈ¢ÑÊúüÂ•ñÂä±Áü≠ÊúüÂ§ßÈáèÈáäÊîæÂ§öÂ∑¥ËÉ∫ÔºåËÆ©Êàë‰ª¨Êõ¥ËøΩÊ±ÇÁü≠ÊúüÂø´ÊÑüÔºåÊõ¥Ê≤°ËÄêÂøÉ„ÄÇÊõ¥Â§öÁöÑÂ§öÂ∑¥ËÉ∫ÊàñÊèêÈ´òÈòàÂÄºÔºåÂØºËá¥Êõ¥ÈöæËé∑ÂæóÂø´‰πê„ÄÇ‰øùÊåÅÂπ≥Â∏∏ÂøÉÔºåÂáèÂ∞ëÊÉÖÁª™Ê≥¢Âä®ÔºåÈôç‰ΩéÂ§öÂ∑¥ËÉ∫ÂàÜÊ≥å„ÄÇ 1.$n$Áª¥ÊõºÂìàÈ°øË∑ùÁ¶ªÂèØ‰ª•ÂèòÊàê$2^{n-1}$Áª¥Â•ëÊØîÈõ™Â§´Ë∑ùÁ¶ª„ÄÇÔºàÁõ∏ÂΩì‰∫éÊûö‰∏æ$n-1$‰∏™ÁöÑÁ¨¶Âè∑Ôºâ 2.‰∏âÂàÜÔºö(2l+r)/3,(l+2r+2)/3 3.ÂØπÊó∂Èó¥Âª∫Á∫øÊÆµÊ†ëÂèØ‰ª•‰ª£ÊõøcdqÂàÜÊ≤ª 4.‰∫åËøõÂà∂ÂàÜÁªÑ 5.Á¶ªÊï£ÂåñÔºösort+unique+lower_boundsort(a+1,a+n+1);n=unique(a+1,a+n+1)-a-1;Êü•ÂÄºxÔºöreturn lower_bound(a+1,a+n+1,x)-b;ÊàñËÄÖ12345678910for(int i=1;i&lt;=n;++i)&#123; a[i].x=read();a[i].id=i;&#125;sort(a+1,a+n+1,cmp);last=1;b[a[1].id]=1;for(int i=2;i&lt;=n;++i)&#123; if(a[i].x!=a[i-1].x) ++last; b[a[i].id]=last;&#125; 6.hashÔºöÊ®°$2^{31}+1$ÔºåËÆæÂêé31‰Ωç‰∏∫aÔºåÂâçÈù¢‰∏∫bÔºåÂéüÊï∞‰∏∫$a+b*2^{31}$ÔºåÊ®°ÂÆå‰∏∫$a-b$ 7.Âéã‰Ωç 8.Âå∫Èó¥‰ºóÊï∞Á¶ªÁ∫øÔºöËé´Èòü $O(n\sqrt{n})$ Âè≥Á´ØÁÇπÈÄíÂ¢ûÔºõÂ∑¶Á´ØÁÇπÂõ∫ÂÆöÔºåÊØèÊ¨°ÂêëÂ∑¶ÁßªÂà∞ËØ¢ÈóÆÁöÑ‰ΩçÁΩÆÔºåÁªìÊùüÂÜçÊí§ÂõûÂú®Á∫øÔºö(1) ÂàÜÂùó+vector‰∫åÂàÜ $O(n\sqrt{nlogn})$ (2) ÂàÜÂùóÔºåÂØπÊØèÁßçÂÄºÂú®ÊØè‰∏™ÂùóÊú´Â∞æËÆ∞ÂΩïÂá∫Áé∞Ê¨°Êï∞Ôºå$O(n\sqrt{n})$ 9.dtxÔºö ÂÄçÂ¢ûÊõø‰ª£‰∫åÂàÜ 10.‰∫åÂàÜÂõæ‰∏≠ÔºöÊúÄÂ∞èÁÇπË¶ÜÁõñÁ≠â‰∫éÊúÄÂ§ßÂåπÈÖçÔºàÊúÄÂ∞èÁÇπË¶ÜÁõñ$\geq$ÊúÄÂ§ßÂåπÈÖçÔºå‰∏îÊØè‰∏™ÂåπÈÖç‰∏≠Âèñ‰∏Ä‰∏™ÁÇπÂèØ‰ª•Êàê‰∏∫ÁÇπË¶ÜÁõñÔºâ ÊúÄÂ§ßÁã¨Á´ãÈõÜ+ÊúÄÂ∞èÁÇπË¶ÜÁõñ=ÁÇπÊï∞ÔºàÁã¨Á´ãÈõÜÊòØÁÇπË¶ÜÁõñÁöÑË°•ÈõÜÔºâ 11.Á¨¶Âè∑Ôºö%ÁöÑÂÄºÂêåË¢´Èô§Êï∞Ôºå/ÁöÑÂÄºÊ†πÊçÆË¢´Èô§Êï∞ÂíåÈô§Êï∞ÁöÑÁ¨¶Âè∑ÔºåÁõ∏Âêå‰∏∫Ê≠£Ôºå‰∏çÁõ∏Âêå‰∏∫Ë¥ü 12.[k/i]‰∏ÄÂÖ±Ê†πÂè∑‰∏™ÂÄºÔºå‰∏ã‰∏Ä‰∏™i=k/(k/i)+1 13.printfËæìÂá∫doubleÊòØÂõõËàç‰∫îÂÖ•ÁöÑÔºå‰øùÁïô‰∏§‰ΩçÂêë‰∏ãÂèñÊï¥Â∞±-0.005+epsÂÜçËæìÂá∫ÔºåÂêë‰∏äÂèñÊï¥Â∞±+0.005-epsÂÜçËæìÂá∫ doubleÊúâ15‰ΩçÊúâÊïàÊï∞Â≠ó epsÂ∫îËØ•ÊòØÂ∞è‰∫é‰Ω†ËÉΩÁÆóÂá∫Êù•ÊâÄÊúâÊï∞‰∏§‰∏§‰πãÂ∑Æ(xy) Á≤æÂ∫¶ËØØÂ∑ÆÂèØ‰ª•ËÆ§‰∏∫Âú®[-1e-13,1e-13]‰πãÈó¥ ‰ΩïÊó∂+/-epsÂá≠ÊÑüËßâ(xy) Âè™ËÉΩËØ¶ÁªÜËÆ∞ÂΩïÂêÑÁßçÊÉÖÂÜµ‰∫ÜÔºö ÔºàË¥üÊï∞ÁöÑÂõõËàç‰∫îÂÖ•Ë¶ÅÁúãÈ¢òÁõÆÂÆö‰πâÔºåÊïÖÂè™ËÆ®ËÆ∫Ê≠£Êï∞Ôºâ ÊãøËæπÁïåÂæÄÈáåÂ∏¶ Ê≠£Êï∞ÁöÑÂõõËàç‰∫îÂÖ•Ë¶Å+epsÔºåÔºàË¥üÊï∞ÂèØËÉΩË¶Å-eps) 14.Â∞∫ËßÑ‰ΩúÂõæÂè™ËÉΩÂÅöÂä†Âáè‰πòÈô§ÂºÄÊñπ‰∫îÁßçËøêÁÆó 15.ÈöîÊùøÊ≥ïË¶Å‰πàÊòØÈöîÊï∞Â≠óË¶Å‰πàÊòØÈöî‰ΩçÁΩÆ 16.Á∫øÊÄßÊ±ÇÈÄÜÂÖÉÔºöinv[i]=(p-p/i)inv[p%i]%pÊàñËÄÖinv[i]=p-p/iinv[p%i]%p; inv[1]=1ÊòØ‰∏ÄÂÆöË¶ÅÂÜôÁöÑÔºÅ 17.ÊúÄÂ§ßÂõ¢ÂíåÊúÄÂ§ßÁã¨Á´ãÈõÜÊòØÁ≠â‰ª∑ÁöÑÔºåÈÉΩÊòØnpc ‰∏Ä‰∏™ÂõæÁöÑÊúÄÂ§ßÂõ¢ÂíåÂèñÂèçÁöÑÂõæÁöÑÊúÄÂ§ßÁã¨Á´ãÈõÜÁ≠â‰ª∑ 18.È´òÁª¥ÂâçÁºÄÂíåË¶Å‰∏Ä‰Ωç‰∏Ä‰ΩçÂÅö ÈõÜÂêàÁöÑÂ≠êÈõÜÂíåÂíåÈ´òÁª¥ÂâçÁºÄÂíå‰∏ÄÊ†∑ Ë¶Å‰∏Ä‰Ωç‰∏Ä‰ΩçÂÅö Âê¶Âàô‰ºöÈáçÂ§ç 001&lt;-000 010&lt;-000 011&lt;-001 &lt;-010 ÁÑ∂ÂêéÂèëÁé∞000Âú®011‰∏≠Âá∫Áé∞‰∏§Ê¨°„ÄÅ Â∫îËØ•ÊòØ 001&lt;-000 011&lt;-010 010&lt;-000 011&lt;-001 19.ÂùêÊ†áËåÉÂõ¥1Âà∞nÁöÑ‰∏ãÂá∏Â£≥‰∏äÊúâsqrt(n)‰∏™ÁÇπ 20.AÂùêÊ†áÁ≥ª‰∏≠ÁöÑÂàáÊØîÈõ™Â§´Ë∑ùÁ¶ª=BÂùêÊ†áÁ≥ª‰∏≠ÁöÑÊõºÂìàÈ°øË∑ùÁ¶ª AÂùêÊ†áÁ≥ª‰∏≠ÁöÑÊõºÂìàÈ°øË∑ùÁ¶ª=BÂùêÊ†áÁ≥ª‰∏≠ÁöÑÂàáÊØîÈõ™Â§´Ë∑ùÁ¶ªÔºàB‰∏∫AÊóãËΩ¨45¬∞ÔºåÈ°∫Êó∂ÈíàÂíåÈÄÜÊó∂ÈíàÊòØ‰∏ÄÊ†∑ÁöÑÔºåÂõ†‰∏∫Âú®‰∫íÁõ∏ÂûÇÁõ¥ÁöÑÂùêÊ†áÁ≥ª‰∏≠ÂàáÊØîÈõ™Â§´Ë∑ùÁ¶ªÂíåÊõºÂìàÈ°øË∑ùÁ¶ªÊòØÁ≠â‰ª∑ÁöÑÔºâ ÊóãËΩ¨45¬∞,(x,y)-&gt;((x+y)/2,(x-y)/2) ÊõºÂìàÈ°øË∑ùÁ¶ªÔºödis=|x1‚àíx2|+|y1‚àíy2| ÂàáÊØîÈõ™Â§´Ë∑ùÁ¶ªÔºödis=max(|x1‚àíx2|,|y1‚àíy2|) Â∞Ü‰∏Ä‰∏™ÁÇπ(x,y)(x,y)ÁöÑÂùêÊ†áÂèò‰∏∫(x+y,x‚àíy)(x+y,x‚àíy)Âêé,ÂéüÂùêÊ†áÁ≥ª‰∏≠ÁöÑÊõºÂìàÈ°øË∑ùÁ¶ª == Êñ∞ÂùêÊ†áÁ≥ª‰∏≠ÁöÑÂàáÊØîÈõ™Â§´Ë∑ùÁ¶ª Â∞Ü‰∏Ä‰∏™ÁÇπ(x,y)(x,y)ÁöÑÂùêÊ†áÂèò‰∏∫((x+y)/2,(x‚àíy)/2)((x+y)/2,(x‚àíy)/2) Âêé,ÂéüÂùêÊ†áÁ≥ª‰∏≠ÁöÑÂàáÊØîÈõ™Â§´Ë∑ùÁ¶ª == Êñ∞ÂùêÊ†áÁ≥ª‰∏≠ÁöÑÊõºÂìàÈ°øË∑ùÁ¶ª 21.Êó†Âêë‰ªô‰∫∫ÊéåÂõæÂà§ÂÆöÔºödfs+Â∑ÆÂàÜÔºåËøîÁ•ñËæπÁöÑ‰∏ãÁ´ØÁÇπ+1Ôºå‰∏äÁ´ØÁÇπ-1Ôºå‰∏ÄÊù°ËæπÂ±û‰∫é&gt;2‰∏™ÁéØÂ∞±‰∏çÊòØ‰ªô‰∫∫ÊéåÔºåÂê¶ÂàôÊòØ„ÄÇ ÊúâÂêë‰ªô‰∫∫ÊéåÂõæÂà§ÂÆöÔºödfsÔºåÊâæÂà∞‰∏Ä‰∏™ÁéØÂ∞±Êö¥ÂäõÁöÑÊääÁéØ‰∏äÊØèÊù°Ëæπ+1 22.$T(n)=2T(n/2)+O(n) =&gt; O(nlogn)$ $T(n)=T(n/2)+O(n) =&gt; O(n)$ $T(n)=4T(n/2)+O(n) =&gt; O(n^2)$ 23.Â§ÑÁêÜ‰∏éËØ¢ÈóÆÊó†ÂÖ≥ÂèØ‰ª•Áî®ÂàÜÊ≤ª 24.ÊâìÂÜ≥Á≠ñÁÇπÁúãÂÜ≥Á≠ñÂçïË∞ÉÊÄß 25.‰∏ÄÂÆöË¶ÅÈÄ†ÊûÅÈôêÊï∞ÊçÆÔºÅÔºÅÊääintÂÖ®Êç¢ÊàêllÂÜçË∑ë‰∏ÄÈÅçÁúãÁªìÊûú‰πãÁ±ªÁöÑ„ÄÇ 26.‰∏§ÈÅçdfsÊâæÊ†ëÁöÑÁõ¥ÂæÑ‰∏çÈÄÇÁî®‰∫éË¥üÊùÉÔºàËØÅÊòéÈúÄË¶ÅÊØèÊù°ËæπÂ§ß‰∫éÁ≠â‰∫é0ÔºåËøòÊòØdpÁÆ°Áî®Ôºâ ‰æãÂ≠êÔºö(1) -&gt; 1 -&gt; (2) -&gt; -2 -&gt; (3) -&gt; 2 -&gt; (4)Ôºå‰ªé2ÂºÄÂßãÂ∞±ÁàÜÁÇ∏‰∫Ü 27.$\sum_{i|n}n/i=O(n)*Ë¥®Âõ†Êï∞‰∏™Êï∞(n)$ 28.ÂºÄÊ†πÂ§çÊùÇÂ∫¶ÔºöO(loglogn)ÁâõÈ°øËø≠‰ª£Â§çÊùÇÂ∫¶ 29.p1+p2=1ÂàôÊ®°ÊÑè‰πâ‰∏ãp1+p2=1(mod p)ÔºàË¶ÅÊ±ÇÔºöËÆæp1=a/bÔºàÊ≤°ÊúâÁ∫¶ÂàÜÊó∂Ôºâ,(a,p)=1,(b,p)=1Ôºâ 30.Âú®Ââ©‰∏ãÁöÑÊï∞‰∏≠Á≠âÊ¶ÇÁéáÈÄâÔºåÂèØ‰ª•Á≠â‰ª∑‰∏∫Ôºö‰∏çÂáèÂ∞ëÊï∞ÔºåÂú®ÊâÄÊúâÊï∞‰∏≠Á≠âÊ¶ÇÁéáÈÄâÔºåÈÄâ‰∏≠‰∏çÂêàÊ≥ïÁöÑÊó†Êî∂ÁõäÔºåÈáçÊù• ËØÅÊòéÔºö $F=\frac{1}{n-1}(f(1)+‚Ä¶+f(n-1))$ $F=\frac{1}{n}(f(1)+‚Ä¶+f(n-1))+\frac{1}{n}F$ ÊòæÁÑ∂‰∏§ÂºèÁ≠â‰ª∑ 31.treapÁöÑÂà†Èô§Ë¶ÅÊ≥®ÊÑèÔºåÂà†Âà∞‰∏çÂ≠òÂú®ÁöÑËäÇÁÇπË¶ÅÂÅú‰ΩèÔºå‰∏çÁÑ∂tleÔºàcjqÔºâ 32.randÁî®48271ll*seed%INT_MAXÂèØ‰ª•Áîü‰∫ß1Âà∞INT_MAX-1ÁöÑÊâÄÊúâÊï∞ 33.ÁªìÊûÑ‰Ωì‰∏≠ÁöÑÂáΩÊï∞ÂèØ‰ª•Ë∞ÉÁî®ËØ•ÁªìÊûÑ‰ΩìÂêéÈù¢ÁöÑÂáΩÊï∞ÔºåÁªìÊûÑ‰Ωì‰∏≠‰∏çËÉΩÂ£∞ÊòéÂáΩÊï∞„ÄÇ Ê≠£Â∏∏ÁöÑÂáΩÊï∞Â¶ÇÊûúÂá∫Áé∞Âæ™ÁéØË∞ÉÁî®Ë¶ÅÂÖàÂ£∞Êòé„ÄÇ 34.ÈõÜÂêàs ÈÅçÂéÜsÁöÑÂ≠êÈõÜ for(int i=s;i&gt;0;i=(i-1)&amp;s)ÔºàÊ≤°ÊúâÊûö‰∏æÁ©∫ÈõÜ int x=s; while(1){ solve(); if(x==0) break; x=(x-1)&s;//Âè™ÊúâxÊòØsÁöÑÂ≠êÈõÜÁöÑÊó∂ÂÄôÊòØÊúâÊïàÁöÑ } ÈÅçÂéÜsÁöÑË∂ÖÈõÜ for(int i=s;i&lt;Max;i=(i+1)|s) 35.ÊúÄÁü≠Ë∑ØËÆ°Êï∞ÔºàÂÖàÂà§Êéâ0ÁéØÔºâ spfaÔºöÊØèÊ¨°Êõ¥Êñ∞ÂêéË¶ÅÊ∏Ö0 dijkÔºö‰∏çËÉΩÂ§ÑÁêÜ0ËæπÔºüÔºàÊó†0ÁéØÔºâ 36.dag‰∏ädpÔºöÊãìÊâëÂá∫Êù•ÊàñËÄÖËÆ∞ÂøÜÂåñÊêúÁ¥¢Ôºåspfa‰ºötÂïä„ÄÇ 37.ÂèØÂπ∂Â†ÜÁöÑ3ÁßçÂÜôÊ≥ïÔºö 1.Â∑¶ÂÅèÔºàdist_left&gt;=dist_right) 2.Êó†ËÑëÊç¢ 3.ÈöèÊú∫Êç¢ 38.ÂçïË∞É‰∏äÂçáËΩ¨ÊàêÂçïË∞É‰∏çÈôçÈÄöËøáai -&gt; ai-i ÂçïË∞É‰∏çÈôçËΩ¨ÊàêÂçïË∞É‰∏äÂçáÈÄöËøáai -&gt; ai+i 39.ÊúÄÁü≠Ë∑ØÔºöËæπÂ§öÔºö‰∏çÂä†‰ºòÂåñÁöÑdijk ËæπÂ∞ëÔºöÂä†Â†Ü‰ºòÂåñÁöÑdijk 40.Ê†ë‰∏äËÉåÂåÖÊúâÊó∂ÂèØ‰ª•ËΩ¨ÂåñÊàêdfsÂ∫èÂÅöÔºàÊØîÂ¶ÇÂøÖÈ°ªË¶ÅÊòØËøûÈÄöÁöÑÔºåÂØπ‰∫éÊüê‰∏™ÁÇπÔºåÈÄâÂ∞±ÁªßÁª≠Ôºå‰∏çÈÄâÂ∞±Ë∑≥ËøáÊï¥‰∏™Â≠êÊ†ëÔºâ 41.ÊúâÊó∂ËæπÂ≠ò‰∏ç‰∏ã‰ªçÁÑ∂ÊòØÂèØËÉΩÂèØ‰ª•Ë∑ëÂá∫Êù•ÁöÑÔºàÂ≠òËæπÈúÄË¶Å‰πò‰∏ä‰∏Ä‰∏™Â∏∏Êï∞ÔºåÂøÉ‰∏≠ÊúâËæπÂç≥ÂèØ„ÄÇ„ÄÇÔºâ 42.Êï∞ÁªÑÁõ¥Êé•ÂÅöÂèÇÊï∞‰ºöÈöêÂºèËΩ¨Êç¢‰∏∫ÊåáÈíàÔºå‰º†ÂèÇÁöÑÊó∂ÂÄôa[]Âíå*aÊòØÁ≠â‰ª∑ÁöÑÔºåÁîöËá≥ÊñπÊã¨Âè∑ÈáåÂÜô‰∏Ä‰∏™ÈïøÂ∫¶ÈÉΩÊòØÁ≠â‰ª∑ÁöÑÔºå‰∏çËøá‰∫åÁª¥ÊàñÊõ¥È´òÁª¥Êï∞ÁªÑÂè™ÊúâÁ¨¨‰∏ÄÁª¥ÂèòÊàêÊåáÈíà 43.ÊâãÂä®ÂºÄÊ†àÔºö-Wl,‚Äìstack=/Â≠óËäÇÊï∞/ -Wl,‚Äìstack=1000000000 //ÂºÄ1GBÁöÑÊ†à 44.Âå∫Èó¥Âä†Á≠âÂ∑ÆÊï∞ÂàóÔºöÁª¥Êä§ÊØè‰∏™Âå∫Èó¥Âä†ÁöÑa+biÔºàiÊòØÁ¨¨Âá†È°πÔºâ Á∫øÊÆµÊ†ëË¶ÅÊ±ÇËÆ∞ÂΩïÁöÑÂÄºÂíåtagÂèØ‰ª•ÂêàÂπ∂ 45.bit‰∏äÁöÑ‰∫åÂàÜÔºö 1234567891011inline int solve(int x)//Ê±Çmin(i)Ôºå‰ΩøÂæósum[i]&gt;=x&#123; int pos=0; for(int i=20;i&gt;=0;--i)&#123;//20ÊòØlogn if(pos+(1&lt;&lt;i)&lt;=n&amp;&amp;bit[pos+(1&lt;&lt;i)]&lt;=x)&#123; pos+=(1&lt;&lt;i); x-=bit[pos]; &#125; &#125; return pos;&#125; 46.Ôºà‰∫åÁª¥Êï∞ÁÇπÔºâÊ±ÇÁü©ÂΩ¢ÂÜÖÁÇπÁöÑ‰∏™Êï∞ÔºàÁ¶ªÁ∫øÔºâÔºö ÊåâxÊéíÂ∫èÔºåÂú®yËΩ¥‰∏äÂª∫Ê†ëÊ°©ÔºåÈÅáÂà∞Áü©ÂΩ¢ÁöÑÂ∑¶ËæπÁïå‰ΩúÂáèÊ≥ïÔºåÈÅáÂà∞Áü©ÂΩ¢ÁöÑÂè≥ËæπÁïå‰ΩúÂä†Ê≥ï ÔºàÂú®Á∫øÊàñÂ∏¶‰øÆÊîπÔºâÔºö bitÂ•óÊùÉÂÄºÁ∫øÊÆµÊ†ë //233 47.Á∫øÊÆµÊ†ëÁª¥Êä§Âå∫Èó¥gcdÔºöÊòØnlogÔºàÂÅö‰∏ÄÊ¨°ËæóËΩ¨Áõ∏Èô§ÔºågcdÂáèÂ∞è‰∏ÄÂÄçÔºâ 48.noi2016Âå∫Èó¥ÔºåÊåâÂå∫Èó¥ÈïøÂ∫¶ÊéíÂ∫èÔºåÂ∑¶Âè≥ÊåáÈíàÔºåÁ∫øÊÆµÊ†ëÁª¥Êä§Ë¢´Ë¶ÜÁõñÁöÑÊúÄÂ§ßÂÄº 49.BZOJ 4552 Á∫øÊÆµÊ†ëÂêàÂπ∂Ôºü 50.ÁªÑÂêàÊï∞ $(x+1)^n=\sum{i=0}^n({i}^{n})*x^i$ ‰∏§ËæπÊ±ÇÂØºÂêé‰ª§x=1ÔºåÂèØ‰ª•Ê±ÇÂæó‰∏ÄÈò∂ÂíåÂºè ÂÜçÊ±ÇÂØºÂèØÂæó‰∫åÈò∂ÂíåÂºè.. Âç¢Âç°ÊñØÂÆöÁêÜÔºàp‰∏∫Ë¥®Êï∞Ôºâ ÂΩìp=2Êó∂Ôºå$({k}^{n})=0$Âè™Êúân=0,k=1Ôºå$({k}^{n})=1(mod 2)&lt;=&gt;(n and k)==k$ Â∞èÊ†πÂ†ÜÔºåÁ°ÆÂÆöÊ†ëÁöÑÁªìÊûÑÔºåÊ±Ç‰∏çÂêåÊ†ëÁöÑ‰∏™Êï∞Ôºö$\frac{n!}{\prod_{x=1}^n sz[x]}$ 51.Âå∫Èó¥ÂèØÂáèÔºàÊ±ÇÂíåÔºâÊØîÂå∫Èó¥ÂêàÂπ∂/Âå∫Èó¥ÂèØÂä†ÊÄßÔºàmin/maxÔºâÊù°‰ª∂Êõ¥Âº∫ Áå´Ê†ëÂè™ÈúÄË¶ÅÊª°Ë∂≥Âå∫Èó¥ÂêàÂπ∂Ôºå‰∏ç‰øÆÊîπ $$f\big|\bigcup_{i=1}^nAi \big|=\sum{i=1}^nf\big|Ai\big|-\sum{1&lt;=i&lt;j&lt;=n}f\big|A_i\bigcap A_j\big|+‚Ä¶+(-1)^{n-1}f\big|A_1\bigcap‚Ä¶\bigcap A_n\big|$$ 53.ÈöèÊú∫1Âà∞i-1‰Ωú‰∏∫Áà∂‰∫≤ÁöÑÊ†ëÔºöÂπ≥ÂùáÊ∑±Â∫¶O(logn)ÔºåÊúüÊúõÊúÄÂ§ßÊ∑±Â∫¶logn pruferÁºñÁ†ÅÁîüÊàêÊ†ëÔºöÊúüÊúõÊúÄÂ§ßÊ∑±Â∫¶O(sqrt(n))ÔºåÊúüÊúõÂπ≥ÂùáÊ∑±Â∫¶O(logn) 54.ÊñØÁâπÊûóÊï∞/Âç°ÁâπÂÖ∞Êï∞/ÂàíÂàÜÊï∞ÊÄé‰πàÁî®Ôºö Âç°ÁâπÂÖ∞Êï∞ÔºöÔºà‰ª•‰∏ãÈÉΩÊòØÁ≠â‰ª∑ÁöÑÔºâ ÈÄöÈ°πÂÖ¨Âºè1Ôºö$Cn=\dfrac{1}{n+1}{C}{2n}^n={C}{2n}^n-{C}{2n}^{n-1}$ ÈÄöÈ°πÂÖ¨Âºè2Ôºö$Cn=\dfrac{1}{n+1}\sum\limits{i=0}^n\left({C}n^i\right)^2$ ÈÄíÊé®ÂÖ¨Âºè1Ôºö$C{n+1}=\dfrac{2(2n+1)}{n+2}C_n,C0=1$ ÈÄíÊé®ÂÖ¨Âºè2Ôºö$C{n+1}=\sum\limits_{i=0}^nCiC{n-i},C0=1$ Á¨¨‰∫åÁ±ªÊñØÁâπÊûóÊï∞Ôºö ÈÄöÈ°πÂÖ¨ÂºèÔºö$S(n,k)=\frac{1}{k!}\sum{j=0}^{k}(-1)^{k-j}(^k_j)j^n$ ÈÄíÊé®ÂÖ¨ÂºèÔºö$S(n+1,k)=k*S(n,k)+S(n,k-1)$ ÂàíÂàÜÊï∞Ôºö ÈÄíÊé®ÂÖ¨ÂºèÔºö$p(n,k)=p(n-k,k)+p(n-1,k-1)$ 55.ÂØπ‰∏ÄÂ†ÜËØ¢ÈóÆlen[l,r]=kÔºåÂå∫Èó¥Âè™Êª°Ë∂≥ÂèØÂä†ÊÄßÔºåO(n)ÂÅöÊ≥ïÔºàÂú®Á∫øÔºâÔºöÂú®kÁöÑÂÄçÊï∞ÁöÑ‰ΩçÁΩÆÂàíÂàÜÔºåÂêëÂâçÂêëÂêéÁª¥Êä§‰∏ÄÊÆµÔºåÊØè‰∏™ËØ¢ÈóÆÂøÖÂÆöËøá‰∏Ä‰∏™ÂàíÂàÜ‰ΩçÁΩÆ 56.ÂØπ‰∏ÄÂ†ÜËØ¢ÈóÆÔºå‰∏çÂ≠òÂú®Âå∫Èó¥ÂåÖÂê´ÔºåÂç≥l1&lt;=l2&lt;=l3&lt;=l4‚Ä¶,r1&lt;=r2&lt;=r3&lt;=r4‚Ä¶ÔºåÂå∫Èó¥Âè™Êª°Ë∂≥ÂèØÂä†ÊÄßÔºåO(n)ÂÅöÊ≥ïÔºàÁ¶ªÁ∫øÔºâÔºö‰ª•r1‰∏∫ÂàíÂàÜÂêëÂâçÂêëÂêéÂÅöÔºåËøôÊ†∑ÂèØ‰ª•Â§ÑÁêÜÊâÄÊúâËøár1ÁöÑËØ¢ÈóÆÔºåÂΩìli&gt;r1ÁöÑÊó∂ÂÄôÔºåÊØèÊ¨°ÂêëÂ∑¶Êâ´Âè™ÈúÄË¶ÅÊâ´Âà∞‰∏äÊ¨°ÁöÑrÔºåËøôÊ†∑ÊØè‰∏™ÁÇπÂè™‰ºö‰ªéÂ∑¶ËæπÂíåÂè≥ËæπÂêÑÊâ´‰∏ÄÈÅç 57.ÂèØÊåÅ‰πÖÂåñÁ∫øÊÆµÊ†ëÁöÑÂå∫Èó¥‰øÆÊîπÔºöË¶ÅÂºÄ2logÁöÑÁ©∫Èó¥ÔºàÂõ†‰∏∫ÊØèÂ±ÇËÆøÈóÆÊúÄÂ§ñËæπÁöÑ‰∏§‰∏™ËäÇÁÇπÔºâÔºåÊ†áËÆ∞Ê∞∏‰πÖÂåñÔºåÊØèÊ¨°ÁªèËøáÈÉΩÂä†‰∏äÊ†áËÆ∞Âç≥ÂèØ 58.ÂêØÂèëÂºèÂêàÂπ∂Â§çÊùÇÂ∫¶O(nlognlogn)ÊØè‰∏™Êï∞Âè™‰ºöË¢´ÊèíÂÖ•lognÊ¨° splay/treap/fhq treapÂêàÂπ∂ÊòØnlogn ÂêØÂèëÂºèÂêàÂπ∂ÁöÑÁ©∫Èó¥ÊÄé‰πàÈáäÊîæ?Ê≤°ÊúâÊµ™Ë¥πÁ©∫Èó¥ÔºåÂè™ÊòØÊõ¥Êñ∞ÊåáÈíàÊâÄÊåáÁöÑ‰ΩçÁΩÆ 59.Á∫øÊÆµÊ†ëÂêàÂπ∂Ôºö‰∏ÄÂºÄÂßãn‰∏™‰ΩçÁΩÆÔºånlogn‰∏™ËäÇÁÇπÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶nlognÔºàÊØèdfs‰∏ÄÊ¨°Â∞±ÂáèÂ∞ë‰∏Ä‰∏™ÁÇπÔºå‰∏ÄÂÖ±Â∞±‰∏ÄÂºÄÂßãÁöÑnlogn‰∏™ÁÇπÔºåÂêàÂπ∂ËøáÁ®ã‰∏≠‰∏çÂºÄÊñ∞ÁÇπ‰∫ÜÔºâÔºåÁ©∫Èó¥Â§çÊùÇÂ∫¶nlogn 60.Âå∫Èó¥Âä†Á≠âÂ∑ÆÊï∞ÂàóÔºåÂå∫Èó¥Ê±ÇmaxÔºöÂàÜÂùóÔºàÁ∫øÊÆµÊ†ë‰∏çÂèØÂÅöÔºâ Âå∫Èó¥Âä†Á≠âÂ∑ÆÊï∞ÂàóÔºåÂå∫Èó¥Ê±ÇÔºöÁ∫øÊÆµÊ†ë 61. 123456for(int i=0;i&lt;n*2;i++) for(int j=0;j&lt;=n;j++) &#123; f[i+1][j][0]=(f[i][j][0]+f[i][j][1])%mo; if(lk[i+1]) f[i+1][j+1][1]=f[i][j][0]; &#125; ÊÄé‰πànttÔºüÊØè‰∏™ÈìæÁî®ÁªÑÂêàÊï∞ÁÆóÔºånttÂêàÂπ∂ 62.SÂèØÁÆÄÂçïÂõæÂåñÔºöHavel‚ÄìHakimi algorithm/Erd≈ës‚ÄìGallai theorem HHÊòØË¥™ÂøÉÔºåÂ§çÊùÇÂ∫¶O(n^2logn) EGÊòØÁªìËÆ∫ÔºàÔºüÔºâÔºåÂ§çÊùÇÂ∫¶O(n)ÔºåÔºü 63.Êâæ‰∏Ä‰∏™ÂõæÁöÑÊâÄÊúâÁéØÔºütan90 64.ÁÇπ‰∏äÊâìÊ†áËÆ∞Ôºö(1)Â≠êÊ†ëÂíå (2)Âà∞Ê†πÁöÑÂíå 65.n^3/64ÊâæÊúÄÁü≠Ë∑ØÔºàËæπÊùÉ‰∏∫1..Ôºâ bitset lowbitÔºü 66.ÂèñÊ®°ÔºåÈô§0ÔºöËÆ∞ÂΩïÊúâÂ§öÂ∞ë‰∏™0ÔºåÊØèÊ¨°Âáè 67.Á≠îÊ°àÊØîÁä∂ÊÄÅÂ∞èÂèØ‰ª•Áî®Á≠îÊ°à‰Ωú‰∏∫Áä∂ÊÄÅ 68.ÂÜ≥Á≠ñÂçïË∞ÉÊÄßÔºö 1)dpÂÄºÂ∑≤Áü•ÔºüÔºüÂàÜÊÆµÔºåÂÖàÊ±ÇÂâçÈù¢ÂÜçÊ±ÇÂêéÈù¢ 12345678solve(l,r,opt_l,opt_r)&#123; if(l+1&gt;=r) return; mid=(l+r)/2; for()//ÊâæÂà∞opt_mid solve(l,mid,opt_l,opt_mid); solve(mid,r,opt_mid,opt_r);&#125; 2)‰ªé1Âà∞n‰æùÊ¨°Âà∑Ë°® Ê†àÁª¥Êä§ÊØè‰∏™ÂÜ≥Á≠ñÁÇπÂíåÂ∑¶Âè≥Á´ØÁÇπ 69.Âå∫Èó¥Âπ≥ÊñπÂíåÊª°Ë∂≥ÂõõËæπÂΩ¢‰∏çÁ≠âÂºèÔºàËÉΩËΩ¨ÂåñÊàêÂå∫Èó¥Âπ≥Êñπ‰πãÁ±ªÁöÑÂ§ßÊ¶ÇÊúâÂèØËÉΩÊª°Ë∂≥ÂêßÔºâ 70.includeË¶Å1MÁ©∫Èó¥Ôºå‰∏çÁî®ÁöÑÁ©∫Èó¥ÂèØËÉΩ‰ºöË¢´‰ºòÂåñÊéâ(O2?) 71.Â≠êÈõÜÂíåÈóÆÈ¢òÔºà‰∏Ä‰∫õÊï∞ÁöÑÂíåËÉΩÂê¶‰∏∫xÔºâ sum(a)&lt;=nÔºåÂÖ±O(sqrt(n))‰∏™‰∏çÂêåÁöÑÊï∞ÔºåO(nsqrtn)ÁöÑÂ§öÈáçËÉåÂåÖÔºàÂ§öÈáçËÉåÂåÖ‰∏çËÉΩÂéã‰ΩçÔºâ ÊàñËÄÖÊääsqrtn‰∏™‰∏úË•ø‰∫åËøõÂà∂ÊãÜÂàÜÔºåÂèòÊàê01ËÉåÂåÖÔºåÂèòÊàêO(sqrtnlogn)ÔºåÁÑ∂Âêébitset‰ºòÂåñÔºåO(nsqrtnlogn/w) ÂØπ‰∏ÄÂºÄÂßãÁöÑÁâ©ÂìÅÔºö 2x+1‰∏™a =&gt; aÔºåx‰∏™2a 2x+2‰∏™a =&gt; aÔºåaÔºåx‰∏™2a ËøôÊ†∑ÊØè‰∏™Áâ©ÂìÅ‰∏çË∂ÖËøá2‰∏™ÔºåÂèòÊàêsqrtn‰∏™‰∏çÂêåÊï∞ÁöÑ01ËÉåÂåÖ Â§çÊùÇÂ∫¶O(nsqrtn/w) 72.V 1e9 n 100 ‰ΩìÁßØ ai2^bi (a&lt;=10,b&lt;=30) ‰ª∑ÂÄº ci (&lt;=1e9) bi‰ªéÂ§ßÂà∞Â∞èÊéíÂ∫è dp(i,j)Ë°®Á§∫Âà∞Á¨¨i‰∏™Áâ©ÂìÅÔºåÂÆûÈôÖÂÆπÈáèËøòÊúâj2^bi+V%2^bi jÊúÄÂ§ßÂà∞sum(ai) (ËÆ∞Âà∞1000) Êîπ‰∏Ä‰∏ãdp dp(w,j)Ë°®Á§∫Âà∞Á¨¨w‰∏™Áâ©ÂìÅÔºåÂÆûÈôÖÂÆπÈáèËøòÊúâj*2^w+V%2^w ‰æãÈ¢òÔºö 1ÔºàÊ¢¶ÂπªÂ≤õÂÆùÁè†Ôºâ 2‰ΩìÁßØÂ∞èÁöÑÔºåÁâ©ÂìÅÂ∞ëÔºåV 1e18ÔºåÂÆåÂÖ®ËÉåÂåÖ„ÄÇÂÆåÂÖ®ËÉåÂåÖÁöÑÁâ©ÂìÅÂèØ‰ª•ÂèòÊàêai2^0,ai2^1‚Ä¶ 73.Áü≥Â≠êÂêàÂπ∂ÔºöÊúâÂÜ≥Á≠ñÂçïË∞ÉÊÄßÔºåO(n^2) ÂÖàÊåâÈïøÂ∫¶dpÔºåÊØèÂ±ÇËΩ¨ÁßªÊòØO(n) 74.ÂêàÂπ∂Âêå‰ΩôÊñπÁ®ãÔºö ‰∫íË¥®Ôºö‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜ ‰∏ç‰∫íË¥®Ôºö‰∏§‰∏§ÂêàÂπ∂ÔºàÂ∞±ÊòØËß£‰∫åÂÖÉ‰∏ÄÊ¨°ÊñπÁ®ã„ÄÇÔºâÊé®ÂØº 75.‰∫åÊ¨°Ââ©‰Ωô‰∏çË¶ÅÊêûÈîôÔºö $x^2=n(mod p)$ÂØπÊØè‰∏™Á°ÆÂÆöÁöÑnÂú®[0,p)‰∏äÂè™Êúâ‰∏Ä‰∏™Ëß£ ÂØπ(p-1)/2+1‰∏™nÊúâËß£ 76.((~0)&gt;&gt;1)=-1 ((~0u)&gt;&gt;1)=INT_MAX -x=2^32-x a^b&lt;=a+b a^b+2(a&amp;b)=a+b a^b=a+b &lt;=&gt; a&amp;b=0 ÊàñÁöÑÂçïË∞ÉÊÄß (x|y)&gt;=x 77.bitsetËß£ÂÜ≥5Áª¥ÂÅèÂ∫èÔºàÂèØ‰ª•Ëß£ÂÜ≥kÁª¥ÂÅèÂ∫èÔºåÂ§çÊùÇÂ∫¶ÔºöÈ¢ÑÂ§ÑÁêÜO(kn)ÔºåÊØèÊ¨°ËØ¢ÈóÆO(ksqrtn)Ôºâ 78.Âä®ÊÄÅÂä†ËæπÔºåÊ±Ç‰∏§ÁÇπË∑ØÂæÑÂíåÔºünlognÔºåÂêØÂèëÂºèÂêàÂπ∂ 79.ÁªôÂÆö n ‰∏™Êï∞ a[1..n]ÔºåÊ±ÇÊúâÂá†‰∏™Â≠êÈõÜÊª°Ë∂≥ÔºöÂ≠êÈõÜÁöÑÂºÇÊàñÂíåÁ≠â‰∫éËøô‰∏™Â≠êÈõÜÁöÑAND 80.doubleÁöÑ‰∫åÂàÜÂßøÂäøÔºö‰∏çËÉΩÂç°Á≤æÂ∫¶ÔºåÂè™ËÉΩÂç°Ê¨°Êï∞ while(r-l&gt;eps)ÊòØÈîôÁöÑ„ÄÇ„ÄÇ for(Ê¨°Êï∞)ÔºàÊé®ËçêÂÜôÊ≥ïÔºâ while‰ºöÂÅú‰∏ç‰∏ãÊù•ÔºàÂõ†‰∏∫mid=(l+r)/2==lÔºâ 1234567 l=1;r=123456789123.123;while(r-l&gt;eps)&#123; mid=(l+r)/2; l=mid; printf("%.10f %.10f %.10f\n",l,r,mid);&#125; [-A,A]ÁöÑÂ§ñÊé•ÂúÜÁöÑÂçäÂæÑÊòØA^2Á∫ßÂà´ÁöÑ ‰∫åÂàÜÁî®sqrt(l*r)ÂèØ‰ª•Ê¨°Êï∞Êõ¥Â∞ë„ÄÇ(l,r&gt;0) ÂáΩÊï∞ÂØπlong doulbeÊúâÂçïÁã¨ÁöÑÁâàÊú¨ 89.$[\frac {[\frac{a}{b}]}{c}]=[\frac{a}{bc}]$ ÁîªÁîªÁ∫øÊÆµÂ∞±ËÉΩËØÅÊòé 90.knight‚Äôs tourÔºö nn‰∏≠Ôºån&gt;=5Â≠òÂú®ÂìàÂØÜÂ∞îÈ°øË∑ØÂæÑÔºån&gt;=6‰∏în‰∏∫ÂÅ∂Êï∞Â≠òÂú®ÂìàÂØÜÂ∞îÈ°øÂõûË∑ØÔºàËØÅÊòéËßÅwikiÔºâ nm‰∏≠ÔºåÂè™Ë¶Åmin(n,m)&gt;=5ÂàôÂ≠òÂú®ÂìàÂØÜÂ∞îÈ°øË∑ØÂæÑÔºåÊó†ËØÅÊòéÔºàÊêúÁ¥¢ËØÅÊòé„ÄÇ„ÄÇ 91.doubleÁöÑ‰∏âÂàÜÂßøÂäø 12345//Ê≥®ÊÑèÂç°Ê¨°Êï∞//mid1=l+(r-l)/3;//mid2=l+(r-l)/3*2;mid1=(2*l+r)/3,mid2=(l+2*r)/3;//2ÁßçÁªìÊûú‰∏ÄÊ†∑ÁöÑ‰∏âÂàÜÊñπÂºèÔºåËøôÁßçÊó∂Èó¥Á´üÁÑ∂ÊòØÊ≥®ÈáäÊéâÁöÑÈÇ£ÁßçÁöÑ1/4ÔºåÁ•ûÂ•á intÁöÑ‰∏âÂàÜÂßøÂäø 12345while(l+9&lt;=r)&#123; ll=l+(r-l)/3; rr=r-(r-l)/3;&#125;for(l to r) update(ans); 92.Â∏∏ËßÅnpcÔºö ÂìàÂØÜÂ∞îÈ°øÂõûË∑ØÔºàÂìàÂØÜÂ∞îÈ°øË∑ØÂæÑ‰∏çÊòØÔºå‰ΩÜÊòØ‰æùÊóßÊ≤°ÊúâÂ§öÈ°πÂºèÁÆóÊ≥ïÔºâ tsp ÂõæÂêåÊûÑÔºöÂõæG1ÊòØÂê¶‰∏éÂõæG2ÂêåÊûÑÔºüÂ≠êÂõæÂêåÊûÑÔºöÂõæG1ÊòØÂê¶‰∏éÂõæG2ÁöÑ‰ªª‰∏ÄÂ≠êÂõæÂêåÊûÑÔºüÂ≠êÂõæÂêåÊûÑÈóÆÈ¢òÊòØNPCÔºåËÄåÂõæÂêåÊûÑÈóÆÈ¢ò‰∏ÄËà¨ËÆ§‰∏∫‰∏çÊòØP‰πü‰∏çÊòØNPCÈóÆÈ¢òÔºåËôΩÁÑ∂ÂÆÉÊòéÊòæÊòØ‰∏Ä‰∏™NPÈóÆÈ¢ò„ÄÇËøôÊòØ‰∏Ä‰∏™ÂÖ∏ÂûãË¢´ËÆ§‰∏∫ÂæàÈöæÂç¥Ëøò‰∏çÊòØNPCÈóÆÈ¢òÁöÑ‰æãÂ≠ê„ÄÇ 3satÂèä‰ª•‰∏ä ËÉåÂåÖ ‰∏ÄËà¨ÂõæÊüìËâ≤ Â≠êÈõÜÂíåÈóÆÈ¢ò ÂÖ®ÊéíÂàóÈóÆÈ¢ò nÁöáÂêéÈóÆÈ¢òÂ∏∏ËßÅnp-hardÔºö Ê±ÇÂõæÁöÑÊúÄÈïøË∑Ø ‰∏ÄËà¨ÂõæÊúÄÂ§ßÂõ¢ ‰∏ÄËà¨ÂõæÊúÄÂ§ßÁã¨Á´ãÈõÜÂ∏∏ËßÅnpÔºö ÊãìÊâëÂõæËÆ°Êï∞ 93.(a|b)+(a&amp;b)=a+b 94.c++03ÁöÑ‰∏úË•øÔºö 123timeb tim;ftime(&amp;tim);srand(tim.time*1000+tim.millitm); 95.set s; ÈáçËΩΩÊñπÂºèÔºö 1.Áõ¥Êé•ÈáçËΩΩpairÁöÑÊØîËæÉÊñπÂºè Âú®ÂÖ®Â±ÄÂÜôbool operator &lt; (const pii &amp;a,const pii &amp;b) 2.Âú®Ëøô‰∏™setÈáåÈù¢ÈáçËΩΩ struct cmp{ bool operator () (const pii &amp;a,const pii &amp;b){ } } 96.a&lt;bÔºåb&lt;cÔºåÂ¶ÇÊûúËÉΩÊé®Âá∫a&lt;c 97.()ÂêéÁöÑconstË°®Á§∫ÂΩìÂâçÁªìÊûÑ‰ΩìÔºå‰ªÄ‰πàÊó∂ÂÄôË¶ÅÁî®ÔºüÂ∫ìÂáΩÊï∞Ôºà‰∏ç‰øÆÊîπthisÔºâ friend‰ªÄ‰πàÊó∂ÂÄôË¶ÅÁî®ÔºüÊúâprivateÔºåÂíåÂÜôÂ§ñÈù¢‰∏ÄÊ†∑ 98.Ê®°ÊãüÈÄÄÁÅ´ Áà¨Â±±ÔºàÂá∏ÂáΩÊï∞Ôºå‰πüÂ∞±ÊòØÂè™Êúâ‰∏ÄÂ∫ßÂ±±Â≥∞Ôºâ 99.Ë¶ÅÂØπ10‰ª•ÂÜÖÁöÑcÊïèÊÑü from dtx 100.Â±ÄÈÉ®Âà∞Êï¥‰Ωì 101.ÂÖ®Â∫èÂÖ≥Á≥ªÊâçËÉΩÊéíÂ∫èÔºåÂÅèÂ∫èÂÖ≥Á≥ªÂè™ËÉΩÊãìÊâëÊéíÂ∫è 102.dijkÁî®Â†Ü‰ºòÂåñmlogn Áî®Ê°∂‰ºòÂåñO(n+m+ÊúÄÂ§ßÊùÉÂÄº)ÔºåÁî®ÊåáÈíàÁª¥Êä§ÔºàÊùÉÂÄºÈÄíÂ¢ûÔºâ /ÔºöÊ†πÁõÆÂΩï/home/noilinux/Êàñ~/ÔºöÂΩìÂâçÁî®Êà∑ÁöÑÁõÆÂΩïlsÔºöÊòæÁ§∫ÂΩìÂâçÂàóË°®ls + Ë∑ØÂæÑÔºöÊòæÁ§∫Ë∑ØÂæÑ‰∏ãÁöÑÂàóË°®cd + Ë∑ØÂæÑÔºö/homeÔºàÁªùÂØπË∑ØÂæÑÔºâ Êàñ DesktopÔºàÁõ∏ÂØπË∑ØÂæÑÔºâÊàñ cd ..ÔºàËøîÂõû‰∏ä‰∏ÄÂ±ÇÔºâ/./ÔºöÂΩìÂâçË∑ØÂæÑ/../Ôºö‰∏äÂ±ÇË∑ØÂæÑmkdirÔºöÂàõÂª∫Êñá‰ª∂Â§πrm -r + ÁõÆÂΩïÔºöÂà†Èô§ÂΩìÂâçÁõÆÂΩïÂèäÈáåÈù¢ÊâÄÊúâÁöÑ‰∏úË•øÔºà-r ÈÄíÂΩíÂú∞Âà†Ôºâsf_sharefoldÂíå/‰∏çÊòØÂêåÁ∫ßÁöÑÔºöÂú®/‰∏ãÁöÑÊüê‰∏™Êñá‰ª∂Â§πÂÜÖtouch + Êñá‰ª∂ÂêçÔºöÔºàÂàõÂª∫Êñá‰ª∂Ôºâ‰øÆÊîπÊñá‰ª∂ÁöÑ‰øÆÊîπÊó•ÊúüÔºàÊ≤°ÊúâÂ∞±ÂàõÂª∫Ôºâcat + Êñá‰ª∂ + Êñá‰ª∂ÔºöÔºàÊòæÁ§∫Êñá‰ª∂ÂÜÖÂÆπÔºâÂ∞ÜÂá†‰∏™Êñá‰ª∂ÁöÑÂÜÖÂÆπÊòæÁ§∫Âá∫Êù•mv + Êñá‰ª∂ + Ë∑ØÂæÑÔºöÂ∞ÜÊñá‰ª∂ÁßªÂä®Âà∞Ë∑ØÂæÑ‰∏ãcp + Êñá‰ª∂ + Ë∑ØÂæÑÔºöÂ∞ÜÊñá‰ª∂Â§çÂà∂Âà∞Ë∑ØÂæÑ‰∏ãÂ∞ÜÊñá‰ª∂Â§çÂà∂Âà∞Êñá‰ª∂Ôºö1.cp + Êñá‰ª∂ + Êñá‰ª∂2.cat + Êñá‰ª∂ + &gt;Êñá‰ª∂mvÂíåcp ÈÉΩË¶ÅÂä†-rÊâçËÉΩÂØπÊñá‰ª∂Â§πÊìç‰Ωú;ÂèØ‰ª•ÈöîÂºÄ‰∏§‰∏™ÂëΩ‰ª§echoÊàñprintfÔºöËæìÂá∫\;ÂèØ‰ª•ËæìÂá∫;‚Äú‚ÄùÂèØ‰ª•Êää‰∏úË•øÊêûÊàêÂ≠óÁ¨¶‰∏≤echo + ‰ø°ÊÅØ + &gt;Êñá‰ª∂ÔºöÂ∞Ü‰ø°ÊÅØË¶ÜÁõñÂà∞Êñá‰ª∂echo + ‰ø°ÊÅØ + &gt;&gt;Êñá‰ª∂ÔºöÂ∞Ü‰ø°ÊÅØËøΩÂä†Âà∞Êñá‰ª∂Âêé0Ôºöstdin1Ôºöstdout2Ôºöstderrctrl+cÔºöÈÄÄÂá∫ÂΩìÂâçÂëΩ‰ª§ctrl+zÔºöÂ∞ÜÂΩìÂâçÂëΩ‰ª§ÂéãÂà∞Ê†à‰∏≠fgÔºöÂ∞ÜÂëΩ‰ª§‰ªéÊ†à‰∏≠ÂºπÂá∫ctrl+dÔºöEOFdiff + Êñá‰ª∂ + Êñá‰ª∂ÔºöÁõ∏Âêå‰∏∫0Ôºå‰∏çÂêå‰∏ç‰∏∫0g++ -WallÔºöÊòæÁ§∫ÊâÄÊúâwarning -O0 -O1 -O2 -O3 -OfastÔºöÂä†ÈÄü -gÔºöÁîüÊàêÁªôË∞ÉËØïÂô®Áî®ÁöÑ‰ø°ÊÅØ -lmÔºöÈìæÊé•Êï∞Â≠¶Â∫ìÔºà‰∏çÂä†‰πüË°åÔºâ -o + Êñá‰ª∂ÔºöËæìÂá∫Âà∞ÊåáÂÆöÊñá‰ª∂ -std=c++11 -Wl,‚Äìstack=/Ê†àÁöÑÂ§ßÂ∞èÔºåÂçï‰ΩçÂ≠óËäÇ/bash + a.shÔºöÁî®bashËøêË°åÊñá‰ª∂ 104.+-1rmqÔºöÊåâlen=logn/2ÂàÜÂùóÔºåÂØπÊï¥Âùó‰ΩústË°®ÔºåÂ§çÊùÇÂ∫¶O(n) ÂØπÂùóÂÜÖËøõË°åÈ¢ÑÂ§ÑÁêÜÔºåÊú¨Ë¥®‰∏çÂêåÁöÑÂùó‰∏ÄÂÖ±O(2^len)=O(sqrt(n))‰∏™ÔºåÂØπËøô‰∫õÂùóÁöÑÊØè‰∏™[l,r]ÈÉΩÊö¥ÂäõÈ¢ÑÂ§ÑÁêÜÔºåÂ§çÊùÇÂ∫¶O(sqrtloglog) Êü•ËØ¢O(1)105.dag‰∏≠Ê±ÇÔºö 1)‰∏Ä‰∏™ÁÇπËÉΩÂà∞ÁöÑÁÇπÊï∞ÔºöO(nn/32)Ôºåbitset‰ºòÂåñÊö¥Âäõ 2)ÊãìÊâëÂ∫èÁöÑ‰∏™Êï∞ÔºöÁä∂ÂéãÔºåO(2^nn) 106.%d‚Äì&gt; for int %u‚Äì&gt; for unsigned int %ld‚Äì&gt; for long int %lu‚Äì&gt; for unsigned long int %lld‚Äì&gt; for long long int %llu‚Äì&gt; for unsigned long long int 107.char[][]Ôºà‰∏ÄÂ†ÜÂ≠óÁ¨¶‰∏≤ÔºâËøõË°åÊéíÂ∫èÔºöÊñ∞ÂºÄ‰∏Ä‰∏™‰ΩçÁΩÆÊï∞ÁªÑÔºåÂØπËøô‰∏™Êï∞ÁªÑÊéíÂ∫è 108.namespaceÊòØ‰∏™Â•Ω‰∏úË•øÔºåÂú®Â§ñÈù¢ÁöÑÂèòÈáèËøòÊòØÂÖ®Â±ÄÁöÑÔºåÈô§‰∫ÜÂèØ‰ª•ÈáçÂèòÈáèÂêçÊ≤°Âï•ÁâπÂà´„ÄÇ 109.Â≠óÁ¨¶‰∏≤hashÂÜ≤Á™ÅÁöÑÊ¶ÇÁéáÔºö‰ΩøÁî®Ê¨°Êï∞^2/Ê®°Êï∞Â§ßÂ∞èÔºàÂíåÁîüÊó•ÊÇñËÆ∫Â∑Æ‰∏çÂ§öÔºüÔºâÔºåË¶ÅÂèåhash 110.#define rep(ÂΩ¢ÂèÇÔºåÂΩ¢ÂèÇÔºå‚Ä¶) ÊõøÊç¢ÂàóË°® ‰æãÂ¶ÇÔºö #define rep(i,x,y) for(int i=(x);i&lt;=(y);++i)//ËÆ∞ÂæóÊâìÊã¨Âè∑Ôºå‰∏çÁÑ∂‰º†1&lt;&lt;nÂ∞±ÊåÇ‰∫Ü 111.‰∫åÁª¥Êï∞ÁªÑ‰º†ÂèÇ(int a[x][y])ÊàñËÄÖ(int a[][y])ÔºåÂè™ÊúâÁ¨¨‰∏ÄÁª¥ÂèØ‰ª•‰∏çÂÜôÔºÅ 112.rand()ÊòØÈÄöËøáÁ∫øÊÄßÈÄíÊé® windows‰∏ãÊ®°32768 rand()%(2^x)ÊúâÂë®ÊúüÔºåÂ§ßÊ¶Ç1e5 Êõ¥Â•ΩÁöÑÈöèÊú∫Êï∞ÊòØ mt19937 mt(/ÈöèÊú∫Êï∞ÁßçÂ≠ê/); ËÆæÁΩÆÁßçÂ≠êÁöÑÁ¨¨‰∫åÁßçÊñπÊ≥ïÔºö mt.seed(/ÈöèÊú∫Êï∞ÁßçÂ≠ê/); Âú®ÈáåÈù¢Ôºàc++11Ôºâ mt19937 mt(time(0)); mt();//ËøîÂõû‰∏Ä‰∏™ÈöèÊú∫Êï∞ mt.min();//mtÁöÑÊúÄÂ∞èÂÄº0 mt.max();//mtÁöÑÊúÄÂ§ßÂÄº2^32-1 mt19937_64 mt(time(0)); mt(); mt.max();//ÊúÄÂ§ßÂÄº‰∏∫2^64-1 Ê≥®ÊÑèuÂíålluËæìÂá∫ 113.dijk‰∏çÁî®visÊØèÊ¨°Âà§Êñ≠ÂíåÊúÄÂ∞èÂÄºÊòØÂê¶Áõ∏ÂêåÂç≥ÂèØÔºåpqÂÜôÂ§ßÊ†πÂ†Ü‰πü‰ºöÂæóÂà∞Ê≠£Á°ÆÁöÑÁªìÊûúÔºà‰ΩÜÊòØ‰ºötÔºâ 114.È´òÊñØÊ∂àÂÖÉÂ§çÊùÇÂ∫¶Ôºönmmin(n,m) 115.ÈÇªÊé•Ë°®Âà§ÈáçËæπÔºö 116.kÂèâÂìàÂ§´ÊõºÊ†ëÂèØ‰ª•O(n)ÊûÑÈÄ†Ôºö Ê°∂ÊéíÔºåÁÑ∂ÂêéÁî®‰∏§‰∏™ÈòüÂàó kÂèâÂìàÂ§´ÊõºÊ†ëÁöÑdp f[i][j]Ë°®Á§∫Â∑≤ÁªèÂÅöÂÆå‰∫ÜÂâçi‰∏™ÂÖÉÁ¥†ÔºåËøòÁ©∫Âá∫j‰∏™Âè∂Â≠êËäÇÁÇπÁöÑÊúÄÂ∞è‰ª£‰ª∑ f[0][1]=0,ÂÖ∂‰ªñ‰∏∫inf Á¨¨‰∫åÁª¥ÊúÄÂ§ß‰∏∫Â§ß‰∫énÁöÑ2ÁöÑÂπÇ $f[i+1][j-1]=min(f[i][j]),f[i][j*k]=min(f[i][j]+\sum_{p=i+1}^{n}a[p])$ $ans=min(f[n][p])(0&lt;=p&lt;n)$ #458. ÊàëÊâç‰∏çÊòØËêùËéâÊéßÂë¢ ËøôÈ¢òÂíåÂìàÂ§´ÊõºÊ†ëÁöÑdpÊúâÁ±ª‰ºº ‰ΩÜÊòØÊúâ‰∫õ‰∏çÂêå Â∞ÜdpÁöÑÂê´‰πâÊîπÊàêf[i][j]Ë°®Á§∫ÂÅöÂÆåÂâçi-1‰∏™ÂÖÉÁ¥†Âç≥ÂèØ Ë¶ÅÊ±ÇÁöÑÁ≠îÊ°à‰πüÊòØf[n][1]ÔºåÂõ†‰∏∫ÊúÄÂêéÊîæÂÆå‰∏ÄÂÆöÊ≤°ÊúâÁ©∫ËäÇÁÇπ 117.tr1ÊòØc++03ÁöÑusing namespace tr1;ÔºàÂú®using std‰πãÂêéÂä†Ôºâ Â§¥Êñá‰ª∂Â¶Ç#include 118.‰øùÂ∫èÂõûÂΩíÔºö Â∞ÜÊï∞ÂàóaË∞ÉÊï¥ÊàêÂçïË∞É‰∏çÈôçÁöÑÊúÄÂ∞è‰ª£‰ª∑ÔºåaË∞ÉÊï¥‰∏∫bÁöÑ‰ª£‰ª∑‰∏∫|a-b| Ë∞ÉÊï¥‰∏∫ÂçïË∞É‰∏äÂçáÂàôÂØπai-=i ÂéüÂõ†Ôºö Áª¥Êä§ÁöÑÊØè‰∏™ÁÇπÂèØ‰ª•Âà∞ËææÁöÑÊúÄ‰ΩéË∑ùÁ¶ª Âè™ÊúâÂΩìÂÜçÊ¨°Â∞è‰∫éÊúÄ‰ΩéË∑ùÁ¶ªÂêéÊâçË¶ÅÁªßÁª≠Êõ¥Êñ∞Á≠îÊ°à ÂÅöÊ≥ïÂá∫Â§ÑÔºöhttp://codeforces.com/blog/entry/47094?#comment-315161 ÂÜôÁöÑÂ•ΩÁúãÁöÑdpÔºöhttps://blog.csdn.net/Vectorxj/article/details/78793739 ‰ªîÁªÜÊÄùËÄÉÂèëÁé∞ÔºåËÄÉËôëÂáΩÊï∞ÂõæÂÉèÂπ∂‰∏çËÉΩÂæàÂ•ΩÁöÑËß£ÈáäÔºàÊàñËÄÖÊàëÂ§™Âº±‰∫Ü Êú¨Ë¥®ËøòÊòØÁª¥Êä§Âà∞ËææÁöÑÊúÄ‰ΩéË∑ùÁ¶ª ‰ΩÜÊòØÂéüÊù•ÁöÑÁêÜËß£Êúâ‰∫õÂÅèÂ∑Æ ËÆ∞f[i]Ë°®Á§∫ËÄÉËôë[1,i]ÁöÑÁ≠îÊ°à ÈÇ£‰πàf[i]ÊòØÂçïË∞É‰∏çÈôçÁöÑ ÔºàÊ≥®ÊÑèÈ¢òËß£‰∏≠ÁöÑfi[x]ÊòØ‰∏ãÂá∏ÁöÑÔºåÊ≤°ÊúâÊñúÁéá‰∏∫ÈùûË¥üÁöÑÁ∫øÊÆµÔºâ pq‰∏≠Â≠òÁöÑÊòØ‰∏çÊîπÂèòÂΩìÂâçÁ≠îÊ°àÁöÑÊÉÖÂÜµ‰∏ãÔºåËÉΩÂèòÊàêÁöÑÊúÄ‰ΩéÁöÑÊÉÖÂÜµ Âõ†‰∏∫fi[opt[i]]=fi-1[opt[i-1]]+opt[i-1]-a[i] ÊâÄ‰ª•Â∞ΩÈáèÊääopt[i]ÂèòÂ∞èÔºåÂ∞±ÊòØÊääÂ§ßÁöÑÂæÄ‰∏ãÊãâÔºàÊ≥®ÊÑèÊãâÂÆå‰πãÂêéÂπ∂‰∏çÊòØÂêàÊ≥ïÁöÑÂ∫èÂàóÔºåÂè™ÊòØ‰øùËØÅÊúâ1.Êª°Ë∂≥Á≠îÊ°à2.ÊúÄÂ§ßÂÄºÊòØopt[i] ÁöÑÂ∫èÂàóÔºâ ÂΩìÊâÄÊúâopt[i]ÈÉΩÂèòÂ∞è‰ª•ÂêéÔºåÊúÄÂ§ßÂÄºÂ∞±ÂèòÂ∞è‰∫Ü ÂèçÊ≠£Â∞±ÊòØ‰∏çÂ§™ÂÆπÊòìÁêÜËß£ cjqÂ§™Âº∫‰∫Ü cfÁöÑÂÅöÊ≥ïÊòØÁª¥Êä§ÊäòÁ∫ø Áª¥Êä§ÊäòÁ∫ø‰∏ÄËà¨Ë¶ÅÁª¥Êä§Ê®™Á∫µÂùêÊ†áÊàñËÄÖÊñúÁéá‰ªÄ‰πàÁöÑ ËøôÈ¢òÂè™ÈúÄË¶ÅÁª¥Êä§Ê®™ÂùêÊ†áÂíåÊñúÁéá ‰∏Ä‰∏™ÁÇπÂíå‰∏ã‰∏Ä‰∏™ÁÇπÁöÑÊñúÁéá‰∏∫‰∏•Ê†ºÊØîËøô‰∏™ÁÇπÂ§ßÁöÑÁÇπÁöÑ‰∏™Êï∞ Âõ†‰∏∫ÊñúÁéáÁöÑÂèòÂåñÂè™Êúâ+-1 ÂèØ‰ª•ÈÄöËøáÂä†ÁÇπÂíåÂà†ÁÇπÊù•Áª¥Êä§ 12345678910 priority_queue&lt;int&gt; q; q.push(a[1]); for(int i=2;i&lt;=half_n;++i)&#123; if(q.top()&gt;a[i])&#123; ans+=q.top()-a[i]; q.pop(); q.push(a[i]); &#125; q.push(a[i]);&#125; 119.vector()Ë°®Á§∫Á©∫vector 120.‰∏ÄËà¨ÂõæÂõõÂÖÉÁéØÔºön^3/32 ‰∫åÂàÜÂõæÂõõÂÖÉÁéØÔºömsqrt(m)ÔºåÂàÜÂ§ßÂ∞èÁÇπ 12345678for (int i = 1; i &lt;= n; i++) &#123; f[i] = a[i];&#125;for (int i = 1; i &lt;= n; i++) &#123; for (int j = 2 * i; j &lt;= n; j += i) &#123; f[j] -= f[i]; &#125;&#125; ÂΩìa[i]=iÊó∂Ôºåf[i]=\phi(i)Áåú‰∏ÄÊ≥¢ÁªìËÆ∫Ôºö$$when\ \varphi(i)\neq0,f[i]=(\sum{j|i}\mu(j)\cdot a[j])\cdot\mu(i)$$$$when\ \varphi(i)=0,t=\text{product of every prime factor of i},f[i]=(\sum{j|t}\mu(j)\cdot a[j\cdot\frac{i}{t}])\cdot \mu(t)$$ 122.ctrl+mÔºöÊäädevÂàÜÊàêÂ∑¶Âè≥‰∏§‰∏™Á™óÂè£ 123.f[i]Ë°®Á§∫‰∫åËøõÂà∂‰∏ãÊòØiÁöÑË∂ÖÈõÜÁöÑÊï∞ÁöÑ‰∏™Êï∞ ÂÖàÊûö‰∏æÊüê‰∏Ä‰ΩçjÔºåÂÜçÊûö‰∏æiÔºà‰ªéÂ∞èÂà∞Â§ßÂíå‰ªéÂ§ßÂà∞Â∞èÈÉΩÂèØ‰ª•ÔºåÂõ†‰∏∫ÊØè‰∏Ä‰ΩçÂè™Êúâ0/1Ôºâ f[i^(1&lt;]]></content>
      <tags>
        <tag>ÊäÄÂ∑ß</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2278 [HNOI2003]Êìç‰ΩúÁ≥ªÁªü]]></title>
    <url>%2F2018%2F04%2F28%2Fluogu2278%20%5BHNOI2003%5D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[12345678Â•Ω‰πÖÊ≤°ÂÜôÈáçËΩΩ‰∫ÜlessÈúÄË¶ÅÈáçËΩΩÂ∞è‰∫éÂè∑greaterÈúÄË¶ÅÈáçËΩΩÂ§ß‰∫éÂè∑stl‰∏≠‰ΩøÁî®ÁªìÊûÑ‰Ωì‰ºö‰ΩøÊàêÂëòÂèòÈáèÂèòÊàêprivateÔºåÂØºËá¥Âè™ÂèØËÆøÈóÆÔºå‰∏çÂèØ‰øÆÊîπÊâÄ‰ª•ÊàêÂëòÂáΩÊï∞Ë¶ÅÂä†const‰ª•Âèäpriority_queueÁöÑÂ§ßÂ∞è‰∫éÂà§Êñ≠Âíåsort/setÊòØÁõ∏ÂèçÁöÑpriority_queueÔºö‰∏∫1Â∞±‰∫§Êç¢sort/setÔºö‰∏∫1‰∏ç‰∫§Êç¢ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;int id,t1,t2,a,pre;struct node&#123; int x,y,z; inline bool operator &lt; (const node &amp;a) const&#123; if(x!=a.x) return x&lt;a.x; return y&gt;a.y; &#125;&#125;;priority_queue&lt;node&gt; q;int main()&#123; while(scanf(&quot;%d&quot;,&amp;id)!=EOF)&#123; t1=read();t2=read();a=read(); if(q.empty())&#123; q.push((node)&#123;a,id,t2&#125;); pre=t1; &#125; else&#123; while(!q.empty()&amp;&amp;pre+q.top().z&lt;=t1)&#123; pre+=q.top().z; printf(&quot;%d %d\n&quot;,q.top().y,pre); q.pop(); &#125; if(!q.empty()&amp;&amp;pre&lt;t1)&#123; node t=q.top(); q.pop(); t.z-=t1-pre; q.push(t); &#125; q.push((node)&#123;a,id,t2&#125;); pre=t1; &#125; &#125; while(!q.empty())&#123; pre+=q.top().z; printf(&quot;%d %d\n&quot;,q.top().y,pre); q.pop(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Â†Ü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguP2149 [SDOI2009]ElaxiaÁöÑË∑ØÁ∫ø]]></title>
    <url>%2F2018%2F04%2F28%2FluoguP2149%20%5BSDOI2009%5DElaxia%E7%9A%84%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[1234567ÊòæÁÑ∂‰ªñ‰ª¨Âè™‰ºöÂú®‰∏ÄÊÆµËøûÁª≠ÁöÑÁÇπ‰∏äÁõ∏ÈÅáÂÖàÊ±ÇÂá∫ÊØè‰∏™ÁÇπÊòØÂê¶Âú®ÊúÄÁü≠Ë∑Ø‰∏äÁÑ∂ÂêéÊö¥ÂäõÊûö‰∏æËµ∑ÁÇπÂíåÁªàÁÇπËøôÊ†∑Â∞±a‰∫Ü‰ΩÜËøá‰∏ç‰∫Übzoj‰∏äÊèê‰æõÁöÑÈ¢ùÂ§ñ‰∏§ÁªÑÊï∞ÊçÆÂõ†‰∏∫‰∏§‰∏™ÁÇπÂú®ÊúÄÁü≠Ë∑Ø‰∏ä‰∏ç‰ª£Ë°®ÂÆÉ‰ª¨Âú®Âêå‰∏ÄÊù°ÊúÄÁü≠Ë∑Ø‰∏äËøòË¶ÅÂà§Êñ≠ÂÆÉ‰ª¨ÁöÑË∑ùÁ¶ªÂ∑ÆÊòØÂê¶Áõ∏Á≠â 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1508;int n,m;int x[3],y[3];int u,v,l;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[N*N*2];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[3][N];int q[N],he,ta;bool inq[N],ina[3][N];int ans;inline void spfa(int t)&#123; memset(inq,0,sizeof(inq)); dis[t][x[t]]=0; he=1;ta=2; q[1]=x[t]; inq[x[t]]=1; while(he!=ta)&#123; int x=q[he]; inq[x]=0; ++he; if(he==1503) he=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[t][e[i].to]&gt;dis[t][x]+e[i].f)&#123; dis[t][e[i].to]=dis[t][x]+e[i].f; if(!inq[e[i].to])&#123; q[ta]=e[i].to; inq[e[i].to]=1; ++ta; if(ta==1503) ta=1; &#125; &#125; &#125; &#125; he=1;ta=2; q[1]=y[t]; inq[y[t]]=1; while(he!=ta)&#123; int x=q[he]; ++he; ina[t][x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[t][x]-e[i].f==dis[t][e[i].to])&#123; if(!inq[e[i].to])&#123; q[ta]=e[i].to; inq[e[i].to]=1; ++ta; &#125; &#125; &#125; &#125;&#125;int main()&#123; memset(dis,0x3f,sizeof(dis)); n=read();m=read();x[1]=read();y[1]=read();x[2]=read();y[2]=read(); for(int i=1;i&lt;=m;++i)&#123; u=read();v=read();l=read(); addedge(u,v,l); addedge(v,u,l); &#125; spfa(1); spfa(2); for(int i=1;i&lt;=n;++i)&#123; if(ina[1][i]&amp;&amp;ina[2][i])&#123; for(int j=1;j&lt;=n;++j)&#123; if(i!=j&amp;&amp;ina[1][j]&amp;&amp;ina[2][j]&amp;&amp;abs(dis[1][i]-dis[1][j])==abs(dis[2][i]-dis[2][j]))&#123; ans=max(ans,abs(dis[1][i]-dis[1][j])); &#125; &#125; &#125; &#125; printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>ÊúÄÁü≠Ë∑Ø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1345 [USACO5.4]Â•∂ÁâõÁöÑÁîµ‰ø°Telecowmunication]]></title>
    <url>%2F2018%2F04%2F28%2Fluogu1345%20%5BUSACO5.4%5D%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1Telecowmunication%2F</url>
    <content type="text"><![CDATA[12345678910111213Áúã‰∏äÂéªÂÉèÁΩëÁªúÊµÅÂÜô‰∫Ü‰∏ÄÂèë80ÂàÜËøò‰ª•‰∏∫Â∞èÁªÜËäÇÊåÇ‰∫ÜÂÖ∂ÂÆûÊï¥‰∏™Á®ãÂ∫èÈÉΩÊòØÈîôÁöÑ„ÄÇ„ÄÇÊòØÊ±ÇÊúÄÂ∞èÁöÑÂâ≤ÁÇπÊï∞ËΩ¨ÂåñÊàêÊ±ÇÊúÄÂ∞èÁöÑÂâ≤ËæπÊï∞ÔºàÊúÄÂ∞èÂâ≤ÔºâÊØè‰∏™ÁÇπÊãÜÊàê‰∏§‰∏™ÁÇπi - 1 - i&apos;ÂéüÂõæ‰∏≠ÁöÑËæπËøûINFËøôÊ†∑Âè™‰ºöÂâ≤Êéâ1ÁöÑËæπÁõ∏ÂΩì‰∫éÂâ≤Êéâ‰∫ÜËøô‰∏™ÁÇπ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108,M=608;int n,m,s,t;int x,y;int nume=1,head[N*2],cur[N*2];struct node&#123; int to,nxt,f;&#125;e[M*4+N*2];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;int dis[N*2];int q[N*2],he,ta;inline bool bfs()&#123; memset(dis,0,sizeof(dis)); dis[s]=1; he=1;ta=2; q[1]=s; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=1;i&lt;=n*2;++i) cur[i]=head[i]; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int main()&#123; n=read();m=read();s=read();t=read(); s+=n; for(int i=1;i&lt;=n;++i)&#123; if(i!=s-n&amp;&amp;i!=t)&#123; addedge(i,n+i,1); &#125; &#125; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read(); addedge(x+n,y,INT_MAX); addedge(y+n,x,INT_MAX); &#125; printf(&quot;%d&quot;,dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>ÁΩëÁªúÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1993 Â∞èKÁöÑÂÜúÂú∫]]></title>
    <url>%2F2018%2F04%2F27%2Fluogu1993%20%E5%B0%8FK%E7%9A%84%E5%86%9C%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617‰∏ÄÁúºÂ∑ÆÂàÜÁ∫¶ÊùüÔºå‰∏ÄÁúºÊï∞ÊçÆ1e4‰∏ÄÁúãÈ¢òËß£ÔºåÂÖ®ÂÜôÁöÑÊòØspfa_dfsÔºÅÔºüspfaËøòËÉΩÁî®dfsÔºüÂêìÂæóÊàëËµ∂Á¥ßÂéªË¥üÁéØÁöÑÊ®°ÊùøÈ¢òÁúãÈ¢òËß£‰πüÊòØdfsÔºü‰∏çËøáÈ´òÁ∫ßÁöÑÁÆ°ÁêÜÂëòÊîπ‰∫ÜÊï∞ÊçÆÊääÂ§çÊùÇÂ∫¶Ê≤°Êúâ‰øùËØÅÁöÑdfsÂÖ®ÈÉ®hack‰∫ÜÂè™ËÉΩÊÑâÂø´ÁöÑÂÜôbfsÂï¶Áõ¥Êé•ÂÜôÁöÑËØù‰ºötÊñ∞ÊäÄËÉΩÔºö‰øùÂ≠òÊØè‰∏™ÁÇπÁöÑÊúÄÁü≠Ë∑ØÂæÑÈïøÂ∫¶Ôºå&gt;nËØ¥ÊòéÂá∫Áé∞Ë¥üÁéØËøôÊ†∑ÂÜôÂºÄO2ÊâçËÉΩaÊéâ‰ΩÜÊòØÊï∞ÊçÆÂ§™Âº±&gt;15Â∞±ËÆ§‰∏∫Âá∫Áé∞Ë¥üÁéØËøôÊ†∑Â∞±0msËøá‰∫ÜÈ°∫‰æøÂÅö‰∫Ü‰∏Ä‰∏ãË¥üÁéØÁöÑÊ®°ÊùøÈ¢òÂèëÁé∞ËÆ∞ÂΩïË∑ØÂæÑÈïøÂ∫¶ÊØîËÆ∞ÂΩïËøõÈòüÊ¨°Êï∞ÊÖ¢„ÄÇ„ÄÇ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=10008;int n,m,t;int x,y,z;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[N];int q[N],he,ta;bool inq[N];int tim[N];inline bool spfa()&#123; for(int i=1;i&lt;=n;++i)&#123; q[i]=i; inq[i]=1; tim[i]=1; &#125; he=1;ta=n+1; while(he!=ta)&#123; int x=q[he]; inq[x]=0; ++he; if(he==10003) he=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; //++tim[e[i].to]; //if(tim[e[i].to]&gt;n) return 0; tim[e[i].to]=tim[x]+1; if(tim[e[i].to]&gt;n)&#123;//&gt;15‰πüÂèØ‰ª•Ôºå0ms return 0; &#125; if(!inq[e[i].to])&#123; q[ta]=e[i].to; inq[e[i].to]=1; ++ta; if(ta==10003) ta=1; &#125; &#125; &#125; &#125; return 1;&#125;int main()&#123; n=read();m=read(); while(m--)&#123; t=read(); if(t==1)&#123; x=read();y=read();z=read(); addedge(x,y,-z); &#125; else if(t==2)&#123; x=read();y=read();z=read(); addedge(y,x,z); &#125; else&#123; x=read();y=read(); addedge(x,y,0); addedge(y,x,0); &#125; &#125; if(spfa())&#123; puts(&quot;Yes&quot;); &#125; else&#123; puts(&quot;No&quot;); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=4008,M=6008;int T;int n,m;int x,y,z;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[M&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[N],q[N],he,ta,tim[N];bool inq[N];inline void spfa()&#123; for(int i=1;i&lt;=n;++i)&#123; dis[i]=0; inq[i]=1; q[i]=i; tim[i]=1; &#125; he=1;ta=n+1;//ÈòüÂàóÁöÑtaË¶Å+1 while(he!=ta)&#123; int x=q[he]; inq[x]=0; ++he; if(he==4003) he=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; ++tim[e[i].to]; /*if(tim[e[i].to]&gt;n)&#123; puts(&quot;YE5&quot;); return; &#125;*/ tim[e[i].to]=tim[x]+1; if(tim[e[i].to]&gt;min(2500,n))&#123; puts(&quot;YE5&quot;); return; &#125; if(!inq[e[i].to])&#123; q[ta]=e[i].to; inq[e[i].to]=1; ++ta; if(ta==4003) ta=1; &#125; &#125; &#125; &#125; puts(&quot;N0&quot;); return;&#125;int main()&#123; T=read(); while(T--)&#123; nume=0; memset(head,0,sizeof(head)); n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); if(z&gt;=0)&#123; addedge(y,x,z); &#125; &#125; spfa(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Â∑ÆÂàÜÁ∫¶Êùü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1268 Ê†ëÁöÑÈáçÈáè]]></title>
    <url>%2F2018%2F04%2F25%2Fluogu1268%20%E6%A0%91%E7%9A%84%E9%87%8D%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617Â•ΩÈ¢òÂïäÁúã‰∫ÜÂçäÂ§©‰∏ç‰ºöÂéªÁúãÈ¢òËß£Â¶ôÂïäËøòÊòØ‰∏çÊòéÁôΩÈáçÁÇπÂ∞±ÊòØ‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πàÊ†ëÁöÑÈáçÈáèÊòØ‰∏ÄÂÆöÁöÑËÄåÂÅöÊ≥ïÂ∞±Áõ∏ÂΩì‰∫éËØÅÊòé‰∏ÄÊ†∑ÊØèÂä†‰∏äÂéª‰∏Ä‰∏™ÁÇπÔºåÁõ∏ÂΩì‰∫é‰ªé‰∏ÄÂØπÁÇπÁöÑË∑ØÂæÑ‰∏ä‰º∏Âá∫Êù•‰∏ÄÊù°ËæπÁúãÈ¢òËß£Êó∂ÂèëÁé∞‰∏Ä‰∏™ÊúâË∂£ÁöÑÁªìËÆ∫Ê†πÊçÆ‰∏§‰∏§ÁÇπ‰πãÈó¥ÁöÑÊúÄÁü≠Ë∑ùÁ¶ªÂª∫Âá∫ÁöÑÊ†ëÂ∫îËØ•ÈÉΩÊòØÂêåÊûÑÁöÑÔºàËæπÊùÉÂùáÈùûË¥üÔºâÁÑ∂ËÄåÂ∫îËØ•‰∏çÊòØÂêåÊûÑÊØèÊ¨°ÈÄâÊúÄÂ∞èÁöÑÂÄºw(i,j)Ëã•Â≠òÂú®kÔºå‰ΩøÂæów(i,k)+w(k,j)=w(i,j)ÔºåÂàôi,j‰πãÈó¥‰∏çÈúÄË¶ÅËøûËæπÂê¶ÂàôÂ∞±ËøûËæπËøôÊ†∑Â∫îËØ•ÂèØ‰ª•Á°ÆÂÆö‰∏Ä‰∏™ËæπÊï∞ÊúÄÂ∞ëÁöÑÂõæÂú®Ëøô‰∏™Âõæ‰∏äÂ°´‰∏ÄÂÜôËæÉÂ§ßÁöÑËæπÔºàÂ§ß‰∫é‰∏§Á´ØÁÇπÁöÑÊúÄÁü≠Ë∑ùÁ¶ªÔºâ‰∏ç‰ºö‰∫ßÁîü‰ªª‰ΩïÂΩ±Âìç 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=38;int n;int a[N][N];int ans,tmp;int main()&#123; while(1)&#123; n=read(); if(!n) return 0; memset(a,0,sizeof(a)); for(int i=1;i&lt;n;++i)&#123; for(int j=i+1;j&lt;=n;++j)&#123; a[i][j]=read(); a[j][i]=a[i][j]; &#125; &#125; ans=a[1][2]; for(int i=3;i&lt;=n;++i)&#123; tmp=INT_MAX; for(int j=1;j&lt;i;++j)&#123; for(int k=j+1;k&lt;i;++k)&#123; tmp=min(tmp,(a[j][i]+a[k][i]-a[j][k])/2); &#125; &#125; ans+=tmp; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ÊÄùÁª¥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂçÅÂπ¥Á£®‰∏ÄÂâë]]></title>
    <url>%2F2018%2F04%2F23%2F%E5%85%BB%E6%B0%94%2F</url>
    <content type="text"><![CDATA[18/4/23ÂºÄÂßã|Â∫èÂè∑|Ë¥®Êï∞|Âπ≥ÊñπÊï∞|Á´ãÊñπÊï∞||:-:|:-:|:-:|:-:|| 1| 2| 1| 1|| 2| 3| 4| 8|| 3| 5| 9| 27|| 4| 7| 16| 64|| 5| 11| 25| 125|| 6| 13| 36| 216|| 7| 17| 49| 343|| 8| 19| 64| 512|| 9| 23| 81| 729|| 10| 29| 100| 1000|| 11| 31| 121| 1331|| 12| 37| 144| 1728|| 13| 41| 169| 2197|| 14| 43| 196| 2744|| 15| 47| 225| 3375|| 16| 53| 256| 4096|| 17| 59| 289| 4913|| 18| 61| 324| 5832|| 19| 67| 361| 6859|| 20| 71| 400| 8000|| 21| 73| 441| 9261|| 22| 79| 484| 10648|| 23| 83| 529| 12167|| 24| 89| 576| 13824|| 25| 93| 625| 15625|| 26| 101| 676| 17576|| 27| 103| 729| 19683|| 28| 107| 784| 21952|| 29| 109| 841| 24389|| 30| 113| 900| 27000|| 31| 127| 961| 29791|| 32| 131| 1024| 32768|| 33| 137| 1089| 35937|| 34| 139| 1156| 39304|| 35| 149| 1225| 42875|| 36| 151| 1296| 46656|| 37| 157| 1369| 50653|| 38| 163| 1444| 54872|| 39| 167| 1521| 59319|| 40| 173| 1600| 64000|| 41| 179| 1681| 68921|| 42| 181| 1764| 74088|| 43| 191| 1849| 79507|| 44| 197| 1936| 85184|| 45| 197| 2025| 91125|| 46| 199| 2116| 97336|| 47| 211| 2209| 103823|| 48| 223| 2304| 110592|| 49| 227| 2401| 117649|| 50| 229| 2500| 125000|| 51| 233| 2601| 132651|| 52| 239| 2704| 140608|| 53| 241| 2809| 148877|| 54| 251| 2916| 157464|| 55| 257| 3025| 166375|¬∑Êàí ¬∑Áà± ¬∑Êéß ¬∑‰∏ª|Â∫èÂè∑|Ë¥®Êï∞|Âπ≥ÊñπÊï∞|Á´ãÊñπÊï∞||:-:|:-:|:-:|:-:|| 56| 263| 3136| 175616|| 57| 269| 3249| 185193|| 58| 271| 3364| 195112|| 59| 277| 3481| 205379|| 60| 281| 3600| 216000|| 61| 283| 3721| 226981|| 62| 293| 3844| 238328|ÁÅ´ÁÆ≠ÂèëÂ∞ÑÔºÅÔºÅ|Â∫èÂè∑|Ë¥®Êï∞|Âπ≥ÊñπÊï∞|Á´ãÊñπÊï∞||:-:|:-:|:-:|:-:|| 63| 307| 3969| 250047|| 64| 311| 4096| 262144|| 65| 313| 4225| 274625|| 66| 317| 4356| 287496|| 67| 331| 4489| 300763|| 68| 337| 4624| 314432|| 69| 347| 4761| 328509|| 70| 349| 4900| 343000|| 71| 353| 5041| 357911|| 72| 359| 5184| 373248|| 73| 367| 5329| 389017|| 74| 373| 5476| 405224|| 75| 379| 5625| 421875|| 76| 383| 5776| 438976|| 77| 389| 5929| 456533|| 78| 397| 6084| 474552|| 79| 401| 6241| 493039|| 80| 409| 6400| 512000|| 81| 419| 6561| 531441|| 82| 421| 6724| 551368|| 83| 431| 6889| 571787|| 84| 433| 7056| 592704|| 85| 439| 7225| 614125|| 86| 443| 7396| 636056|| 87| 449| 7569| 658503|| 88| 457| 7744| 681472|| 89| | | || 90| | | || 91| | | || 92| | | || 93| | | || 94| | | || 95| | | || 96| | | || 97| | | || 98| | | || 99| | | || 100| | | || 101| | | || 102| | | || 103| | | || 104| | | || 105| | | || 106| | | || 107| | | || 108| | | || 109| | | || 110| | | || 111| | | || 112| | | || 113| | | || 114| | | || 115| | | || 116| | | || 117| | | || 118| | | || 119| | | || 120| | | || 121| | | || 122| | | || 123| | | || 124| | | || 125| | | || 126| | | || 127| | | || 128| | | || 129| | | || 130| | | || 131| | | || 132| | | || 133| | | || 134| | | || 135| | | || 136| | | || 137| | | || 138| | | || 139| | | || 140| | | || 141| | | || 142| | | || 143| | | || 144| | | || 145| | | || 146| | | || 147| | | || 148| | | || 149| | | || 150| | | || 151| | | || 152| | | || 153| | | || 154| | | || 155| | | || 156| | | || 157| | | || 158| | | || 159| | | || 160| | | || 161| | | || 162| | | || 163| | | || 164| | | || 165| | | || 166| | | || 167| | | || 168| | | || 169| | | || 170| | | || 171| | | || 172| | | || 173| | | || 174| | | || 175| | | || 176| | | || 177| | | || 178| | | || 179| | | || 180| | | || 181| | | || 182| | | || 183| | | || 184| | | || 185| | | || 186| | | || 187| | | || 188| | | || 189| | | || 190| | | || 191| | | || 192| | | || 193| | | || 194| | | || 195| | | || 196| | | || 197| | | || 198| | | || 199| | | || 200| | | || 201| | | || 202| | | || 203| | | || 204| | | || 205| | | || 206| | | || 207| | | || 208| | | || 209| | | || 210| | | || 211| | | || 212| | | || 213| | | || 214| | | || 215| | | || 216| | | || 217| | | || 218| | | || 219| | | || 220| | | || 221| | | || 222| | | || 223| | | || 224| | | || 225| | | || 226| | | || 227| | | || 228| | | || 229| | | || 230| | | || 231| | | || 232| | | || 233| | | || 234| | | || 235| | | || 236| | | || 237| | | || 238| | | || 239| | | || 240| | | || 241| | | || 242| | | || 243| | | || 244| | | || 245| | | || 246| | | || 247| | | || 248| | | || 249| | | || 250| | | || 251| | | || 252| | | || 253| | | || 254| | | || 255| | | || 256| | | || 257| | | || 258| | | || 259| | | || 260| | | || 261| | | || 262| | | || 263| | | || 264| | | || 265| | | || 266| | | || 267| | | || 268| | | || 269| | | || 270| | | || 271| | | || 272| | | || 273| | | || 274| | | || 275| | | || 276| | | || 277| | | || 278| | | || 279| | | || 280| | | || 281| | | || 282| | | || 283| | | || 284| | | || 285| | | || 286| | | || 287| | | || 288| | | || 289| | | || 290| | | || 291| | | || 292| | | || 293| | | || 294| | | || 295| | | || 296| | | || 297| | | || 298| | | || 299| | | || 300| | | || 301| | | || 302| | | || 303| | | || 304| | | || 305| | | || 306| | | || 307| | | || 308| | | || 309| | | || 310| | | || 311| | | || 312| | | || 313| | | || 314| | | || 315| | | || 316| | | || 317| | | || 318| | | || 319| | | || 320| | | || 321| | | || 322| | | || 323| | | || 324| | | || 325| | | || 326| | | || 327| | | || 328| | | || 329| | | || 330| | | || 331| | | || 332| | | || 333| | | || 334| | | || 335| | | || 336| | | || 337| | | || 338| | | || 339| | | || 340| | | || 341| | | || 342| | | || 343| | | || 344| | | || 345| | | || 346| | | || 347| | | || 348| | | || 349| | | || 350| | | || 351| | | || 352| | | || 353| | | || 354| | | || 355| | | || 356| | | || 357| | | || 358| | | || 359| | | || 360| | | || 361| | | || 362| | | || 363| | | || 364| | | || 365| | | || 366| | | || 367| | | || 368| | | || 369| | | || 370| | | || 371| | | || 372| | | || 373| | | || 374| | | || 375| | | || 376| | | || 377| | | || 378| | | || 379| | | || 380| | | || 381| | | || 382| | | || 383| | | || 384| | | || 385| | | || 386| | | || 387| | | || 388| | | || 389| | | || 390| | | || 391| | | || 392| | | || 393| | | || 394| | | || 395| | | || 396| | | || 397| | | || 398| | | || 399| | | || 400| | | || 401| | | || 402| | | || 403| | | || 404| | | || 405| | | || 406| | | || 407| | | || 408| | | || 409| | | || 410| | | || 411| | | || 412| | | || 413| | | || 414| | | || 415| | | || 416| | | || 417| | | || 418| | | || 419| | | || 420| | | || 421| | | || 422| | | || 423| | | || 424| | | || 425| | | || 426| | | || 427| | | || 428| | | || 429| | | || 430| | | || 431| | | || 432| | | || 433| | | || 434| | | || 435| | | || 436| | | || 437| | | || 438| | | || 439| | | || 440| | | || 441| | | || 442| | | || 443| | | || 444| | | || 445| | | || 446| | | || 447| | | || 448| | | || 449| | | || 450| | | || 451| | | || 452| | | || 453| | | || 454| | | || 455| | | || 456| | | || 457| | | || 458| | | || 459| | | || 460| | | || 461| | | || 462| | | || 463| | | || 464| | | || 465| | | || 466| | | || 467| | | || 468| | | || 469| | | || 470| | | || 471| | | || 472| | | || 473| | | || 474| | | || 475| | | || 476| | | || 477| | | || 478| | | || 479| | | || 480| | | || 481| | | || 482| | | || 483| | | || 484| | | || 485| | | || 486| | | || 487| | | || 488| | | || 489| | | || 490| | | || 491| | | || 492| | | || 493| | | || 494| | | || 495| | | || 496| | | || 497| | | || 498| | | || 499| | | || 500| | | || 501| | | || 502| | | || 503| | | || 504| | | || 505| | | || 506| | | || 507| | | || 508| | | || 509| | | || 510| | | || 511| | | || 512| | | || 513| | | || 514| | | || 515| | | || 516| | | || 517| | | || 518| | | || 519| | | || 520| | | || 521| | | || 522| | | || 523| | | || 524| | | || 525| | | || 526| | | || 527| | | || 528| | | || 529| | | || 530| | | || 531| | | || 532| | | || 533| | | || 534| | | || 535| | | || 536| | | || 537| | | || 538| | | || 539| | | || 540| | | || 541| | | || 542| | | || 543| | | || 544| | | || 545| | | || 546| | | || 547| | | || 548| | | || 549| | | || 550| | | || 551| | | || 552| | | || 553| | | || 554| | | || 555| | | || 556| | | || 557| | | || 558| | | || 559| | | || 560| | | || 561| | | || 562| | | || 563| | | || 564| | | || 565| | | || 566| | | || 567| | | || 568| | | || 569| | | || 570| | | || 571| | | || 572| | | || 573| | | || 574| | | || 575| | | || 576| | | || 577| | | || 578| | | || 579| | | || 580| | | || 581| | | || 582| | | || 583| | | || 584| | | || 585| | | || 586| | | || 587| | | || 588| | | || 589| | | || 590| | | || 591| | | || 592| | | || 593| | | || 594| | | || 595| | | || 596| | | || 597| | | || 598| | | || 599| | | || 600| | | || 601| | | || 602| | | || 603| | | || 604| | | || 605| | | || 606| | | || 607| | | || 608| | | || 609| | | || 610| | | || 611| | | || 612| | | || 613| | | || 614| | | || 615| | | || 616| | | || 617| | | || 618| | | || 619| | | || 620| | | || 621| | | || 622| | | || 623| | | || 624| | | || 625| | | || 626| | | || 627| | | || 628| | | || 629| | | || 630| | | || 631| | | || 632| | | || 633| | | || 634| | | || 635| | | || 636| | | || 637| | | || 638| | | || 639| | | || 640| | | || 641| | | || 642| | | || 643| | | || 644| | | || 645| | | || 646| | | || 647| | | || 648| | | || 649| | | || 650| | | || 651| | | || 652| | | || 653| | | || 654| | | || 655| | | || 656| | | || 657| | | || 658| | | || 659| | | || 660| | | || 661| | | || 662| | | || 663| | | || 664| | | || 665| | | || 666| | | || 667| | | || 668| | | || 669| | | || 670| | | || 671| | | || 672| | | || 673| | | || 674| | | || 675| | | || 676| | | || 677| | | || 678| | | || 679| | | || 680| | | || 681| | | || 682| | | || 683| | | || 684| | | || 685| | | || 686| | | || 687| | | || 688| | | || 689| | | || 690| | | || 691| | | || 692| | | || 693| | | || 694| | | || 695| | | || 696| | | || 697| | | || 698| | | || 699| | | || 700| | | || 701| | | || 702| | | || 703| | | || 704| | | || 705| | | || 706| | | || 707| | | || 708| | | || 709| | | || 710| | | || 711| | | || 712| | | || 713| | | || 714| | | || 715| | | || 716| | | || 717| | | || 718| | | || 719| | | || 720| | | || 721| | | || 722| | | || 723| | | || 724| | | || 725| | | || 726| | | || 727| | | || 728| | | || 729| | | || 730| | | || 731| | | || 732| | | || 733| | | || 734| | | || 735| | | || 736| | | || 737| | | || 738| | | || 739| | | || 740| | | || 741| | | || 742| | | || 743| | | || 744| | | || 745| | | || 746| | | || 747| | | || 748| | | || 749| | | || 750| | | || 751| | | || 752| | | || 753| | | || 754| | | || 755| | | || 756| | | || 757| | | || 758| | | || 759| | | || 760| | | || 761| | | || 762| | | || 763| | | || 764| | | || 765| | | || 766| | | || 767| | | || 768| | | || 769| | | || 770| | | || 771| | | || 772| | | || 773| | | || 774| | | || 775| | | || 776| | | || 777| | | || 778| | | || 779| | | || 780| | | || 781| | | || 782| | | || 783| | | || 784| | | || 785| | | || 786| | | || 787| | | || 788| | | || 789| | | || 790| | | || 791| | | || 792| | | || 793| | | || 794| | | || 795| | | || 796| | | || 797| | | || 798| | | || 799| | | || 800| | | || 801| | | || 802| | | || 803| | | || 804| | | || 805| | | || 806| | | || 807| | | || 808| | | || 809| | | || 810| | | || 811| | | || 812| | | || 813| | | || 814| | | || 815| | | || 816| | | || 817| | | || 818| | | || 819| | | || 820| | | || 821| | | || 822| | | || 823| | | || 824| | | || 825| | | || 826| | | || 827| | | || 828| | | || 829| | | || 830| | | || 831| | | || 832| | | || 833| | | || 834| | | || 835| | | || 836| | | || 837| | | || 838| | | || 839| | | || 840| | | || 841| | | || 842| | | || 843| | | || 844| | | || 845| | | || 846| | | || 847| | | || 848| | | || 849| | | || 850| | | || 851| | | || 852| | | || 853| | | || 854| | | || 855| | | || 856| | | || 857| | | || 858| | | || 859| | | || 860| | | || 861| | | || 862| | | || 863| | | || 864| | | || 865| | | || 866| | | || 867| | | || 868| | | || 869| | | || 870| | | || 871| | | || 872| | | || 873| | | || 874| | | || 875| | | || 876| | | || 877| | | || 878| | | || 879| | | || 880| | | || 881| | | || 882| | | || 883| | | || 884| | | || 885| | | || 886| | | || 887| | | || 888| | | || 889| | | || 890| | | || 891| | | || 892| | | || 893| | | || 894| | | || 895| | | || 896| | | || 897| | | || 898| | | || 899| | | || 900| | | || 901| | | || 902| | | || 903| | | || 904| | | || 905| | | || 906| | | || 907| | | || 908| | | || 909| | | || 910| | | || 911| | | || 912| | | || 913| | | || 914| | | || 915| | | || 916| | | || 917| | | || 918| | | || 919| | | || 920| | | || 921| | | || 922| | | || 923| | | || 924| | | || 925| | | || 926| | | || 927| | | || 928| | | || 929| | | || 930| | | || 931| | | || 932| | | || 933| | | || 934| | | || 935| | | || 936| | | || 937| | | || 938| | | || 939| | | || 940| | | || 941| | | || 942| | | || 943| | | || 944| | | || 945| | | || 946| | | || 947| | | || 948| | | || 949| | | || 950| | | || 951| | | || 952| | | || 953| | | || 954| | | || 955| | | || 956| | | || 957| | | || 958| | | || 959| | | || 960| | | || 961| | | || 962| | | || 963| | | || 964| | | || 965| | | || 966| | | || 967| | | || 968| | | || 969| | | || 970| | | || 971| | | || 972| | | || 973| | | || 974| | | || 975| | | || 976| | | || 977| | | || 978| | | || 979| | | || 980| | | || 981| | | || 982| | | || 983| | | || 984| | | || 985| | | || 986| | | || 987| | | || 988| | | || 989| | | || 990| | | || 991| | | || 992| | | || 993| | | || 994| | | || 995| | | || 996| | | || 997| | | || 998| | | || 999| | | || 1000| | | || 1001| | | || 1002| | | || 1003| | | || 1004| | | || 1005| | | || 1006| | | || 1007| | | || 1008| | | || 1009| | | || 1010| | | || 1011| | | || 1012| | | || 1013| | | || 1014| | | || 1015| | | || 1016| | | || 1017| | | || 1018| | | || 1019| | | || 1020| | | || 1021| | | || 1022| | | || 1023| | | || 1024| | | || 1025| | | || 1026| | | || 1027| | | || 1028| | | || 1029| | | || 1030| | | || 1031| | | || 1032| | | || 1033| | | || 1034| | | || 1035| | | || 1036| | | || 1037| | | || 1038| | | || 1039| | | || 1040| | | || 1041| | | || 1042| | | || 1043| | | || 1044| | | || 1045| | | || 1046| | | || 1047| | | || 1048| | | || 1049| | | || 1050| | | || 1051| | | || 1052| | | || 1053| | | || 1054| | | || 1055| | | || 1056| | | || 1057| | | || 1058| | | || 1059| | | || 1060| | | || 1061| | | || 1062| | | || 1063| | | || 1064| | | || 1065| | | || 1066| | | || 1067| | | || 1068| | | || 1069| | | || 1070| | | || 1071| | | || 1072| | | || 1073| | | || 1074| | | || 1075| | | || 1076| | | || 1077| | | || 1078| | | || 1079| | | || 1080| | | || 1081| | | || 1082| | | || 1083| | | || 1084| | | || 1085| | | || 1086| | | || 1087| | | || 1088| | | || 1089| | | || 1090| | | || 1091| | | || 1092| | | || 1093| | | || 1094| | | || 1095| | | || 1096| | | || 1097| | | || 1098| | | || 1099| | | || 1100| | | || 1101| | | || 1102| | | || 1103| | | || 1104| | | || 1105| | | || 1106| | | || 1107| | | || 1108| | | || 1109| | | || 1110| | | || 1111| | | || 1112| | | || 1113| | | || 1114| | | || 1115| | | || 1116| | | || 1117| | | || 1118| | | || 1119| | | || 1120| | | || 1121| | | || 1122| | | || 1123| | | || 1124| | | || 1125| | | || 1126| | | || 1127| | | || 1128| | | || 1129| | | || 1130| | | || 1131| | | || 1132| | | || 1133| | | || 1134| | | || 1135| | | || 1136| | | || 1137| | | || 1138| | | || 1139| | | || 1140| | | || 1141| | | || 1142| | | || 1143| | | || 1144| | | || 1145| | | || 1146| | | || 1147| | | || 1148| | | || 1149| | | || 1150| | | || 1151| | | || 1152| | | || 1153| | | || 1154| | | || 1155| | | || 1156| | | || 1157| | | || 1158| | | || 1159| | | || 1160| | | || 1161| | | || 1162| | | || 1163| | | || 1164| | | || 1165| | | || 1166| | | || 1167| | | || 1168| | | || 1169| | | || 1170| | | || 1171| | | || 1172| | | || 1173| | | || 1174| | | || 1175| | | || 1176| | | || 1177| | | || 1178| | | || 1179| | | || 1180| | | || 1181| | | || 1182| | | || 1183| | | || 1184| | | || 1185| | | || 1186| | | || 1187| | | || 1188| | | || 1189| | | || 1190| | | || 1191| | | || 1192| | | || 1193| | | || 1194| | | || 1195| | | || 1196| | | || 1197| | | || 1198| | | || 1199| | | || 1200| | | || 1201| | | || 1202| | | || 1203| | | || 1204| | | || 1205| | | || 1206| | | || 1207| | | || 1208| | | || 1209| | | || 1210| | | || 1211| | | || 1212| | | || 1213| | | || 1214| | | || 1215| | | || 1216| | | || 1217| | | || 1218| | | || 1219| | | || 1220| | | || 1221| | | || 1222| | | || 1223| | | || 1224| | | || 1225| | | || 1226| | | || 1227| | | || 1228| | | || 1229| | | || 1230| | | || 1231| | | || 1232| | | || 1233| | | || 1234| | | || 1235| | | || 1236| | | || 1237| | | || 1238| | | || 1239| | | || 1240| | | || 1241| | | || 1242| | | || 1243| | | || 1244| | | || 1245| | | || 1246| | | || 1247| | | || 1248| | | || 1249| | | || 1250| | | || 1251| | | || 1252| | | || 1253| | | || 1254| | | || 1255| | | || 1256| | | || 1257| | | || 1258| | | || 1259| | | || 1260| | | || 1261| | | || 1262| | | || 1263| | | || 1264| | | || 1265| | | || 1266| | | || 1267| | | || 1268| | | || 1269| | | || 1270| | | || 1271| | | || 1272| | | || 1273| | | || 1274| | | || 1275| | | || 1276| | | || 1277| | | || 1278| | | || 1279| | | || 1280| | | || 1281| | | || 1282| | | || 1283| | | || 1284| | | || 1285| | | || 1286| | | || 1287| | | || 1288| | | || 1289| | | || 1290| | | || 1291| | | || 1292| | | || 1293| | | || 1294| | | || 1295| | | || 1296| | | || 1297| | | || 1298| | | || 1299| | | || 1300| | | || 1301| | | || 1302| | | || 1303| | | || 1304| | | || 1305| | | || 1306| | | || 1307| | | || 1308| | | || 1309| | | || 1310| | | || 1311| | | || 1312| | | || 1313| | | || 1314| | | || 1315| | | || 1316| | | || 1317| | | || 1318| | | || 1319| | | || 1320| | | || 1321| | | || 1322| | | || 1323| | | || 1324| | | || 1325| | | || 1326| | | || 1327| | | || 1328| | | || 1329| | | || 1330| | | || 1331| | | || 1332| | | || 1333| | | || 1334| | | || 1335| | | || 1336| | | || 1337| | | || 1338| | | || 1339| | | || 1340| | | || 1341| | | || 1342| | | || 1343| | | || 1344| | | || 1345| | | || 1346| | | || 1347| | | || 1348| | | || 1349| | | || 1350| | | || 1351| | | || 1352| | | || 1353| | | || 1354| | | || 1355| | | || 1356| | | || 1357| | | || 1358| | | || 1359| | | || 1360| | | || 1361| | | || 1362| | | || 1363| | | || 1364| | | || 1365| | | || 1366| | | || 1367| | | || 1368| | | || 1369| | | || 1370| | | || 1371| | | || 1372| | | || 1373| | | || 1374| | | || 1375| | | || 1376| | | || 1377| | | || 1378| | | || 1379| | | || 1380| | | || 1381| | | || 1382| | | || 1383| | | || 1384| | | || 1385| | | || 1386| | | || 1387| | | || 1388| | | || 1389| | | || 1390| | | || 1391| | | || 1392| | | || 1393| | | || 1394| | | || 1395| | | || 1396| | | || 1397| | | || 1398| | | || 1399| | | || 1400| | | || 1401| | | || 1402| | | || 1403| | | || 1404| | | || 1405| | | || 1406| | | || 1407| | | || 1408| | | || 1409| | | || 1410| | | || 1411| | | || 1412| | | || 1413| | | || 1414| | | || 1415| | | || 1416| | | || 1417| | | || 1418| | | || 1419| | | || 1420| | | || 1421| | | || 1422| | | || 1423| | | || 1424| | | || 1425| | | || 1426| | | || 1427| | | || 1428| | | || 1429| | | || 1430| | | || 1431| | | || 1432| | | || 1433| | | || 1434| | | || 1435| | | || 1436| | | || 1437| | | || 1438| | | || 1439| | | || 1440| | | || 1441| | | || 1442| | | || 1443| | | || 1444| | | || 1445| | | || 1446| | | || 1447| | | || 1448| | | || 1449| | | || 1450| | | || 1451| | | || 1452| | | || 1453| | | || 1454| | | || 1455| | | || 1456| | | || 1457| | | || 1458| | | || 1459| | | || 1460| | | || 1461| | | || 1462| | | || 1463| | | || 1464| | | || 1465| | | || 1466| | | || 1467| | | || 1468| | | || 1469| | | || 1470| | | || 1471| | | || 1472| | | || 1473| | | || 1474| | | || 1475| | | || 1476| | | || 1477| | | || 1478| | | || 1479| | | || 1480| | | || 1481| | | || 1482| | | || 1483| | | || 1484| | | || 1485| | | || 1486| | | || 1487| | | || 1488| | | || 1489| | | || 1490| | | || 1491| | | || 1492| | | || 1493| | | || 1494| | | || 1495| | | || 1496| | | || 1497| | | || 1498| | | || 1499| | | || 1500| | | || 1501| | | || 1502| | | || 1503| | | || 1504| | | || 1505| | | || 1506| | | || 1507| | | || 1508| | | || 1509| | | || 1510| | | || 1511| | | || 1512| | | || 1513| | | || 1514| | | || 1515| | | || 1516| | | || 1517| | | || 1518| | | || 1519| | | || 1520| | | || 1521| | | || 1522| | | || 1523| | | || 1524| | | || 1525| | | || 1526| | | || 1527| | | || 1528| | | || 1529| | | || 1530| | | || 1531| | | || 1532| | | || 1533| | | || 1534| | | || 1535| | | || 1536| | | || 1537| | | || 1538| | | || 1539| | | || 1540| | | || 1541| | | || 1542| | | || 1543| | | || 1544| | | || 1545| | | || 1546| | | || 1547| | | || 1548| | | || 1549| | | || 1550| | | || 1551| | | || 1552| | | || 1553| | | || 1554| | | || 1555| | | || 1556| | | || 1557| | | || 1558| | | || 1559| | | || 1560| | | || 1561| | | || 1562| | | || 1563| | | || 1564| | | || 1565| | | || 1566| | | || 1567| | | || 1568| | | || 1569| | | || 1570| | | || 1571| | | || 1572| | | || 1573| | | || 1574| | | || 1575| | | || 1576| | | || 1577| | | || 1578| | | || 1579| | | || 1580| | | || 1581| | | || 1582| | | || 1583| | | || 1584| | | || 1585| | | || 1586| | | || 1587| | | || 1588| | | || 1589| | | || 1590| | | || 1591| | | || 1592| | | || 1593| | | || 1594| | | || 1595| | | || 1596| | | || 1597| | | || 1598| | | || 1599| | | || 1600| | | || 1601| | | || 1602| | | || 1603| | | || 1604| | | || 1605| | | || 1606| | | || 1607| | | || 1608| | | || 1609| | | || 1610| | | || 1611| | | || 1612| | | || 1613| | | || 1614| | | || 1615| | | || 1616| | | || 1617| | | || 1618| | | || 1619| | | || 1620| | | || 1621| | | || 1622| | | || 1623| | | || 1624| | | || 1625| | | || 1626| | | || 1627| | | || 1628| | | || 1629| | | || 1630| | | || 1631| | | || 1632| | | || 1633| | | || 1634| | | || 1635| | | || 1636| | | || 1637| | | || 1638| | | || 1639| | | || 1640| | | || 1641| | | || 1642| | | || 1643| | | || 1644| | | || 1645| | | || 1646| | | || 1647| | | || 1648| | | || 1649| | | || 1650| | | || 1651| | | || 1652| | | || 1653| | | || 1654| | | || 1655| | | || 1656| | | || 1657| | | || 1658| | | || 1659| | | || 1660| | | || 1661| | | || 1662| | | || 1663| | | || 1664| | | || 1665| | | || 1666| | | || 1667| | | || 1668| | | || 1669| | | || 1670| | | || 1671| | | || 1672| | | || 1673| | | || 1674| | | || 1675| | | || 1676| | | || 1677| | | || 1678| | | || 1679| | | || 1680| | | || 1681| | | || 1682| | | || 1683| | | || 1684| | | || 1685| | | || 1686| | | || 1687| | | || 1688| | | || 1689| | | || 1690| | | || 1691| | | || 1692| | | || 1693| | | || 1694| | | || 1695| | | || 1696| | | || 1697| | | || 1698| | | || 1699| | | || 1700| | | || 1701| | | || 1702| | | || 1703| | | || 1704| | | || 1705| | | || 1706| | | || 1707| | | || 1708| | | || 1709| | | || 1710| | | || 1711| | | || 1712| | | || 1713| | | || 1714| | | || 1715| | | || 1716| | | || 1717| | | || 1718| | | || 1719| | | || 1720| | | || 1721| | | || 1722| | | || 1723| | | || 1724| | | || 1725| | | || 1726| | | || 1727| | | || 1728| | | || 1729| | | || 1730| | | || 1731| | | || 1732| | | || 1733| | | || 1734| | | || 1735| | | || 1736| | | || 1737| | | || 1738| | | || 1739| | | || 1740| | | || 1741| | | || 1742| | | || 1743| | | || 1744| | | || 1745| | | || 1746| | | || 1747| | | || 1748| | | || 1749| | | || 1750| | | || 1751| | | || 1752| | | || 1753| | | || 1754| | | || 1755| | | || 1756| | | || 1757| | | || 1758| | | || 1759| | | || 1760| | | || 1761| | | || 1762| | | || 1763| | | || 1764| | | || 1765| | | || 1766| | | || 1767| | | || 1768| | | || 1769| | | || 1770| | | || 1771| | | || 1772| | | || 1773| | | || 1774| | | || 1775| | | || 1776| | | || 1777| | | || 1778| | | || 1779| | | || 1780| | | || 1781| | | || 1782| | | || 1783| | | || 1784| | | || 1785| | | || 1786| | | || 1787| | | || 1788| | | || 1789| | | || 1790| | | || 1791| | | || 1792| | | || 1793| | | || 1794| | | || 1795| | | || 1796| | | || 1797| | | || 1798| | | || 1799| | | || 1800| | | || 1801| | | || 1802| | | || 1803| | | || 1804| | | || 1805| | | || 1806| | | || 1807| | | || 1808| | | || 1809| | | || 1810| | | || 1811| | | || 1812| | | || 1813| | | || 1814| | | || 1815| | | || 1816| | | || 1817| | | || 1818| | | || 1819| | | || 1820| | | || 1821| | | || 1822| | | || 1823| | | || 1824| | | || 1825| | | || 1826| | | || 1827| | | || 1828| | | || 1829| | | || 1830| | | || 1831| | | || 1832| | | || 1833| | | || 1834| | | || 1835| | | || 1836| | | || 1837| | | || 1838| | | || 1839| | | || 1840| | | || 1841| | | || 1842| | | || 1843| | | || 1844| | | || 1845| | | || 1846| | | || 1847| | | || 1848| | | || 1849| | | || 1850| | | || 1851| | | || 1852| | | || 1853| | | || 1854| | | || 1855| | | || 1856| | | || 1857| | | || 1858| | | || 1859| | | || 1860| | | || 1861| | | || 1862| | | || 1863| | | || 1864| | | || 1865| | | || 1866| | | || 1867| | | || 1868| | | || 1869| | | || 1870| | | || 1871| | | || 1872| | | || 1873| | | || 1874| | | || 1875| | | || 1876| | | || 1877| | | || 1878| | | || 1879| | | || 1880| | | || 1881| | | || 1882| | | || 1883| | | || 1884| | | || 1885| | | || 1886| | | || 1887| | | || 1888| | | || 1889| | | || 1890| | | || 1891| | | || 1892| | | || 1893| | | || 1894| | | || 1895| | | || 1896| | | || 1897| | | || 1898| | | || 1899| | | || 1900| | | || 1901| | | || 1902| | | || 1903| | | || 1904| | | || 1905| | | || 1906| | | || 1907| | | || 1908| | | || 1909| | | || 1910| | | || 1911| | | || 1912| | | || 1913| | | || 1914| | | || 1915| | | || 1916| | | || 1917| | | || 1918| | | || 1919| | | || 1920| | | || 1921| | | || 1922| | | || 1923| | | || 1924| | | || 1925| | | || 1926| | | || 1927| | | || 1928| | | || 1929| | | || 1930| | | || 1931| | | || 1932| | | || 1933| | | || 1934| | | || 1935| | | || 1936| | | || 1937| | | || 1938| | | || 1939| | | || 1940| | | || 1941| | | || 1942| | | || 1943| | | || 1944| | | || 1945| | | || 1946| | | || 1947| | | || 1948| | | || 1949| | | || 1950| | | || 1951| | | || 1952| | | || 1953| | | || 1954| | | || 1955| | | || 1956| | | || 1957| | | || 1958| | | || 1959| | | || 1960| | | || 1961| | | || 1962| | | || 1963| | | || 1964| | | || 1965| | | || 1966| | | || 1967| | | || 1968| | | || 1969| | | || 1970| | | || 1971| | | || 1972| | | || 1973| | | || 1974| | | || 1975| | | || 1976| | | || 1977| | | || 1978| | | || 1979| | | || 1980| | | || 1981| | | || 1982| | | || 1983| | | || 1984| | | || 1985| | | || 1986| | | || 1987| | | || 1988| | | || 1989| | | || 1990| | | || 1991| | | || 1992| | | || 1993| | | || 1994| | | || 1995| | | || 1996| | | || 1997| | | || 1998| | | || 1999| | | || 2000| | | || 2001| | | || 2002| | | || 2003| | | || 2004| | | || 2005| | | || 2006| | | || 2007| | | || 2008| | | || 2009| | | || 2010| | | || 2011| | | || 2012| | | || 2013| | | || 2014| | | || 2015| | | || 2016| | | || 2017| | | || 2018| | | || 2019| | | || 2020| | | || 2021| | | || 2022| | | || 2023| | | || 2024| | | || 2025| | | || 2026| | | || 2027| | | || 2028| | | || 2029| | | || 2030| | | || 2031| | | || 2032| | | || 2033| | | || 2034| | | || 2035| | | || 2036| | | || 2037| | | || 2038| | | || 2039| | | || 2040| | | || 2041| | | || 2042| | | || 2043| | | || 2044| | | || 2045| | | || 2046| | | || 2047| | | || 2048| | | || 2049| | | || 2050| | | || 2051| | | || 2052| | | || 2053| | | || 2054| | | || 2055| | | || 2056| | | || 2057| | | || 2058| | | || 2059| | | || 2060| | | || 2061| | | || 2062| | | || 2063| | | || 2064| | | || 2065| | | || 2066| | | || 2067| | | || 2068| | | || 2069| | | || 2070| | | || 2071| | | || 2072| | | || 2073| | | || 2074| | | || 2075| | | || 2076| | | || 2077| | | || 2078| | | || 2079| | | || 2080| | | || 2081| | | || 2082| | | || 2083| | | || 2084| | | || 2085| | | || 2086| | | || 2087| | | || 2088| | | || 2089| | | || 2090| | | || 2091| | | || 2092| | | || 2093| | | || 2094| | | || 2095| | | || 2096| | | || 2097| | | || 2098| | | || 2099| | | || 2100| | | || 2101| | | || 2102| | | || 2103| | | || 2104| | | || 2105| | | || 2106| | | || 2107| | | || 2108| | | || 2109| | | || 2110| | | || 2111| | | || 2112| | | || 2113| | | || 2114| | | || 2115| | | || 2116| | | || 2117| | | || 2118| | | || 2119| | | || 2120| | | || 2121| | | || 2122| | | || 2123| | | || 2124| | | || 2125| | | || 2126| | | || 2127| | | || 2128| | | || 2129| | | || 2130| | | || 2131| | | || 2132| | | || 2133| | | || 2134| | | || 2135| | | || 2136| | | || 2137| | | || 2138| | | || 2139| | | || 2140| | | || 2141| | | || 2142| | | || 2143| | | || 2144| | | || 2145| | | || 2146| | | || 2147| | | || 2148| | | || 2149| | | || 2150| | | || 2151| | | || 2152| | | || 2153| | | || 2154| | | || 2155| | | || 2156| | | || 2157| | | || 2158| | | || 2159| | | || 2160| | | || 2161| | | || 2162| | | || 2163| | | || 2164| | | || 2165| | | || 2166| | | || 2167| | | || 2168| | | || 2169| | | || 2170| | | || 2171| | | || 2172| | | || 2173| | | || 2174| | | || 2175| | | || 2176| | | || 2177| | | || 2178| | | || 2179| | | || 2180| | | || 2181| | | || 2182| | | || 2183| | | || 2184| | | || 2185| | | || 2186| | | || 2187| | | || 2188| | | || 2189| | | || 2190| | | || 2191| | | || 2192| | | || 2193| | | || 2194| | | || 2195| | | || 2196| | | || 2197| | | || 2198| | | || 2199| | | || 2200| | | || 2201| | | || 2202| | | || 2203| | | || 2204| | | || 2205| | | || 2206| | | || 2207| | | || 2208| | | || 2209| | | || 2210| | | || 2211| | | || 2212| | | || 2213| | | || 2214| | | || 2215| | | || 2216| | | || 2217| | | || 2218| | | || 2219| | | || 2220| | | || 2221| | | || 2222| | | || 2223| | | || 2224| | | || 2225| | | || 2226| | | || 2227| | | || 2228| | | || 2229| | | || 2230| | | || 2231| | | || 2232| | | || 2233| | | || 2234| | | || 2235| | | || 2236| | | || 2237| | | || 2238| | | || 2239| | | || 2240| | | || 2241| | | || 2242| | | || 2243| | | || 2244| | | || 2245| | | || 2246| | | || 2247| | | || 2248| | | || 2249| | | || 2250| | | || 2251| | | || 2252| | | || 2253| | | || 2254| | | || 2255| | | || 2256| | | || 2257| | | || 2258| | | || 2259| | | || 2260| | | || 2261| | | || 2262| | | || 2263| | | || 2264| | | || 2265| | | || 2266| | | || 2267| | | || 2268| | | || 2269| | | || 2270| | | || 2271| | | || 2272| | | || 2273| | | || 2274| | | || 2275| | | || 2276| | | || 2277| | | || 2278| | | || 2279| | | || 2280| | | || 2281| | | || 2282| | | || 2283| | | || 2284| | | || 2285| | | || 2286| | | || 2287| | | || 2288| | | || 2289| | | || 2290| | | || 2291| | | || 2292| | | || 2293| | | || 2294| | | || 2295| | | || 2296| | | || 2297| | | || 2298| | | || 2299| | | || 2300| | | || 2301| | | || 2302| | | || 2303| | | || 2304| | | || 2305| | | || 2306| | | || 2307| | | || 2308| | | || 2309| | | || 2310| | | || 2311| | | || 2312| | | || 2313| | | || 2314| | | || 2315| | | || 2316| | | || 2317| | | || 2318| | | || 2319| | | || 2320| | | || 2321| | | || 2322| | | || 2323| | | || 2324| | | || 2325| | | || 2326| | | || 2327| | | || 2328| | | || 2329| | | || 2330| | | || 2331| | | || 2332| | | || 2333| | | || 2334| | | || 2335| | | || 2336| | | || 2337| | | || 2338| | | || 2339| | | || 2340| | | || 2341| | | || 2342| | | || 2343| | | || 2344| | | || 2345| | | || 2346| | | || 2347| | | || 2348| | | || 2349| | | || 2350| | | || 2351| | | || 2352| | | || 2353| | | || 2354| | | || 2355| | | || 2356| | | || 2357| | | || 2358| | | || 2359| | | || 2360| | | || 2361| | | || 2362| | | || 2363| | | || 2364| | | || 2365| | | || 2366| | | || 2367| | | || 2368| | | || 2369| | | || 2370| | | || 2371| | | || 2372| | | || 2373| | | || 2374| | | || 2375| | | || 2376| | | || 2377| | | || 2378| | | || 2379| | | || 2380| | | || 2381| | | || 2382| | | || 2383| | | || 2384| | | || 2385| | | || 2386| | | || 2387| | | || 2388| | | || 2389| | | || 2390| | | || 2391| | | || 2392| | | || 2393| | | || 2394| | | || 2395| | | || 2396| | | || 2397| | | || 2398| | | || 2399| | | || 2400| | | || 2401| | | || 2402| | | || 2403| | | || 2404| | | || 2405| | | || 2406| | | || 2407| | | || 2408| | | || 2409| | | || 2410| | | || 2411| | | || 2412| | | || 2413| | | || 2414| | | || 2415| | | || 2416| | | || 2417| | | || 2418| | | || 2419| | | || 2420| | | || 2421| | | || 2422| | | || 2423| | | || 2424| | | || 2425| | | || 2426| | | || 2427| | | || 2428| | | || 2429| | | || 2430| | | || 2431| | | || 2432| | | || 2433| | | || 2434| | | || 2435| | | || 2436| | | || 2437| | | || 2438| | | || 2439| | | || 2440| | | || 2441| | | || 2442| | | || 2443| | | || 2444| | | || 2445| | | || 2446| | | || 2447| | | || 2448| | | || 2449| | | || 2450| | | || 2451| | | || 2452| | | || 2453| | | || 2454| | | || 2455| | | || 2456| | | || 2457| | | || 2458| | | || 2459| | | || 2460| | | || 2461| | | || 2462| | | || 2463| | | || 2464| | | || 2465| | | || 2466| | | || 2467| | | || 2468| | | || 2469| | | || 2470| | | || 2471| | | || 2472| | | || 2473| | | || 2474| | | || 2475| | | || 2476| | | || 2477| | | || 2478| | | || 2479| | | || 2480| | | || 2481| | | || 2482| | | || 2483| | | || 2484| | | || 2485| | | || 2486| | | || 2487| | | || 2488| | | || 2489| | | || 2490| | | || 2491| | | || 2492| | | || 2493| | | || 2494| | | || 2495| | | || 2496| | | || 2497| | | || 2498| | | || 2499| | | || 2500| | | || 2501| | | || 2502| | | || 2503| | | || 2504| | | || 2505| | | || 2506| | | || 2507| | | || 2508| | | || 2509| | | || 2510| | | || 2511| | | || 2512| | | || 2513| | | || 2514| | | || 2515| | | || 2516| | | || 2517| | | || 2518| | | || 2519| | | || 2520| | | || 2521| | | || 2522| | | || 2523| | | || 2524| | | || 2525| | | || 2526| | | || 2527| | | || 2528| | | || 2529| | | || 2530| | | || 2531| | | || 2532| | | || 2533| | | || 2534| | | || 2535| | | || 2536| | | || 2537| | | || 2538| | | || 2539| | | || 2540| | | || 2541| | | || 2542| | | || 2543| | | || 2544| | | || 2545| | | || 2546| | | || 2547| | | || 2548| | | || 2549| | | || 2550| | | || 2551| | | || 2552| | | || 2553| | | || 2554| | | || 2555| | | || 2556| | | || 2557| | | || 2558| | | || 2559| | | || 2560| | | || 2561| | | || 2562| | | || 2563| | | || 2564| | | || 2565| | | || 2566| | | || 2567| | | || 2568| | | || 2569| | | || 2570| | | || 2571| | | || 2572| | | || 2573| | | || 2574| | | || 2575| | | || 2576| | | || 2577| | | || 2578| | | || 2579| | | || 2580| | | || 2581| | | || 2582| | | || 2583| | | || 2584| | | || 2585| | | || 2586| | | || 2587| | | || 2588| | | || 2589| | | || 2590| | | || 2591| | | || 2592| | | || 2593| | | || 2594| | | || 2595| | | || 2596| | | || 2597| | | || 2598| | | || 2599| | | || 2600| | | || 2601| | | || 2602| | | || 2603| | | || 2604| | | || 2605| | | || 2606| | | || 2607| | | || 2608| | | || 2609| | | || 2610| | | || 2611| | | || 2612| | | || 2613| | | || 2614| | | || 2615| | | || 2616| | | || 2617| | | || 2618| | | || 2619| | | || 2620| | | || 2621| | | || 2622| | | || 2623| | | || 2624| | | || 2625| | | || 2626| | | || 2627| | | || 2628| | | || 2629| | | || 2630| | | || 2631| | | || 2632| | | || 2633| | | || 2634| | | || 2635| | | || 2636| | | || 2637| | | || 2638| | | || 2639| | | || 2640| | | || 2641| | | || 2642| | | || 2643| | | || 2644| | | || 2645| | | || 2646| | | || 2647| | | || 2648| | | || 2649| | | || 2650| | | || 2651| | | || 2652| | | || 2653| | | || 2654| | | || 2655| | | || 2656| | | || 2657| | | || 2658| | | || 2659| | | || 2660| | | || 2661| | | || 2662| | | || 2663| | | || 2664| | | || 2665| | | || 2666| | | || 2667| | | || 2668| | | || 2669| | | || 2670| | | || 2671| | | || 2672| | | || 2673| | | || 2674| | | || 2675| | | || 2676| | | || 2677| | | || 2678| | | || 2679| | | || 2680| | | || 2681| | | || 2682| | | || 2683| | | || 2684| | | || 2685| | | || 2686| | | || 2687| | | || 2688| | | || 2689| | | || 2690| | | || 2691| | | || 2692| | | || 2693| | | || 2694| | | || 2695| | | || 2696| | | || 2697| | | || 2698| | | || 2699| | | || 2700| | | || 2701| | | || 2702| | | || 2703| | | || 2704| | | || 2705| | | || 2706| | | || 2707| | | || 2708| | | || 2709| | | || 2710| | | || 2711| | | || 2712| | | || 2713| | | || 2714| | | || 2715| | | || 2716| | | || 2717| | | || 2718| | | || 2719| | | || 2720| | | || 2721| | | || 2722| | | || 2723| | | || 2724| | | || 2725| | | || 2726| | | || 2727| | | || 2728| | | || 2729| | | || 2730| | | || 2731| | | || 2732| | | || 2733| | | || 2734| | | || 2735| | | || 2736| | | || 2737| | | || 2738| | | || 2739| | | || 2740| | | || 2741| | | || 2742| | | || 2743| | | || 2744| | | || 2745| | | || 2746| | | || 2747| | | || 2748| | | || 2749| | | || 2750| | | || 2751| | | || 2752| | | || 2753| | | || 2754| | | || 2755| | | || 2756| | | || 2757| | | || 2758| | | || 2759| | | || 2760| | | || 2761| | | || 2762| | | || 2763| | | || 2764| | | || 2765| | | || 2766| | | || 2767| | | || 2768| | | || 2769| | | || 2770| | | || 2771| | | || 2772| | | || 2773| | | || 2774| | | || 2775| | | || 2776| | | || 2777| | | || 2778| | | || 2779| | | || 2780| | | || 2781| | | || 2782| | | || 2783| | | || 2784| | | || 2785| | | || 2786| | | || 2787| | | || 2788| | | || 2789| | | || 2790| | | || 2791| | | || 2792| | | || 2793| | | || 2794| | | || 2795| | | || 2796| | | || 2797| | | || 2798| | | || 2799| | | || 2800| | | || 2801| | | || 2802| | | || 2803| | | || 2804| | | || 2805| | | || 2806| | | || 2807| | | || 2808| | | || 2809| | | || 2810| | | || 2811| | | || 2812| | | || 2813| | | || 2814| | | || 2815| | | || 2816| | | || 2817| | | || 2818| | | || 2819| | | || 2820| | | || 2821| | | || 2822| | | || 2823| | | || 2824| | | || 2825| | | || 2826| | | || 2827| | | || 2828| | | || 2829| | | || 2830| | | || 2831| | | || 2832| | | || 2833| | | || 2834| | | || 2835| | | || 2836| | | || 2837| | | || 2838| | | || 2839| | | || 2840| | | || 2841| | | || 2842| | | || 2843| | | || 2844| | | || 2845| | | || 2846| | | || 2847| | | || 2848| | | || 2849| | | || 2850| | | || 2851| | | || 2852| | | || 2853| | | || 2854| | | || 2855| | | || 2856| | | || 2857| | | || 2858| | | || 2859| | | || 2860| | | || 2861| | | || 2862| | | || 2863| | | || 2864| | | || 2865| | | || 2866| | | || 2867| | | || 2868| | | || 2869| | | || 2870| | | || 2871| | | || 2872| | | || 2873| | | || 2874| | | || 2875| | | || 2876| | | || 2877| | | || 2878| | | || 2879| | | || 2880| | | || 2881| | | || 2882| | | || 2883| | | || 2884| | | || 2885| | | || 2886| | | || 2887| | | || 2888| | | || 2889| | | || 2890| | | || 2891| | | || 2892| | | || 2893| | | || 2894| | | || 2895| | | || 2896| | | || 2897| | | || 2898| | | || 2899| | | || 2900| | | || 2901| | | || 2902| | | || 2903| | | || 2904| | | || 2905| | | || 2906| | | || 2907| | | || 2908| | | || 2909| | | || 2910| | | || 2911| | | || 2912| | | || 2913| | | || 2914| | | || 2915| | | || 2916| | | || 2917| | | || 2918| | | || 2919| | | || 2920| | | || 2921| | | || 2922| | | || 2923| | | || 2924| | | || 2925| | | || 2926| | | || 2927| | | || 2928| | | || 2929| | | || 2930| | | || 2931| | | || 2932| | | || 2933| | | || 2934| | | || 2935| | | || 2936| | | || 2937| | | || 2938| | | || 2939| | | || 2940| | | || 2941| | | || 2942| | | || 2943| | | || 2944| | | || 2945| | | || 2946| | | || 2947| | | || 2948| | | || 2949| | | || 2950| | | || 2951| | | || 2952| | | || 2953| | | || 2954| | | || 2955| | | || 2956| | | || 2957| | | || 2958| | | || 2959| | | || 2960| | | || 2961| | | || 2962| | | || 2963| | | || 2964| | | || 2965| | | || 2966| | | || 2967| | | || 2968| | | || 2969| | | || 2970| | | || 2971| | | || 2972| | | || 2973| | | || 2974| | | || 2975| | | || 2976| | | || 2977| | | || 2978| | | || 2979| | | || 2980| | | || 2981| | | || 2982| | | || 2983| | | || 2984| | | || 2985| | | || 2986| | | || 2987| | | || 2988| | | || 2989| | | || 2990| | | || 2991| | | || 2992| | | || 2993| | | || 2994| | | || 2995| | | || 2996| | | || 2997| | | || 2998| | | || 2999| | | || 3000| | | || 3001| | | || 3002| | | || 3003| | | || 3004| | | || 3005| | | || 3006| | | || 3007| | | || 3008| | | || 3009| | | || 3010| | | || 3011| | | || 3012| | | || 3013| | | || 3014| | | || 3015| | | || 3016| | | || 3017| | | || 3018| | | || 3019| | | || 3020| | | || 3021| | | || 3022| | | || 3023| | | || 3024| | | || 3025| | | || 3026| | | || 3027| | | || 3028| | | || 3029| | | || 3030| | | || 3031| | | || 3032| | | || 3033| | | || 3034| | | || 3035| | | || 3036| | | || 3037| | | || 3038| | | || 3039| | | || 3040| | | || 3041| | | || 3042| | | || 3043| | | || 3044| | | || 3045| | | || 3046| | | || 3047| | | || 3048| | | || 3049| | | || 3050| | | || 3051| | | || 3052| | | || 3053| | | || 3054| | | || 3055| | | || 3056| | | || 3057| | | || 3058| | | || 3059| | | || 3060| | | || 3061| | | || 3062| | | || 3063| | | || 3064| | | || 3065| | | || 3066| | | || 3067| | | || 3068| | | || 3069| | | || 3070| | | || 3071| | | || 3072| | | || 3073| | | || 3074| | | || 3075| | | || 3076| | | || 3077| | | || 3078| | | || 3079| | | || 3080| | | || 3081| | | || 3082| | | || 3083| | | || 3084| | | || 3085| | | || 3086| | | || 3087| | | || 3088| | | || 3089| | | || 3090| | | || 3091| | | || 3092| | | || 3093| | | || 3094| | | || 3095| | | || 3096| | | || 3097| | | || 3098| | | || 3099| | | || 3100| | | || 3101| | | || 3102| | | || 3103| | | || 3104| | | || 3105| | | || 3106| | | || 3107| | | || 3108| | | || 3109| | | || 3110| | | || 3111| | | || 3112| | | || 3113| | | || 3114| | | || 3115| | | || 3116| | | || 3117| | | || 3118| | | || 3119| | | || 3120| | | || 3121| | | || 3122| | | || 3123| | | || 3124| | | || 3125| | | || 3126| | | || 3127| | | || 3128| | | || 3129| | | || 3130| | | || 3131| | | || 3132| | | || 3133| | | || 3134| | | || 3135| | | || 3136| | | || 3137| | | || 3138| | | || 3139| | | || 3140| | | || 3141| | | || 3142| | | || 3143| | | || 3144| | | || 3145| | | || 3146| | | || 3147| | | || 3148| | | || 3149| | | || 3150| | | || 3151| | | || 3152| | | || 3153| | | || 3154| | | || 3155| | | || 3156| | | || 3157| | | || 3158| | | || 3159| | | || 3160| | | || 3161| | | || 3162| | | || 3163| | | || 3164| | | || 3165| | | || 3166| | | || 3167| | | || 3168| | | || 3169| | | || 3170| | | || 3171| | | || 3172| | | || 3173| | | || 3174| | | || 3175| | | || 3176| | | || 3177| | | || 3178| | | || 3179| | | || 3180| | | || 3181| | | || 3182| | | || 3183| | | || 3184| | | || 3185| | | || 3186| | | || 3187| | | || 3188| | | || 3189| | | || 3190| | | || 3191| | | || 3192| | | || 3193| | | || 3194| | | || 3195| | | || 3196| | | || 3197| | | || 3198| | | || 3199| | | || 3200| | | || 3201| | | || 3202| | | || 3203| | | || 3204| | | || 3205| | | || 3206| | | || 3207| | | || 3208| | | || 3209| | | || 3210| | | || 3211| | | || 3212| | | || 3213| | | || 3214| | | || 3215| | | || 3216| | | || 3217| | | || 3218| | | || 3219| | | || 3220| | | || 3221| | | || 3222| | | || 3223| | | || 3224| | | || 3225| | | || 3226| | | || 3227| | | || 3228| | | || 3229| | | || 3230| | | || 3231| | | || 3232| | | || 3233| | | || 3234| | | || 3235| | | || 3236| | | || 3237| | | || 3238| | | || 3239| | | || 3240| | | || 3241| | | || 3242| | | || 3243| | | || 3244| | | || 3245| | | || 3246| | | || 3247| | | || 3248| | | || 3249| | | || 3250| | | || 3251| | | || 3252| | | || 3253| | | || 3254| | | || 3255| | | || 3256| | | || 3257| | | || 3258| | | || 3259| | | || 3260| | | || 3261| | | || 3262| | | || 3263| | | || 3264| | | || 3265| | | || 3266| | | || 3267| | | || 3268| | | || 3269| | | || 3270| | | || 3271| | | || 3272| | | || 3273| | | || 3274| | | || 3275| | | || 3276| | | || 3277| | | || 3278| | | || 3279| | | || 3280| | | || 3281| | | || 3282| | | || 3283| | | || 3284| | | || 3285| | | || 3286| | | || 3287| | | || 3288| | | || 3289| | | || 3290| | | || 3291| | | || 3292| | | || 3293| | | || 3294| | | || 3295| | | || 3296| | | || 3297| | | || 3298| | | || 3299| | | || 3300| | | || 3301| | | || 3302| | | || 3303| | | || 3304| | | || 3305| | | || 3306| | | || 3307| | | || 3308| | | || 3309| | | || 3310| | | || 3311| | | || 3312| | | || 3313| | | || 3314| | | || 3315| | | || 3316| | | || 3317| | | || 3318| | | || 3319| | | || 3320| | | || 3321| | | || 3322| | | || 3323| | | || 3324| | | || 3325| | | || 3326| | | || 3327| | | || 3328| | | || 3329| | | || 3330| | | || 3331| | | || 3332| | | || 3333| | | || 3334| | | || 3335| | | || 3336| | | || 3337| | | || 3338| | | || 3339| | | || 3340| | | || 3341| | | || 3342| | | || 3343| | | || 3344| | | || 3345| | | || 3346| | | || 3347| | | || 3348| | | || 3349| | | || 3350| | | || 3351| | | || 3352| | | || 3353| | | || 3354| | | || 3355| | | || 3356| | | || 3357| | | || 3358| | | || 3359| | | || 3360| | | || 3361| | | || 3362| | | || 3363| | | || 3364| | | || 3365| | | || 3366| | | || 3367| | | || 3368| | | || 3369| | | || 3370| | | || 3371| | | || 3372| | | || 3373| | | || 3374| | | || 3375| | | || 3376| | | || 3377| | | || 3378| | | || 3379| | | || 3380| | | || 3381| | | || 3382| | | || 3383| | | || 3384| | | || 3385| | | || 3386| | | || 3387| | | || 3388| | | || 3389| | | || 3390| | | || 3391| | | || 3392| | | || 3393| | | || 3394| | | || 3395| | | || 3396| | | || 3397| | | || 3398| | | || 3399| | | || 3400| | | || 3401| | | || 3402| | | || 3403| | | || 3404| | | || 3405| | | || 3406| | | || 3407| | | || 3408| | | || 3409| | | || 3410| | | || 3411| | | || 3412| | | || 3413| | | || 3414| | | || 3415| | | || 3416| | | || 3417| | | || 3418| | | || 3419| | | || 3420| | | || 3421| | | || 3422| | | || 3423| | | || 3424| | | || 3425| | | || 3426| | | || 3427| | | || 3428| | | || 3429| | | || 3430| | | || 3431| | | || 3432| | | || 3433| | | || 3434| | | || 3435| | | || 3436| | | || 3437| | | || 3438| | | || 3439| | | || 3440| | | || 3441| | | || 3442| | | || 3443| | | || 3444| | | || 3445| | | || 3446| | | || 3447| | | || 3448| | | || 3449| | | || 3450| | | || 3451| | | || 3452| | | || 3453| | | || 3454| | | || 3455| | | || 3456| | | || 3457| | | || 3458| | | || 3459| | | || 3460| | | || 3461| | | || 3462| | | || 3463| | | || 3464| | | || 3465| | | || 3466| | | || 3467| | | || 3468| | | || 3469| | | || 3470| | | || 3471| | | || 3472| | | || 3473| | | || 3474| | | || 3475| | | || 3476| | | || 3477| | | || 3478| | | || 3479| | | || 3480| | | || 3481| | | || 3482| | | || 3483| | | || 3484| | | || 3485| | | || 3486| | | || 3487| | | || 3488| | | || 3489| | | || 3490| | | || 3491| | | || 3492| | | || 3493| | | || 3494| | | || 3495| | | || 3496| | | || 3497| | | || 3498| | | || 3499| | | || 3500| | | || 3501| | | || 3502| | | || 3503| | | || 3504| | | || 3505| | | || 3506| | | || 3507| | | || 3508| | | || 3509| | | || 3510| | | || 3511| | | || 3512| | | || 3513| | | || 3514| | | || 3515| | | || 3516| | | || 3517| | | || 3518| | | || 3519| | | || 3520| | | || 3521| | | || 3522| | | || 3523| | | || 3524| | | || 3525| | | || 3526| | | || 3527| | | || 3528| | | || 3529| | | || 3530| | | || 3531| | | || 3532| | | || 3533| | | || 3534| | | || 3535| | | || 3536| | | || 3537| | | || 3538| | | || 3539| | | || 3540| | | || 3541| | | || 3542| | | || 3543| | | || 3544| | | || 3545| | | || 3546| | | || 3547| | | || 3548| | | || 3549| | | || 3550| | | || 3551| | | || 3552| | | || 3553| | | || 3554| | | || 3555| | | || 3556| | | || 3557| | | || 3558| | | || 3559| | | || 3560| | | || 3561| | | || 3562| | | || 3563| | | || 3564| | | || 3565| | | || 3566| | | || 3567| | | || 3568| | | || 3569| | | || 3570| | | || 3571| | | || 3572| | | || 3573| | | || 3574| | | || 3575| | | || 3576| | | || 3577| | | || 3578| | | || 3579| | | || 3580| | | || 3581| | | || 3582| | | || 3583| | | || 3584| | | || 3585| | | || 3586| | | || 3587| | | || 3588| | | || 3589| | | || 3590| | | || 3591| | | || 3592| | | || 3593| | | || 3594| | | || 3595| | | || 3596| | | || 3597| | | || 3598| | | || 3599| | | || 3600| | | || 3601| | | || 3602| | | || 3603| | | || 3604| | | || 3605| | | || 3606| | | || 3607| | | || 3608| | | || 3609| | | || 3610| | | || 3611| | | || 3612| | | || 3613| | | || 3614| | | || 3615| | | || 3616| | | || 3617| | | || 3618| | | || 3619| | | || 3620| | | || 3621| | | || 3622| | | || 3623| | | || 3624| | | || 3625| | | || 3626| | | || 3627| | | || 3628| | | || 3629| | | || 3630| | | || 3631| | | || 3632| | | || 3633| | | || 3634| | | || 3635| | | || 3636| | | || 3637| | | || 3638| | | || 3639| | | || 3640| | | || 3641| | | || 3642| | | || 3643| | | || 3644| | | || 3645| | | || 3646| | | || 3647| | | || 3648| | | || 3649| | | || 3650| | | |]]></content>
      <tags>
        <tag>ÂøÉÊÉÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1462 ÈÄöÂæÄÂ••Ê†ºÁëûÁéõÁöÑÈÅìË∑Ø]]></title>
    <url>%2F2018%2F04%2F23%2Fluogu1462%20%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[12345Âæà‰πÖÊ≤°ÂÜôÊúÄÁü≠Ë∑Ø‰∫ÜÈ¢òÁõÆÊúâÁÇπÁªïÁúãÊáÇ‰πãÂêéÂ∞±ÊòØ‰∏Ä‰∏™‰∫åÂàÜdijkÂú®ÂºÄO2‰∏ãÊØîspfaÂø´ÔºàÊ≠£Â∏∏‰πüÂ∫îËØ•Âø´Âïä„ÄÇ„ÄÇÔºâdequeÊõ¥Âø´ÁöÑÔºàO2‰∏ãÔºåÂèØqueueÂ±ÖÁÑ∂ÊòØÊúÄÂø´ÁöÑ„ÄÇ„ÄÇÔºâ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=10008,M=50008;int n,m,b;int a[N];int x,y,z;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[M&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int l,r,mid,ans=INT_MAX;int dis[N];int q[N],he,ta;bool inq[N];inline bool ok()&#123; memset(dis,0x3f,sizeof(dis)); dis[1]=0; he=1;ta=2; q[1]=1; inq[1]=1; while(he!=ta)&#123; int x=q[he]; inq[x]=0; ++he; if(he==10003) he=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(a[e[i].to]&lt;=mid&amp;&amp;dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; if(!inq[e[i].to])&#123; q[ta]=e[i].to; inq[e[i].to]=1; ++ta; if(ta==10003) ta=1; &#125; &#125; &#125; &#125; if(dis[n]&lt;=b) return 1; else return 0;&#125;int main()&#123; n=read();m=read();b=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); r=max(r,a[i]); &#125; l=a[1]; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); addedge(y,x,z); &#125; while(l&lt;=r)&#123; mid=(r-l)/2+l; if(ok())&#123; ans=mid; r=mid-1; &#125; else&#123; l=mid+1; &#125; &#125; if(ans!=INT_MAX) printf(&quot;%d&quot;,ans); else puts(&quot;AFK&quot;); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=10008,M=50008;int n,m,b;int a[N];int x,y,z;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[M&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int l,r,mid,ans=INT_MAX;int dis[N];priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;bool vis[N];inline bool ok()&#123; memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); dis[1]=0; q.push(mp(0,1)); while(!q.empty())&#123; int x=q.top().second; q.pop(); if(vis[x]) continue; vis[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(a[e[i].to]&lt;=mid&amp;&amp;dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; q.push(mp(dis[e[i].to],e[i].to)); &#125; &#125; &#125; if(dis[n]&lt;=b) return 1; else return 0;&#125;int main()&#123; n=read();m=read();b=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); r=max(r,a[i]); &#125; l=a[1]; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); addedge(y,x,z); &#125; while(l&lt;=r)&#123; mid=(r-l)/2+l; if(ok())&#123; ans=mid; r=mid-1; &#125; else&#123; l=mid+1; &#125; &#125; if(ans!=INT_MAX) printf(&quot;%d&quot;,ans); else puts(&quot;AFK&quot;); return 0;&#125;]]></content>
      <tags>
        <tag>‰∫åÂàÜ</tag>
        <tag>ÊúÄÁü≠Ë∑Ø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1341 Êó†Â∫èÂ≠óÊØçÂØπ]]></title>
    <url>%2F2018%2F04%2F23%2Fluogu1341%20%E6%97%A0%E5%BA%8F%E5%AD%97%E6%AF%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[12345Ê¨ßÊãâÂõûË∑ØÊ≥®ÊÑèÂõæÂèØËÉΩ‰∏çËøûÈÄöÔºàÂ∞ΩÁÆ°Êï∞ÊçÆÊ≤°Âç°ÔºâË¶ÅÊ±ÇÂ≠óÂÖ∏Â∫èÊúÄÂ∞èÁöÑÊ¨ßÊãâÂõûË∑ØÊâÄ‰ª•Ë¶ÅÁî®ÈÇªÊé•Áü©ÈòµÊ≥®ÊÑèË¶ÅÂÄíÂ∫èËæìÂá∫ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=58;int n;int a[N][N];char c,ans[N*N];int u,v,rt;int d[N],num;bool vis[N][N],flag;int cnt;inline void getc(int &amp;x)&#123; c=getchar(); while(!(c&gt;=&apos;A&apos;&amp;&amp;c&lt;=&apos;Z&apos;||c&gt;=&apos;a&apos;&amp;&amp;c&lt;=&apos;z&apos;)) c=getchar(); if(c&lt;=&apos;Z&apos;)&#123; x=c-&apos;A&apos;+1; &#125; else&#123; x=c-&apos;a&apos;+27; &#125;&#125;inline char backc(int x)&#123; if(x&lt;=26)&#123; return x+&apos;A&apos;-1; &#125; else&#123; return x+&apos;a&apos;-27; &#125;&#125;inline void dfs(int x)&#123; for(int i=1;i&lt;N;++i)&#123; if(!vis[x][i]&amp;&amp;a[x][i])&#123; vis[x][i]=vis[i][x]=1; dfs(i); &#125; &#125; ans[++cnt]=backc(x);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; getc(u);getc(v); a[u][v]=a[v][u]=1; ++d[u]; ++d[v]; &#125; for(int i=1;i&lt;N;++i)&#123; if(d[i]&amp;1)&#123; ++num; &#125; &#125; if(num!=0&amp;&amp;num!=2)&#123; puts(&quot;No Solution&quot;); return 0; &#125; for(int i=1;i&lt;N;++i)&#123; if(d[i])&#123; if(num==0)&#123; rt=i; break; &#125; else&#123; if(d[i]%2)&#123; rt=i; break; &#125; &#125; &#125; &#125; dfs(rt); if(cnt!=n+1)&#123; puts(&quot;No Solution&quot;); &#125; else&#123; for(int i=cnt;i;--i)&#123; printf(&quot;%c&quot;,ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ê¨ßÊãâË∑Ø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄêÂ≠¶‰π†Á¨îËÆ∞„ÄëÊ¨ßÊãâË∑Ø&ÂìàÂØÜÈ°øË∑Ø]]></title>
    <url>%2F2018%2F04%2F22%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%AC%A7%E6%8B%89%E8%B7%AF%26%E5%93%88%E5%AF%86%E9%A1%BF%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[12345678910```&lt;!--more--&gt;Ê¨ßÊãâË∑ØÔºö - 1.Â≠òÂú®ÊÄßÂà§Êñ≠Ôºö Êó†ÂêëÂõæÔºöÊó†Â•áÁÇπÁ≠â‰ª∑‰∫éÊ¨ßÊãâÂõûË∑ØÔºõÊúâ‰∏§‰∏™Â•áÁÇπÁ≠â‰ª∑‰∫éÊ¨ßÊãâÈÄöË∑Ø ÊúâÂêëÂõæÔºöÊâÄÊúâÁÇπÁöÑÂÖ•Â∫¶ÈÉΩÁ≠â‰∫éÂá∫Â∫¶Á≠â‰ª∑‰∫éÂ≠òÂú®Ê¨ßÊãâÂõûË∑ØÔºõ‰∏Ä‰∏™ÁÇπÂÖ•Â∫¶ÊØîÂá∫Â∫¶Â§ö1ÔºåÂè¶‰∏Ä‰∏™ÁÇπÂá∫Â∫¶ÊØîÂÖ•Â∫¶Â§ö1Á≠â‰ª∑‰∫éÊ¨ßÊãâÈÄöË∑Ø - 2.fleuryÁÆóÊ≥ïÔºö DFS(u): While (uÂ≠òÂú®Êú™Ë¢´Âà†Èô§ÁöÑËæπe(u,v)) Âà†Èô§Ëæπe(u,v) DFS(v) End PathSize ‚Üê PathSize + 1 Path[ PathSize ] ‚Üê u 123456789101112131415 Ê≥®ÊÑèÊúâÂêëÂõæÁöÑÊ¨ßÊãâË∑ØË¶ÅÂÄíÂ∫èËæìÂá∫ [ÂæàÂ•ΩÁöÑËµÑÊñô](http://www.cnblogs.com/TheRoadToTheGold/p/8439160.html)ÂìàÂØÜÈ°øË∑ØÔºànpÈóÆÈ¢òÔºâÔºö- 1.ÁãÑÊãâÂÖãÂÆöÁêÜÔºöÂ¶ÇÊûúÂõæGÊòØ‰∏Ä‰∏™ÂÖ∑Êúâ$n(n\geq 3)$‰∏™È°∂ÁÇπÁöÑÁÆÄÂçïÊó†ÂêëÂõæÔºåÂπ∂‰∏îÂõæG‰∏≠ÊØè‰∏™È°∂ÁÇπÁöÑÂ∫¶Êï∞Ëá≥Â∞ë‰∏∫$n/2$ÔºåÈÇ£‰πàÂõæGÊòØÂìàÂØÜÈ°øÂõæÔºàÂÖ∑ÊúâÂìàÂØÜÈ°øÂõûË∑ØÁöÑÂõæÔºâ„ÄÇÔºàËØÅÊòéÔºöÂΩíÁ∫≥Ôºâ Â••ÂãíÂÆöÁêÜÔºàdiracÂÆöÁêÜÁöÑÊé®ÂπøÔºâÔºöÂ¶ÇÊûúÂõæGÊòØ‰∏Ä‰∏™ÂÖ∑Êúâ$n(n\geq 3)$‰∏™È°∂ÁÇπÁöÑÁÆÄÂçïÊó†ÂêëÂõæÔºåÂπ∂‰∏îÂõæG‰∏≠ÊØè‰∏ÄÂØπ‰∏çÁõ∏ÈÇªÁöÑÈ°∂ÁÇπuÂíåvÊª°Ë∂≥$deg(u)+deg(v)\geq n$ÔºåÈÇ£‰πàÂõæGÊòØÂìàÂØÜÈ°øÂõæ„ÄÇ - 2.n(n&gt;=2)Èò∂Á´ûËµõÂõæ‰∏ÄÂÆöÂ≠òÂú®ÂìàÂØÜÈ°øÈÄöË∑Ø„ÄÇÔºàËØÅÊòéÔºöÂΩíÁ∫≥Ôºâ ÂΩì‰∏î‰ªÖÂΩìÁ´ûËµõÂõæÊòØÂº∫ËøûÈÄöÁöÑÔºåÂ≠òÂú®ÂìàÂØÜÈ°øÂõûË∑Ø„ÄÇÔºàËØÅÊòéÔºöÂΩíÁ∫≥Ôºâ - 3.Á´ûËµõÂõæ‰∏äÁöÑÂìàÂØÜÈ°øÂõûË∑Ø ÂÖàÊâæÂà∞‰∏Ä‰∏™ÁéØÔºåÂÜçÂú®ÁéØ‰∏äÊâ©Â±ï„ÄÇ hdu3414 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;climits&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #define mp make_pair #define pb push_back using namespace std; typedef long long LL; typedef pair&lt;int,int&gt; PII; inline LL read() { LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;){if(ch==&apos;-&apos;)f=-1;ch=getchar();} while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();} return x*f; } const int N=1008; int n; int a[N][N]; int nxt[N]; bool vis[N]; bool flag; int cnt; inline bool dfs(int x) { vis[x]=1; if(a[x][1]){ nxt[x]=1; ++cnt; return 1; } for(int i=2;i&lt;=n;++i){ if(!vis[i]&amp;&amp;a[x][i]){ if(dfs(i)){ nxt[x]=i; ++cnt; return 1; } } } return 0; } inline void solve() { memset(nxt,0,sizeof(nxt)); memset(vis,0,sizeof(vis)); cnt=0; if(!dfs(1)){ puts(&quot;-1&quot;); return; } while(1){ flag=0; for(int i=2;i&lt;=n;++i){ if(!nxt[i]){ for(int j=1;j&lt;=n;++j){ if(nxt[j]&amp;&amp;a[j][i]&amp;&amp;a[i][nxt[j]]){ nxt[i]=nxt[j]; nxt[j]=i; ++cnt; flag=1; break; } } } } if(!flag){ break; } } if(cnt==n){ printf(&quot;1&quot;); for(int i=nxt[1];i!=1;i=nxt[i]){ printf(&quot; %d&quot;,i); } puts(&quot;&quot;); } else{ puts(&quot;-1&quot;); } } int main() { while(1){ scanf(&quot;%d&quot;,&amp;n); if(!n) return 0; for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=n;++j){ a[i][j]=read(); } } if(n==1){ puts(&quot;1&quot;); continue; } solve(); } return 0; } ```]]></content>
      <tags>
        <tag>Ê¨ßÊãâË∑Ø</tag>
        <tag>ÂìàÂØÜÈ°øË∑Ø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÊâìÈ±ºËÆ∞]]></title>
    <url>%2F2018%2F04%2F22%2F%E6%89%93%E9%B1%BC%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1Ê¢¶Ê∏∏~ 18/4/22 ÂáÜÂ§áÂ•ΩËàπ„ÄÇÂùêÁ®≥‰∫ÜÔºåËÄÅÂè∏Êú∫Ë¶ÅÂá∫Êµ∑ÊâìÊ∏î‰∫ÜÔºÅ 18/4/23 ‰∏ÄÁ©∑‰∫åÁôΩÁöÑÊòéÂê¨Èóª‰∫ÜÊù•Ëá™È≠îÊ≥ï‰∏ñÁïåÁöÑÁ•ûÁßòÂÆùËóèÔºåÂÜ≥ÂÆöÂùê‰∏ä‰ªñÁöÑÂ∞èÊú®ËàπÔºåÂéªÊçû‰∏ä‰∏ÄÁ¨îÔºÅÁÑ∂ËÄåÔºåÊÉ≥Ë¶ÅËé∑ÂæóÈí±Ë¥¢ÔºåÊÄéËÉΩ‰∏ç‰ªòÂá∫‰ª£‰ª∑ÔºüÊçÆËØ¥Á•ûÁßòÂÆùËóèÈöêËóèÂú®‚Äú‰∏ñÁïåÂ∞ΩÂ§¥‚ÄùÁöÑÊµ∑Âüü‰∏≠ÁöÑ‰∏Ä‰∫õÂ∞èÂ≤õ‰∏ä„ÄÇËÄå‚Äú‰∏ñÁïåÂ∞ΩÂ§¥‚ÄùÔºåÈÇ£ÂèØÊòØÊó†‰∫∫ÁîüËøòÁöÑÁ¶ÅÂå∫ÔºÅÊµ∑Èù¢‰πã‰∏äÁöÑÈ£éÂπ≥Êµ™Èùô‰πüÊé©È•∞‰∏ç‰∫ÜÂÆÉÂÜÖÈÉ®ÁöÑÊ±πÊ∂åÊ≥¢Ê∂õÔºåËÄåÊúÄ‰ª§‰∫∫ÊÅêÊÉßÁöÑÔºå‰∏çÊòØÈÇ£ÊªîÂ§©È™áÊµ™ÔºåËÄåÊòØÊµ∑‰∏äÊùÄÊâã‚Äî‚ÄîÊµ∑ÁÅµ„ÄÇÊµ∑ÁÅµÊòØ‰∏ÄÁßçËÉΩÊéßÂà∂Ê∞¥ÂÖÉÁ¥†ÁöÑÈ´òÁ∫ßÂÖÉÁ¥†Á≤æÁÅµÔºå‰∫∫‰ª¨Âè™Âú®‚Äú‰∏ñÁïåÂ∞ΩÂ§¥‚Äù‰∏≠ÂèëÁé∞„ÄÇËÄåÊµ∑ÁÅµÔºå‰πüÂè™ÊòØÊµ∑Â≤∏ÊóÅÁöÑÊ∞¥ÁîüÁâ©ÔºåÈÇ£Ê†∏ÂøÉÂå∫ÂèàÊúâ‰ªÄ‰πàÂë¢ÔºüË∞Å‰πü‰∏çÁü•ÈÅì„ÄÇ‰∏∫‰∫ÜËé∑ÂæóÂÆùËóèÔºåÊòéÊãúËÆøÁöÑÈöê‰∏ñÁöÑÈ≠îÊ≥ïÂ∏àÔºåÂπ∂Â≠¶‰ºö‰∫ÜÂ•πÁöÑÊãõÁâåÊ≥ïÊúØ‚Äî‚ÄîÁÅ´ÁêÉÊúØ„ÄÇÁî®ÁÅ´ÁêÉÊúØÂ∞±ÂèØ‰ª•ËΩªÊùæÂπ≤ÊéâÊ∞¥ÁÅµÂï¶ÔºÅÂèØ‰ªñ‰∏çÁü•ÈÅìÔºåÊ∞¥ÁÅµÂèØÊòØÊ∞¥Â∑®‰∫∫ÁöÑÂ∞èÂñΩÂñΩÔºåÊùÄÊ≠ª‰∫ÜÊ∞¥ÁÅµ‰ºöÂºïÊù•Ê∞¥Â∑®‰∫∫ÁöÑ! 18/4/25 ÂòöÁëüÁöÑÊòéË¢´Ê∞¥Â∑®‰∫∫‰∏ÄÊã≥ÊâìÈ£û‰∫Ü‚Ä¶ ÊòéÂÜçÊ¨°ÂéªÊâæÈ≠îÊ≥ïÂ∏àÔºåÂ∏åÊúõÂ≠¶‰ºöÊõ¥Âº∫ÁöÑÈ≠îÊ≥ï„ÄÇÈ≠îÊ≥ïÂ∏àÂëäËØâÊòéÔºåÊÉ≥Ë¶ÅÊâìË¥•Ê∞¥Â∑®‰∫∫ÔºåÈúÄË¶ÅÈáäÊîæÊéèÁ©∫‰∏ÄÂàáÈ≠îÂäõÁöÑÊØÅÁÅ≠È≠îÊ≥ï‚Äî‚ÄîÁÇéÁàÜÊúØÔºÅÁÑ∂ËÄåÔºåÈáäÊîæÂÆåÁÇéÁàÜÊúØ‰πãÂêéÔºå‰æø‰ºöÁ≤æÁñ≤ÂäõÁ´≠ÔºåË¢´Âë®Âõ¥ÁöÑÊ∞¥ÁÅµÂêûÈ£ü„ÄÇËÅ™ÊòéÁöÑÊòéËßâÂæóÊØÅÁÅ≠‰∏ç‰∏ÄÂÆöÊòØÊúÄÊúâÊïàÁöÑÊñπÊ≥ïÔºåÊéßÂà∂ÊàñËÆ∏ËÉΩËµ∑Âà∞Êõ¥Â§ßÁöÑÊïàÊûú„ÄÇ‰∫éÊòØ‰ªñÂ≠¶‰π†‰∫ÜËÉΩÂÜ∞ÂÜª‰ΩèÂà´‰∫∫ÁöÑÂÜ∞ÁéØ‚Äî‚ÄîÂÜ∞ÈúúÊñ∞Êòü„ÄÇÂèØÊòØÂÜ∞ÁéØÁöÑ‰ΩøÁî®‰πüÊòØÊúâÈôêÁöÑÔºåÂ¶Ç‰ΩïÂ∑ßÂ¶ôÂú∞ËøêÁî®ÂèØ‰ª•ÂÜ≥ÂÆöÊòéÊúÄÁªàËÉΩÊãøÂà∞Âá†‰∏™ÂÆùËóè„ÄÇ]]></content>
      <tags>
        <tag>ÂøÉÊÉÖ</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F22%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91kd-tree%2F</url>
    <content type="text"><![CDATA[kd-treen‰∏™kÁª¥Á©∫Èó¥‰∏ãÁöÑÁÇπÂ§çÊùÇÂ∫¶O($n^{(k-1)/k}$)ÂæÖË°•ÂÖÖ]]></content>
  </entry>
  <entry>
    <title><![CDATA[luogu1415 ÊãÜÂàÜÊï∞Âàó]]></title>
    <url>%2F2018%2F04%2F20%2Fluogu1415%20%E6%8B%86%E5%88%86%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[12f[i]Ë°®Á§∫‰ªéÂâçÂæÄÂêéÂà∞iÊó∂ÔºåÊúÄÂêé‰∏Ä‰∏™Êï∞‰∏∫f[i]-iÔºàa-bË°®Á§∫‰ªéÁ¨¨a‰ΩçÂà∞Á¨¨b‰ΩçÔºâÔºåÊª°Ë∂≥Êï∞Âàó‰∏•Ê†ºÈÄíÂ¢ûÁöÑf[i]ÁöÑÊúÄÂ§ßÂÄºg[i]Ë°®Á§∫‰ªéÂêéÂæÄÂâçÂà∞iÊó∂ÔºåÊúÄÂêé‰∏Ä‰∏™Êï∞‰∏∫i-g[i]ÔºåÊª°Ë∂≥Êï∞Âàó‰∏•Ê†ºÈÄíÂ¢ûÁöÑg[i]ÁöÑÊúÄÂ§ßÂÄº 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=508;char a[N];int n;int f[N],g[N];int pos=1;inline bool cmp(int l1,int r1,int l2,int r2)&#123; while(l1&lt;r1&amp;&amp;a[l1]==&apos;0&apos;) ++l1; while(l2&lt;r2&amp;&amp;a[l2]==&apos;0&apos;) ++l2; if(r1-l1&lt;r2-l2) return 1; if(r1-l1&gt;r2-l2) return 0; int len=r1-l1; for(int i=0;i&lt;=len;++i)&#123; if(a[l1+i]&lt;a[l2+i]) return 1; if(a[l1+i]&gt;a[l2+i]) return 0; &#125; return 0;&#125;inline void dp1()&#123; for(int i=1;i&lt;=n;++i)&#123; f[i]=1; for(int j=i;j&gt;1;--j)&#123; if(cmp(f[j-1],j-1,j,i))&#123; f[i]=j; break; &#125; &#125; &#125;&#125;inline void dp2()&#123; int tmp=f[n]; g[tmp]=n; while(a[tmp-1]==&apos;0&apos;) g[--tmp]=n; for(int i=tmp-1;i;--i)&#123; for(int j=f[n]-1;j&gt;=i;--j)&#123; if(cmp(i,j,j+1,g[j+1]))&#123; g[i]=j; break; &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%s&quot;,a+1); n=strlen(a+1); dp1(); dp2(); while(1)&#123; for(int i=pos;i&lt;=g[pos];++i)&#123; printf(&quot;%c&quot;,a[i]); &#125; pos=g[pos]+1; if(pos&lt;=n)&#123; printf(&quot;,&quot;); &#125; else&#123; break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1070 ÈÅìË∑ØÊ∏∏Êàè]]></title>
    <url>%2F2018%2F04%2F20%2Fluogu1070%20%E9%81%93%E8%B7%AF%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223dpf[i]Ë°®Á§∫Âà∞iÊó∂ÂàªÁöÑÊúÄÂ§ßÊî∂Áõäsum[k][j]Ë°®Á§∫Á¨¨k‰∏™Êú∫Âô®‰∫∫ÂâçjÊó∂Èó¥ÁöÑÊî∂Áõäf[i]=max(f[j]+sum[k][i]-sum[k][j]-a[getid(k+j)];ÂÖ∂‰∏≠a[]ÁöÑ‰∏ãÊ†áÂ∫îËØ•ÊòØ‰ªékÂæÄÂêéËµ∞jÊ≠•ÁöÑÂú∞ÊñπËÆ∞ÂæóÊääf[]ÂàùÂßãÂåñÊàêÊúÄÂ∞èÁöÑÔºåÁ≠îÊ°àÂèØËÉΩÊòØË¥üÁöÑËøôÊ†∑O($n^3$)Â∞±ËÉΩËøá‰∫ÜÔºàÊØïÁ´üpjÈ¢òÔºâ2d/1dËÄÉËôë‰ºòÂåñÊàê2d/0dÂçïË∞ÉÈòüÂàói‰∏çÂ•ΩÊîæÂà∞ÂçïË∞ÉÈòüÂàóÈáåjÊúâÈôêÂà∂Ôºàj&gt;=i-pÔºâÔºåjÂ∫îËØ•ÊòØÂçïË∞ÉÈòüÂàóÁöÑ‰∏Ä‰∏™‰∏ãÊ†áÁÑ∂ËÄå‰∏ÄÁª¥Âπ∂‰∏çÂ•ΩÂ§ÑÁêÜËøô‰∏™ÈóÆÈ¢òq[k][j]Ë°®Á§∫ÂØπÊØè‰∏™kÁöÑ‰∏Ä‰∏™ÂçïË∞ÉÈòüÂàómax(f[j]-sum[k][j]-a[getid(k+j)]-&gt;q[k][j]ËøôÊ†∑ÂØπÊØè‰∏™iÂè™ÈúÄË¶ÅÊûö‰∏ækË∑ë‰∫Ü100+msÁÑ∂ËÄåcandy?ÁöÑ‰ª£Á†Å20+ms‰ΩÜ‰ªñÁöÑ‰ª£Á†Å‰∏≠Êúâ‰∏ÄÁÇπÈóÆÈ¢òËøá‰∏ç‰∫Ühackf[i][j]‰∏≠ÊúÄÂ§ß‰∏ç‰∏ÄÂÆöÊòØÊúÄÂ•ΩÔºàÊúâÂêéÊïàÊÄßÔºâÂõ†‰∏∫step[i][j]=pÊó∂ÔºåÊòØÊó†Ê≥ïÂêëÂêéËΩ¨ÁßªÁöÑ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int n,m,p;int a[N],b[N][N],sum[N][N],f[N];inline int getid(int x)&#123; return (x-1)%n+1;&#125;int main()&#123; n=read();m=read();p=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; b[i][j]=read(); &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; sum[i][j]=sum[i][j-1]+b[getid(i+j-1)][j]; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;=m;++i)&#123; f[i]=INT_MIN; &#125; for(int i=1;i&lt;=m;++i)&#123; for(int j=i-1;j&gt;=i-p&amp;&amp;j&gt;=0;--j)&#123; for(int k=1;k&lt;=n;++k)&#123; f[i]=max(f[i],f[j]+sum[k][i]-sum[k][j]-a[getid(k+j)]); &#125; &#125; &#125; printf(&quot;%d&quot;,f[m]); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int n,m,p;int a[N],b[N][N],sum[N][N],f[N];int tmp;PII q[N][N];int he[N],ta[N];inline int getid(int x)&#123; return (x-1)%n+1;&#125;int main()&#123; n=read();m=read();p=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; b[i][j]=read(); &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; sum[i][j]=sum[i][j-1]+b[getid(i+j-1)][j]; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;=m;++i)&#123; f[i]=INT_MIN; &#125; for(int i=1;i&lt;=m;++i)&#123; for(int k=1;k&lt;=n;++k)&#123; tmp=f[i-1]-sum[k][i-1]-a[getid(k+i-1)]; while(tmp&gt;q[k][ta[k]].first&amp;&amp;ta[k]&gt;he[k])&#123; --ta[k]; &#125; q[k][++ta[k]]=mp(tmp,i-1); &#125; for(int k=1;k&lt;=n;++k)&#123; while(q[k][he[k]+1].second&lt;i-p)&#123; ++he[k]; &#125; f[i]=max(f[i],q[k][he[k]+1].first+sum[k][i]); &#125; &#125; printf(&quot;%d&quot;,f[m]); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>ÂçïË∞ÉÈòüÂàó</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2051 [AHOI2009]‰∏≠ÂõΩË±°Ê£ã]]></title>
    <url>%2F2018%2F04%2F18%2Fluogu2051%20%5BAHOI2009%5D%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[12345f[i][j][k]Ë°®Á§∫Âà∞Á¨¨iË°åÔºåÂÖ∂‰∏≠jÂàóÊúâ1‰∏™ÔºåkÂàóÊúâ2‰∏™ËΩ¨ÁßªËßÅ‰ª£Á†Å‰∏çË¶ÅÊäänÂíåmÊâìÈîô‰∫ÜÔºÅÔºÅÔºÅ‰∏çË¶ÅÊäänÂíåmÊâìÈîô‰∫ÜÔºÅÔºÅÔºÅ‰∏çË¶ÅÊäänÂíåmÊâìÈîô‰∫ÜÔºÅÔºÅÔºÅ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108,mod=9999973;int n,m;int f[N][N][N],ans;int main()&#123; n=read();m=read(); f[0][0][0]=1; for(int i=1;i&lt;=n;++i)&#123; for(int k=0;k&lt;=m;++k)&#123; for(int j=0;j+k&lt;=m;++j)&#123; f[i][j][k]=f[i-1][j][k]; if(j&gt;=1)&#123; f[i][j][k]=(1ll*f[i-1][j-1][k]*(m-k-j+1)%mod+f[i][j][k])%mod; if(j&gt;=2)&#123; f[i][j][k]=(1ll*(m-k-j+2)*(m-k-j+1)/2*f[i-1][j-2][k]%mod+f[i][j][k])%mod; &#125; &#125; if(k&gt;=1)&#123; f[i][j][k]=(1ll*f[i-1][j+1][k-1]*(j+1)%mod+f[i][j][k])%mod; f[i][j][k]=(1ll*(m-k-j+1)*j*f[i-1][j][k-1]%mod+f[i][j][k])%mod; if(k&gt;=2)&#123; f[i][j][k]=(1ll*(j+2)*(j+1)/2*f[i-1][j+2][k-2]%mod+f[i][j][k])%mod; &#125; &#125; &#125; &#125; &#125; /*for(int i=1;i&lt;=n;++i)&#123; for(int k=0;k&lt;=m;++k)&#123; for(int j=0;j+k&lt;=m;++j)&#123; cerr&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;j&lt;&lt;&apos; &apos;&lt;&lt;k&lt;&lt;&apos; &apos;&lt;&lt;f[i][j][k]&lt;&lt;&apos;\n&apos;; &#125; &#125; &#125;*/ for(int j=0;j&lt;=m;++j)&#123; for(int k=0;j+k&lt;=m;++k)&#123; ans+=f[n][j][k]; if(ans&gt;mod)&#123; ans-=mod; &#125; &#125; &#125; printf(&quot;%d&quot;,ans); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108,mod=9999973;int n,m;int f[N][N],ans;int main()&#123; n=read();m=read(); f[0][0]=1; for(int i=1;i&lt;=n;++i)&#123; for(int k=m;k&gt;=0;--k)&#123; for(int j=m-k;j&gt;=0;--j)&#123; f[j][k]=f[j][k]; if(j&gt;=1)&#123; f[j][k]=(1ll*f[j-1][k]*(m-k-j+1)%mod+f[j][k])%mod; if(j&gt;=2)&#123; f[j][k]=(1ll*(m-k-j+2)*(m-k-j+1)/2*f[j-2][k]%mod+f[j][k])%mod; &#125; &#125; if(k&gt;=1)&#123; f[j][k]=(1ll*f[j+1][k-1]*(j+1)%mod+f[j][k])%mod; f[j][k]=(1ll*(m-k-j+1)*j*f[j][k-1]%mod+f[j][k])%mod; if(k&gt;=2)&#123; f[j][k]=(1ll*(j+2)*(j+1)/2*f[j+2][k-2]%mod+f[j][k])%mod; &#125; &#125; &#125; &#125; &#125; for(int j=0;j&lt;=m;++j)&#123; for(int k=0;j+k&lt;=m;++k)&#123; ans+=f[j][k]; if(ans&gt;mod)&#123; ans-=mod; &#125; &#125; &#125; printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2947 Widget Factory]]></title>
    <url>%2F2018%2F04%2F17%2Fpoj2947%20Widget%20Factory%2F</url>
    <content type="text"><![CDATA[12345678910Ê∂àÊàêÂØπËßíÁ∫øÁöÑÊñπÊ≥ïÂ∞±‰∏çË°å‰∫Ü‰∏çÊòØÊñπÈòµÊ∂àÊàêË°åÈò∂Ê¢ØÂΩ¢‰ªénowÂºÄÂßã‰ª•ÂêéÊúâÁ≥ªÊï∞ÂÖ®‰∏∫0,‰ΩÜÂè≥Ëæπ‰∏ç‰∏∫0ÁöÑÂ∞±Êó†Ëß£Âê¶Âàônow&lt;nÂ§öËß£ËøôÈ¢òÊï∞ÊçÆÊå∫Â§ßÁöÑÔºà‰∏ÄËà¨È¢òÈÉΩÊòØ0msÔºâÈ´òÊñØÁ∫¶Êó¶Ê≥ïÂú®ÈÄüÂ∫¶‰∏äÁöÑÂ∑ÆÂºÇ‰ΩìÁé∞Âá∫Êù•‰∫Ü‰ºöÊÖ¢100msÂ∑¶Âè≥ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int mod=7,N=308,M=308;int n,m,k;char s[5],t[5];int a[M][N];int cas;int inv[10];inline int sol(char *x)&#123; if(x[0]==&apos;M&apos;) return 1; if(x[0]==&apos;T&apos;&amp;&amp;x[1]==&apos;U&apos;) return 2; if(x[0]==&apos;W&apos;) return 3; if(x[0]==&apos;T&apos;&amp;&amp;x[1]==&apos;H&apos;) return 4; if(x[0]==&apos;F&apos;) return 5; if(x[0]==&apos;S&apos;&amp;&amp;x[1]==&apos;A&apos;) return 6; if(x[0]==&apos;S&apos;&amp;&amp;x[1]==&apos;U&apos;) return 7;&#125;inline int gauss()&#123; register int i,j,k,t,now=1; for(j=1;j&lt;=n;++j)&#123; if(a[now][j]==0)&#123; for(i=now+1;i&lt;=m&amp;&amp;a[i][j]==0;++i); if(i&gt;m) continue; for(k=j;k&lt;=n+1;++k)&#123; swap(a[i][k],a[now][k]); &#125; &#125; for(i=1;i&lt;=m;++i)&#123; if(i!=now&amp;&amp;a[i][j])&#123; t=a[i][j]*inv[a[now][j]]%mod; for(k=j;k&lt;=n+1;++k)&#123; a[i][k]=(a[i][k]-t*a[now][k]%mod+mod)%mod; &#125; &#125; &#125; ++now; &#125; for(int i=now;i&lt;=m;++i)&#123; if(a[i][n+1])&#123; int f=0; for(int j=i;j&lt;=n;++j)&#123; if(a[i][j])&#123; f=1; break; &#125; &#125; if(!f) return -1;//Êó†Ëß£ &#125; &#125; if(now&lt;n) return 1;//ÊúâËá™Áî±ÂèòÈáèÔºåÂ§öËß£ for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]=a[i][n+1]*inv[a[i][i]]%mod; &#125; return 0;&#125;int main()&#123; inv[1]=1; for(int i=2;i&lt;mod;++i)&#123; inv[i]=mod-mod/i*inv[mod%i]%mod; &#125; while(1)&#123; n=read();m=read(); if(n==0&amp;&amp;m==0) return 0; memset(a,0,sizeof(a)); for(int i=1;i&lt;=m;++i)&#123; k=read(); scanf(&quot;%s%s&quot;,s,t); a[i][n+1]=(sol(t)-sol(s)+1+mod)%mod; while(k--) ++a[i][read()]; for(int j=1;j&lt;=n;++j) a[i][j]%=mod; &#125; cas=gauss(); if(cas==-1)&#123; puts(&quot;Inconsistent data.&quot;); &#125; else if(cas==1)&#123; puts(&quot;Multiple solutions.&quot;); &#125; else&#123; for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%d &quot;,a[i][n+1]&lt;3?a[i][n+1]+mod:a[i][n+1]); &#125; puts(&quot; &quot;); &#125; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int mod=7,N=308,M=308;int n,m,k;char s[5],t[5];int a[M][N];int cas;int inv[10];inline int sol(char *x)&#123; if(x[0]==&apos;M&apos;) return 1; if(x[0]==&apos;T&apos;&amp;&amp;x[1]==&apos;U&apos;) return 2; if(x[0]==&apos;W&apos;) return 3; if(x[0]==&apos;T&apos;&amp;&amp;x[1]==&apos;H&apos;) return 4; if(x[0]==&apos;F&apos;) return 5; if(x[0]==&apos;S&apos;&amp;&amp;x[1]==&apos;A&apos;) return 6; if(x[0]==&apos;S&apos;&amp;&amp;x[1]==&apos;U&apos;) return 7;&#125;inline int gauss()&#123; register int i,j,k,t,now=1; for(j=1;j&lt;=n;++j)&#123; if(a[now][j]==0)&#123; for(i=now+1;i&lt;=m&amp;&amp;a[i][j]==0;++i); if(i&gt;m) continue; for(k=j;k&lt;=n+1;++k)&#123; swap(a[i][k],a[now][k]); &#125; &#125; for(i=now+1;i&lt;=m;++i)&#123; if(a[i][j])&#123; t=a[i][j]*inv[a[now][j]]%mod; for(k=j;k&lt;=n+1;++k)&#123; a[i][k]=(a[i][k]-t*a[now][k]%mod+mod)%mod; &#125; &#125; &#125; ++now; &#125; for(i=now;i&lt;=m;++i)&#123; if(a[i][n+1])&#123; int f=0; for(j=i;j&lt;=n;++j)&#123; if(a[i][j])&#123; f=1; break; &#125; &#125; if(!f) return -1;//√é√û¬Ω√¢ &#125; &#125; if(now&lt;n) return 1;//√ì√ê√ó√î√ì√â¬±√§√Å¬ø¬£¬¨¬∂√†¬Ω√¢ for(i=n;i;--i)&#123; for(j=n;j&gt;i;--j)&#123; a[i][n+1]=(a[i][n+1]-a[i][j]*a[j][n+1]%mod+mod)%mod; &#125; a[i][n+1]=a[i][n+1]*inv[a[i][i]]%mod; &#125; return 0;&#125;int main()&#123; inv[1]=1; for(int i=2;i&lt;mod;++i)&#123; inv[i]=mod-mod/i*inv[mod%i]%mod; &#125; while(1)&#123; n=read();m=read(); if(n==0&amp;&amp;m==0) return 0; memset(a,0,sizeof(a)); for(int i=1;i&lt;=m;++i)&#123; k=read(); scanf(&quot;%s%s&quot;,s,t); a[i][n+1]=(sol(t)-sol(s)+1+mod)%mod; while(k--) ++a[i][read()]; for(int j=1;j&lt;=n;++j) a[i][j]%=mod; &#125; cas=gauss(); if(cas==-1)&#123; puts(&quot;Inconsistent data.&quot;); &#125; else if(cas==1)&#123; puts(&quot;Multiple solutions.&quot;); &#125; else&#123; for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%d &quot;,a[i][n+1]&lt;3?a[i][n+1]+mod:a[i][n+1]); &#125; puts(&quot; &quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È´òÊñØÊ∂àÂÖÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2065 SETI]]></title>
    <url>%2F2018%2F04%2F17%2Fpoj2065%20SETI%2F</url>
    <content type="text"><![CDATA[123È´òÊñØÊ∂àÂÖÉËß£ÂÜ≥Ê®°Á∫øÊÄßÊñπÁ®ãÁªÑÊ®°Êï∞‰∏∫Ë¥®Êï∞‰∏îÂùáÁõ∏Âêå‰∏çÂêåÁöÑ‰∏ç‰ºöÔºå‰∏çÊòØË¥®Êï∞ÁöÑÊõ¥‰∏ç‰ºö 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=78;int T;int p;int a[N][N];char s[N];int n;inline int ksm(int x,int y)&#123; int tmp=1; while(y)&#123; if(y&amp;1) tmp=tmp*x%p; x=x*x%p; y&gt;&gt;=1; &#125; return tmp;&#125;inline int inv(int x)&#123; return ksm(x,p-2);&#125;inline void gauss()&#123; register int i,j,k,t1,t2; for(int j=1;j&lt;=n;++j)&#123; if(a[j][j]==0)&#123; for(i=j+1;i&lt;=n&amp;&amp;a[i][j]==0;++i); for(k=j;k&lt;=n+1;++k)&#123; swap(a[i][k],a[j][k]); &#125; &#125; t1=inv(a[j][j]); for(i=1;i&lt;=n;++i)&#123; if(i!=j&amp;&amp;a[i][j])&#123; t2=a[i][j]*t1%p; for(k=j;k&lt;=n+1;++k)&#123; a[i][k]=((a[i][k]-t2*a[j][k])%p+p)%p; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]=a[i][n+1]*inv(a[i][i])%p; &#125;&#125;int main()&#123; T=read(); while(T--)&#123; //memset(a,0,sizeof(a)); p=read(); scanf(&quot;%s&quot;,s+1); n=strlen(s+1); for(int i=1;i&lt;=n;++i)&#123; if(s[i]!=&apos;*&apos;) a[i][n+1]=s[i]-&apos;a&apos;+1; else a[i][n+1]=0; a[i][1]=1; for(int j=2;j&lt;=n;++j)&#123; a[i][j]=a[i][j-1]*i%p; &#125; &#125; gauss(); for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%d &quot;,a[i][n+1]); &#125; puts(&quot;&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È´òÊñØÊ∂àÂÖÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2962 [USACO09NOV]ÁÅØLights]]></title>
    <url>%2F2018%2F04%2F17%2Fluogu2962%20%5BUSACO09NOV%5D%E7%81%AFLights%2F</url>
    <content type="text"><![CDATA[123456789101112131415È´òÊñØÊ∂àÂÖÉÁÑ∂ÂêéÊêúÁ¥¢Êûö‰∏æÊØè‰∏™Ëá™Áî±ÂèòÈáèÁöÑÂÄº‰∏∫‰∫ÜÊñπ‰æøÁ°ÆÂÆöËá™Áî±ÂèòÈáèÁöÑ‰ΩçÁΩÆa[i][i]=0Ë°®Á§∫iÊòØËá™Áî±ÂèòÈáè‰πüÂ∞±ÊòØÂ∞ÜÁ≥ªÊï∞Áü©ÈòµÊ∂àÊàêÂØπËßíÁ∫øËã•ÂØπËßíÁ∫ø‰∏ä‰∏∫1ÔºåÂàô1‰∏äÈù¢‰∏∫0Ëã•ÂØπËßíÁ∫ø‰∏ä‰∏∫0ÔºåÂàô0‰∏äÈù¢ÂèØËÉΩÊúâ1‰πüÂ∞±ÊòØÊòØËØ¥È´òÊñØÊ∂àÂÖÉ‰∏çÂøÖÊ∂àÊàêË°åÈò∂Ê¢ØÂΩ¢Ôºàa[i][j]==0ÂÜôÊàêa[i][j]ÔºåÂ∞èÈîôËØØË¶ÅÈÅøÂÖçÔºâmeet in the middle‰πüËÉΩÂÅöÊØîÈ´òÊñØÊ∂àÂÖÉÊÖ¢‰∏ÄÁÇπÔºà‰∏çËøáÊÑüËßâÊêúÁ¥¢ÁöÑÂ§çÊùÇÂ∫¶Êõ¥Ê≤°Êúâ‰øùËØÅÂïä„ÄÇ„ÄÇÔºâ‰ª£Á†ÅÊäÑhzwer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=40;int n,m;bitset&lt;N&gt; a[N];int x,y,now;int cnt,ans=INT_MAX,val[N];inline void gauss()&#123; register int i,j; for(int j=1;j&lt;=n;++j)&#123; if(a[j][j]==0)&#123; for(i=j+1;i&lt;=n&amp;&amp;a[i][j]==0;++i); if(i&gt;n) continue; swap(a[j],a[i]); &#125; for(int i=1;i&lt;=n;++i)&#123; if(i!=j&amp;&amp;a[i][j])&#123; a[i]^=a[j]; &#125; &#125; &#125;&#125;inline void dfs(int x)&#123; if(cnt&gt;=ans) return; if(!x)&#123; ans=cnt; return; &#125; if(a[x][x])&#123; int t=a[x][n+1]; for(int j=x+1;j&lt;=n;++j)&#123; if(a[x][j]) t^=val[j]; &#125; val[x]=t; if(t)&#123; ++cnt; dfs(x-1); --cnt; &#125; else&#123; dfs(x-1); &#125; &#125; else&#123; val[x]=0; dfs(x-1); val[x]=1; ++cnt; dfs(x-1); --cnt; &#125;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; a[i][i]=a[i][n+1]=1; &#125; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read(); a[x][y]=a[y][x]=1; &#125; gauss(); dfs(n); printf(&quot;%d&quot;,ans); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=40;int n,m;int x,y;LL ub,a[N];int cnt,ans=INT_MAX;map&lt;LL,int&gt; num;inline void dfs(int x,int tmp,LL key)&#123; if(x&gt;cnt)&#123; if(key==ub)&#123; ans=min(ans,tmp); return; &#125; if(cnt==n)&#123; int t=num[ub-key]; if(t) ans=min(ans,t+tmp); &#125; else&#123; int t=num[key]; if(!t||tmp&lt;t) num[key]=tmp; &#125; return; &#125; dfs(x+1,tmp,key); dfs(x+1,tmp+1,key^a[x]);&#125;int main()&#123; n=read();m=read(); ub=(1ll&lt;&lt;n)-1; for(int i=1;i&lt;=n;++i)&#123; a[i]=1ll&lt;&lt;(i-1); &#125; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read(); a[x]+=1ll&lt;&lt;(y-1); a[y]+=1ll&lt;&lt;(x-1); &#125; cnt=n/2; dfs(1,0,0); cnt=n; dfs(n/2+1,0,0); printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>È´òÊñØÊ∂àÂÖÉ</tag>
        <tag>MITM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[„ÄêÊ®°Êùø„ÄëÈùûÈÄíÂΩíexgcd]]></title>
    <url>%2F2018%2F04%2F17%2F%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E9%9D%9E%E9%80%92%E5%BD%92exgcd%2F</url>
    <content type="text"><![CDATA[123456789101112a*1+b*0=aa*0+b*1=bÁ≠âÂºèÂè≥Ëæπ‰ΩúËæóËΩ¨Áõ∏Èô§ËÆæax&apos;&apos;+by&apos;&apos;=t1ax&apos; +by&apos; =t2ax +by =t1-t1/t2*t2‰ª§q=t1/t2,r=t1%t2Âàôx=x&apos;&apos;-qx&apos;y=y&apos;&apos;-qy&apos;ÂΩìr=0Êó∂ÁªìÊùü 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;int a,b,x,y;inline void exgcd(int a,int b,int &amp;x,int &amp;y)&#123; x=0;y=1; int prevx=1,prevy=0; int q=a/b,r=a%b,t; while(r)&#123; t=x; x=prevx-q*x; prevx=t; t=y; y=prevy-q*y; prevy=t; a=b; b=r; q=a/b; r=a%b; &#125; //return b;//gcd(a,b)=b&#125;int main()&#123; a=read();b=read(); exgcd(a,b,x,y); printf(&quot;%d&quot;,(x%b+b)%b); return 0;&#125;]]></content>
      <tags>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2447 [SDOI2010]Â§ñÊòüÂçÉË∂≥Ëô´]]></title>
    <url>%2F2018%2F04%2F16%2Fluogu2447%20%5BSDOI2010%5D%E5%A4%96%E6%98%9F%E5%8D%83%E8%B6%B3%E8%99%AB%2F</url>
    <content type="text"><![CDATA[12345Ë£∏ÁöÑÂºÇÊàñÊñπÁ®ãÁªÑÊ≥®ÊÑèËÆ∞ÂΩïÊúÄÂ§öÁî®Âà∞Âì™‰∏™ÊñπÁ®ã‰∏çÁî®bitset‰∏çÂºÄO2‰ºöt3‰∏™ÁÇπÂΩìÁÑ∂Ë¶ÅÁî®bitsetÂï¶ÔºàÊìç‰ΩúÂ§çÊùÇÂ∫¶‰∏∫bitsetÈô§‰ª•Â≠óÈïøÔºåÂ§ßÊ¶ÇÂ∞±ÊòØcpu‰∏ÄÊ¨°ËÉΩÂ§ÑÁêÜÂ≠óÈïøÈïøÂ∫¶ÁöÑbit‰ΩçÂêß‚Äî‚Äîbx2kÔºâÊúÄÂø´ÁöÑÂêåÂ≠¶ÊòØ‰∏ÄËæπËØª‰∏ÄËæπÈ´òÊñØÊ∂àÂÖÉÁöÑÔºåÈ´òÁ∫ß 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008,M=2008;int n,m;int a[M][N];char c;int now=1,ans;inline bool gauss()&#123; register int i,j,k; for(int j=1;j&lt;=n;++j)&#123; if(a[now][j]==0)&#123; for(i=now+1;i&lt;=m&amp;&amp;a[i][j]==0;++i); if(i&gt;m) return 0;//Êúâ‰∏Ä‰∏™Ëá™Áî±ÂèòÈáèÔºåÂ§öËß£ ans=max(ans,i);//ÂΩìÂâçËÆøÈóÆÁöÑÊúÄÂ§ßË°å for(k=j;k&lt;=n+1;++k)&#123; swap(a[now][k],a[i][k]); &#125; &#125; ans=max(ans,j); for(int i=1;i&lt;=m;++i)&#123; if(now!=i&amp;&amp;a[i][j])&#123; for(k=j;k&lt;=n+1;++k)&#123; a[i][k]^=a[now][k]; &#125; &#125; &#125; ++now; &#125; return 1;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; for(int j=1;j&lt;=n+1;++j)&#123; c=getchar(); while(c!=&apos;0&apos;&amp;&amp;c!=&apos;1&apos;) c=getchar(); if(c==&apos;1&apos;)&#123; a[i][j]=1; &#125; &#125; &#125; if(gauss())&#123; printf(&quot;%d\n&quot;,ans); for(int i=1;i&lt;=n;++i)&#123; if(a[i][n+1]) puts(&quot;?y7M#&quot;); else puts(&quot;Earth&quot;); &#125; &#125; else&#123; puts(&quot;Cannot Determine&quot;); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008,M=2008;int n,m;bitset&lt;N&gt; a[M];char c;int now=1,ans;inline bool gauss()&#123; register int i,j,k; for(int j=1;j&lt;=n;++j)&#123; if(a[now][j]==0)&#123; for(i=now+1;i&lt;=m&amp;&amp;a[i][j]==0;++i); if(i&gt;m) return 0; ans=max(ans,i); swap(a[now],a[i]); &#125; ans=max(ans,j); for(int i=1;i&lt;=m;++i)&#123; if(now!=i&amp;&amp;a[i][j])&#123; a[i]^=a[now]; &#125; &#125; ++now; &#125; return 1;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; for(int j=1;j&lt;=n+1;++j)&#123; c=getchar(); while(c!=&apos;0&apos;&amp;&amp;c!=&apos;1&apos;) c=getchar(); if(c==&apos;1&apos;)&#123; a[i][j]=1; &#125; &#125; &#125; if(gauss())&#123; printf(&quot;%d\n&quot;,ans); for(int i=1;i&lt;=n;++i)&#123; if(a[i][n+1]) puts(&quot;?y7M#&quot;); else puts(&quot;Earth&quot;); &#125; &#125; else&#123; puts(&quot;Cannot Determine&quot;); &#125; return 0;&#125; 1Âà´‰∫∫ÁöÑ‰ª£Á†Å‚Üì 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;using namespace std;int gi()&#123; int x=0,w=1;char ch=getchar(); while ((ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&amp;&amp;ch!=&apos;-&apos;) ch=getchar(); if (ch==&apos;-&apos;) w=0,ch=getchar(); while (ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;) x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&apos;0&apos;,ch=getchar(); return w?x:-x;&#125;const int N = 1005;int n,m,ele,sol[N];char s[N];bitset&lt;N&gt;a[N],tmp;int main()&#123; n=gi();m=gi(); for (int ans=1;ans&lt;=m;++ans) &#123; scanf(&quot;%s&quot;,s+1);int x=gi(); for (int i=1;i&lt;=n;++i) tmp[i]=s[i]-&apos;0&apos;;tmp[n+1]=x; for (int i=1;i&lt;=n;++i) &#123; if (!tmp[i]) continue; if (!a[i][i]) &#123;a[i]=tmp;++ele;break;&#125; tmp^=a[i]; &#125; if (ele==n) &#123; printf(&quot;%d\n&quot;,ans); for (int i=n;i;--i) &#123; sol[i]=a[i][n+1]; for (int j=n;j&gt;i;--j) if (a[i][j]) sol[i]^=sol[j]; &#125; for (int i=1;i&lt;=n;++i) puts(sol[i]?&quot;?y7M#&quot;:&quot;Earth&quot;); return 0; &#125; &#125; puts(&quot;Cannot Determine&quot;);return 0;&#125;]]></content>
      <tags>
        <tag>È´òÊñØÊ∂àÂÖÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1222 EXTENDED LIGHTS OUT]]></title>
    <url>%2F2018%2F04%2F16%2Fpoj1222%20EXTENDED%20LIGHTS%20OUT%2F</url>
    <content type="text"><![CDATA[12ÁªèÂÖ∏ÁöÑÂºÇÊàñÊñπÁ®ãÁªÑbitsetÁî®printfËæìÂá∫Êó∂Ë¶ÅÂº∫Âà∂ËΩ¨Êç¢Á±ªÂûã 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;int T;int tmp;bitset&lt;38&gt; a[38];inline int getid(int x,int y)&#123; return (x-1)*6+y;&#125;inline void gauss()&#123; register int i,j,k,now=1; for(i=1;i&lt;=30;++i)&#123; if(a[now][i]==0)&#123; for(j=now+1;j&lt;=30&amp;&amp;a[j][i]==0;++j); if(j&gt;30) continue; swap(a[now],a[j]); &#125; for(k=1;k&lt;=30;++k)&#123; if(k!=now&amp;&amp;a[k][i]) a[k]^=a[now]; &#125; ++now; &#125;&#125;int main()&#123; T=read(); for(int cas=1;cas&lt;=T;++cas)&#123; printf(&quot;PUZZLE #%d\n&quot;,cas); for(int i=1;i&lt;=30;++i)&#123; a[i].reset(); &#125; for(int i=1;i&lt;=5;++i)&#123; for(int j=1;j&lt;=6;++j)&#123; tmp=getid(i,j); a[tmp][31]=read(); a[tmp][tmp]=1; if(i!=1)&#123; a[tmp][tmp-6]=1; &#125; if(i!=5)&#123; a[tmp][tmp+6]=1; &#125; if(j!=1)&#123; a[tmp][tmp-1]=1; &#125; if(j!=6)&#123; a[tmp][tmp+1]=1; &#125; &#125; &#125; gauss(); for(int i=1;i&lt;=5;++i)&#123; for(int j=1;j&lt;=6;++j)&#123; printf(&quot;%d &quot;,int(a[getid(i,j)][31])); &#125; puts(&quot;&quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È´òÊñØÊ∂àÂÖÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1830 ÂºÄÂÖ≥ÈóÆÈ¢ò]]></title>
    <url>%2F2018%2F04%2F16%2Fpoj1830%20%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617È´òÊñØÊ∂àÂÖÉËß£ÂÜ≥ÂºÇÊàñÊñπÁ®ãÁªÑÂºÇÊàñÊñπÁ®ãÁªÑ‰∏∫a11¬∑x1^a12¬∑x2^...^a1n¬∑xn=y1a21¬∑x1^a22¬∑x2^...^a2n¬∑xn=y2...an1¬∑x1^an2¬∑x2^...^ann¬∑xn=ynÂ¢ûÂπøÁü©Èòµ‰∏∫a11 a12 ... a1n y1a21 a22 ... a2n y2...an1 an2 ... ann ynÊâÄÊúâa,x,yÂùáÊòØ0/1Ê∂àÂÖÉÁöÑÊó∂ÂÄôÂ∞ÜÊüê‰∏ÄË°åÂä†Âà∞Âè¶‰∏ÄË°åÁõ∏ÂΩì‰∫éÊüê‰∏ÄË°åÂºÇÊàñÂà∞Âè¶‰∏ÄË°åÔºàÂõ†‰∏∫ÊòØÊ®°2ÁöÑÔºÅÔºÅÔºâbitsetÁ©∫Èó¥Ê∂àËÄóÊõ¥Â∞è‰ΩÜÊòØbitsetÁöÑÊØè‰∏Ä‰ΩçÊòØ1bitÔºå‰∏çÊòØc++Âü∫Êú¨Á±ªÂûãÔºå‰∏çËÉΩ^=(a[i]^=j‰∏çË°åÔºåa^=jÂèØ‰ª•) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=38;int T;int n,a[N][N],x,y,ans;inline int gauss()&#123; register int i,j,k,tmp;//i‰∏∫Ë°åÔºåj‰∏∫Âàó for(i=1,j=1;j&lt;=n;++j)&#123; if(a[i][j]==0)&#123; for(tmp=i+1;tmp&lt;=n;++tmp)&#123; if(a[tmp][j]) break; &#125; if(tmp&gt;n) continue; for(k=j;k&lt;=n+1;++k)&#123; swap(a[tmp][k],a[i][k]); &#125; &#125; for(k=1;k&lt;=n;++k)&#123; if(k!=i&amp;&amp;a[k][j])&#123; for(tmp=j;tmp&lt;=n+1;++tmp)&#123; a[k][tmp]^=a[i][tmp]; &#125; &#125; &#125; ++i; &#125; for(j=i;j&lt;=n;++j)&#123; if(a[j][n+1]) return -1; &#125; return 1&lt;&lt;(n-i+1);&#125;int main()&#123; T=read(); while(T--)&#123; memset(a,0,sizeof(a)); n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]=read(); &#125; for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]^=read(); &#125; for(int i=1;i&lt;=n;++i)&#123; a[i][i]=1; &#125; while(1)&#123; x=read();y=read(); if(x==0&amp;&amp;y==0) break; a[y][x]=1; &#125; ans=gauss(); if(ans==-1)&#123; puts(&quot;Oh,it&apos;s impossible~!!&quot;); &#125; else&#123; printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=38;int T;int n,x,y,ans;bitset&lt;N&gt; a[N];inline int gauss()&#123; register int i=1,j,k,tmp;//i‰∏∫Ë°åÔºåj‰∏∫Âàó for(j=1;j&lt;=n;++j)&#123; if(a[i][j]==0)&#123; for(tmp=i+1;tmp&lt;=n;++tmp)&#123; if(a[tmp][j]) break; &#125; if(tmp&gt;n) continue; swap(a[tmp],a[i]); &#125; for(k=1;k&lt;=n;++k)&#123; if(k!=i&amp;&amp;a[k][j])&#123; a[k]^=a[i]; &#125; &#125; ++i; &#125; for(j=i;j&lt;=n;++j)&#123; if(a[j][n+1]) return -1; &#125; return 1&lt;&lt;(n-i+1);&#125;int main()&#123; T=read(); while(T--)&#123; for(int i=1;i&lt;=n;++i)&#123; a[i].reset(); &#125; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]=read(); &#125; for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]=a[i][n+1]^read(); &#125; for(int i=1;i&lt;=n;++i)&#123; a[i][i]=1; &#125; while(1)&#123; x=read();y=read(); if(x==0&amp;&amp;y==0) break; a[y][x]=1; &#125; ans=gauss(); if(ans==-1)&#123; puts(&quot;Oh,it&apos;s impossible~!!&quot;); &#125; else&#123; printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È´òÊñØÊ∂àÂÖÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3389 „ÄêÊ®°Êùø„ÄëÈ´òÊñØÊ∂àÂÖÉÊ≥ï]]></title>
    <url>%2F2018%2F04%2F16%2Fluogu3389%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1kÈÄÜÂ∫èÊûö‰∏æÂèØ‰ª•ÂáèÂ∞ë‰∏≠Èó¥ÂèòÈáèÔºåÊèêÈ´òÁ≤æÂ∫¶ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108;const double eps=1e-8;int n;double a[N][N];int tmp;inline bool gauss()&#123; for(int i=1;i&lt;=n;++i)&#123; tmp=i; for(int j=i+1;j&lt;=n;++j)&#123; if(fabs(a[j][i])&gt;fabs(a[tmp][i]))&#123; tmp=j; &#125; &#125; if(tmp!=i)&#123; for(int j=i;j&lt;=n+1;++j)&#123; swap(a[tmp][j],a[i][j]); &#125; &#125; if(fabs(a[i][i])&lt;eps) return 0; for(int j=i+1;j&lt;=n;++j)&#123; for(int k=n+1;k&gt;=i;--k)&#123; a[j][k]-=a[j][i]/a[i][i]*a[i][k]; &#125; &#125; &#125; for(int i=n;i;--i)&#123; for(int j=i+1;j&lt;=n;++j)&#123; a[i][n+1]-=a[i][j]*a[j][n+1]; &#125; a[i][n+1]/=a[i][i]; &#125; return 1;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; a[i][j]=read(); &#125; a[i][n+1]=read(); &#125; if(gauss())&#123; for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%.2lf\n&quot;,a[i][n+1]); &#125; &#125; else&#123; puts(&quot;No Solution&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>È´òÊñØÊ∂àÂÖÉ</tag>
        <tag>Ê®°Êùø</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2577 [ZJOI2005]ÂçàÈ§ê]]></title>
    <url>%2F2018%2F04%2F15%2Fluogu2577%20%5BZJOI2005%5D%E5%8D%88%E9%A4%90%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819Â•óË∑ØÁöÑË¥™ÂøÉÂÅáÂ¶ÇÂè™Êúâ‰∏Ä‰∏™Á™óÂè£ÔºåÂèØ‰ª•ËØÅÊòéÊåâÂêÉÈ•≠Êó∂Èó¥ÈôçÂ∫èÊéíÊòØÊúÄ‰ºòÁöÑÂÖàÊéíÂ∫èÁÑ∂ÂêéÂ∞Ü‰∫∫ÊåâÈ°∫Â∫èÂàÜÂà∞‰∏§‰∏™Á™óÂè£ËøôÊ†∑Â∞±ÂèØ‰ª•dp‰∫Üf[i][j]Ë°®Á§∫ÂÆâÊéíÂÆåÁ¨¨i‰∏™‰∫∫ÔºåÁ¨¨‰∏ÄÈòüÁöÑÊéíÈòüÊó∂Èó¥‰∏∫jÔºåÁöÑÊúÄÂ∞èÂêÉÈ•≠Êó∂Èó¥sum[i]Ë°®Á§∫Ââçi‰∫∫ÁöÑÊéíÈòüÊó∂Èó¥Âíåf[i][j]=min(f[i][j],max(f[i-1][j],sum[i]-j+a[i].y)) (j=0 to sum[i-1])f[i][j]=min(f[i][j],max(f[i-1][j-a[i].x],j+a[i].x+a[i].y)) (j=a[i].x to sum[i])ËßÇÂØüÂà∞‰∏ä‰∏ã‰∏§‰∏™ÊñπÁ®ãÁöÑËåÉÂõ¥Ê≠£Â•ΩÂ∑Æ‰∏Ä‰∏™a[i].xÂèØ‰ª•ÂÉè01ËÉåÂåÖ‰∏ÄÊ†∑Âáè‰∏ÄÁª¥Â∞ÜjÈôçÂ∫èÈÅçÂéÜËøòÊúâ‰∏Ä‰∏™Êõ¥ÂéâÂÆ≥ÁöÑÂÅöÊ≥ïÈöèÊú∫Âåñ„ÄÇ„ÄÇÊó¢ÁÑ∂ÊòØÈöèÊú∫ÂåñÂ∞±ÊúâÈ£éÈô©ÈöèÊú∫ÂåñÊï∞ÁªÑÁî®Âà∞n+1Â∞±ËÉΩa‰∫ÜÔºà‰∏çÁÆ°Áî®‰∏çÁî®srand(time(0)))ÂºÄÂà∞n+10Â∞±‰ºöÂá∫Áé∞wa‰∫ÜÔºàÁî®‰∫Ü70Ôºå‰∏çÁî®80ÔºâÈöèÊú∫ÊúâÈ£éÈô©ÔºåËÄÉËØïÈúÄË∞®ÊÖé 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=208;int n;struct node&#123; int x,y;&#125;a[N];inline bool cmp(const node &amp;a,const node &amp;b)&#123; return a.y&gt;b.y;&#125;int f[N*N],sum[N];int ans=INT_MAX;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i].x=read();a[i].y=read(); &#125; sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;++i)&#123; sum[i]=sum[i-1]+a[i].x; &#125; memset(f,0x3f,sizeof(f)); f[0]=0; for(int i=0;i&lt;n;++i)&#123; for(int j=sum[i];j&gt;=0;--j)&#123; if(f[j]==0x3f3f3f3f) continue; f[j+a[i+1].x]=min(f[j+a[i+1].x],max(f[j],j+a[i+1].x+a[i+1].y)); f[j]=max(f[j],sum[i+1]-j+a[i+1].y); &#125; &#125; for(int j=0;j&lt;=sum[n];++j)&#123; ans=min(ans,f[j]); &#125; printf(&quot;%d&quot;,ans); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=208,lim=1e5;int n;int f[N];struct node&#123; int x,y;&#125;a[N];int s1,s2,t1,t2,ans=INT_MAX;inline bool cmp(const node &amp;a,const node &amp;b)&#123; return a.y&gt;b.y;&#125;int main()&#123; //srand(time(0)); n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i].x=read();a[i].y=read(); &#125; sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n+1;++i)&#123; f[i]=i; &#125; for(int k=1;k&lt;=lim;++k)&#123; random_shuffle(f+1,f+n+2); s1=0;s2=0;t1=0;t2=0; for(int i=1;i&lt;=n;++i)&#123; if(f[i]&amp;1)&#123; s1+=a[i].x; t1=max(t1,s1+a[i].y); &#125; else&#123; s2+=a[i].x; t2=max(t2,s2+a[i].y); &#125; &#125; ans=min(ans,max(t1,t2)); &#125; printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1169 [ZJOI2007]Ê£ãÁõòÂà∂‰Ωú]]></title>
    <url>%2F2018%2F04%2F14%2Fluogu1169%20%5BZJOI2007%5D%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[123Êï¥Âº†ÂõæÂèØ‰ª•ÈáçÊñ∞ÂàÜ‰∏∫‰∏§Á±ªÁÑ∂ÂêéÊÇ¨Á∫øÊ≥ïËß£ÂÜ≥ÊûÅÂ§ßÂ≠êÊ≠£ÊñπÂΩ¢ÂíåÊûÅÂ§ßÂ≠êÁü©Èòµ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=2008;int n,m,tmp;bool a[N][N];int h[N][N],l[N][N],r[N][N];int ans1,ans2;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; a[i][j]=read(); if((i+j)%2==0)&#123; a[i][j]^=1; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if(a[i][j]==0)&#123; h[i][j]=0; l[i][j]=0; &#125; else&#123; h[i][j]=h[i-1][j]+1; l[i][j]=l[i][j-1]+1; &#125; &#125; for(int j=m;j;--j)&#123; if(a[i][j]==0)&#123; r[i][j]=0; &#125; else&#123; r[i][j]=r[i][j+1]+1; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if(i&gt;1&amp;&amp;a[i-1][j]==1)&#123; l[i][j]=min(l[i][j],l[i-1][j]); r[i][j]=min(r[i][j],r[i-1][j]); &#125; tmp=min(h[i][j],l[i][j]+r[i][j]-1); ans1=max(ans1,tmp*tmp); ans2=max(ans2,h[i][j]*(l[i][j]+r[i][j]-1)); &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if(a[i][j]==1)&#123; h[i][j]=0; l[i][j]=0; &#125; else&#123; h[i][j]=h[i-1][j]+1; l[i][j]=l[i][j-1]+1; &#125; &#125; for(int j=m;j;--j)&#123; if(a[i][j]==1)&#123; r[i][j]=0; &#125; else&#123; r[i][j]=r[i][j+1]+1; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if(i&gt;1&amp;&amp;a[i-1][j]==0)&#123; l[i][j]=min(l[i][j],l[i-1][j]); r[i][j]=min(r[i][j],r[i-1][j]); &#125; tmp=min(h[i][j],l[i][j]+r[i][j]-1); ans1=max(ans1,tmp*tmp); ans2=max(ans2,h[i][j]*(l[i][j]+r[i][j]-1)); &#125; &#125; printf(&quot;%d\n%d&quot;,ans1,ans2); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1273 ÊúâÁ∫øÁîµËßÜÁΩë]]></title>
    <url>%2F2018%2F04%2F13%2Fluogu1273%20%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91%2F</url>
    <content type="text"><![CDATA[123456O(n^2)ÁöÑdpÊúâ‰∏Ä‰∏™ÈáçË¶ÅÁöÑÂú∞ÊñπÊØè‰∏™ÁÇπÁöÑÂæ™ÁéØÂ§ßÂ∞èÊòØÂÆÉÂ≠êÊ†ë‰∏≠Áî®Êà∑ËäÇÁÇπÁöÑ‰∏™Êï∞‰∏çÂä†‰∏äËøô‰∏™50ÂàÜÊØè‰∏§‰∏™ÁÇπÂè™‰ºöÂú®lca‰∫ßÁîüË¥°ÁåÆÊâÄ‰ª•n^2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=3008;int n,m;int x,y,z;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int f[N][N];inline int dfs(int x,int fa)&#123; if(x&gt;n-m)&#123; return 1; &#125; int tot=0; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa)&#123; tot+=dfs(e[i].to,x); for(int j=tot;j;--j)&#123; for(int k=j;k;--k)&#123; f[x][j]=max(f[x][j],f[e[i].to][k]+f[x][j-k]-e[i].f); &#125; &#125; &#125; &#125; return tot;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; f[i][j]=-0x3f3f3f3f; &#125; &#125; for(int i=1;i&lt;=n-m;++i)&#123; z=read(); while(z--)&#123; x=read();y=read(); addedge(i,x,y); addedge(x,i,y); &#125; &#125; for(int i=n-m+1;i&lt;=n;++i)&#123; x=read(); f[i][1]=x; &#125; dfs(1,0); for(int j=n;j&gt;=0;--j)&#123; if(f[1][j]&gt;=0)&#123; printf(&quot;%d&quot;,j); break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ê†ë‰∏ädp</tag>
        <tag>ËÉåÂåÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihocoder1063 Áº©Âú∞]]></title>
    <url>%2F2018%2F04%2F13%2Fhihocoder1063%20%E7%BC%A9%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[1234Âíåapple treeÂæàÂÉè‰ΩÜÊòØÊ≠•Êï∞ÁâπÂà´Â§ßÔºå‰∏çËÉΩ‰Ωú‰∏∫‰∏ÄÁª¥ÂèëÁé∞Êî∂ÁõäÁâπÂà´Â∞èÔºåÂ∞ÜÊî∂Áõä‰Ωú‰∏∫‰∏ÄÁª¥Èîô‰∫Ü‰∏ÄÊ¨°Âú®‰∫éÊï∞ÁªÑÂºÄÂ∞è‰∫Ü 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108;int n,a,b,w;int v[N];int ub;int q,d;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int f[N][N&lt;&lt;1][2];//Êï∞ÁªÑÂºÄÂ∞è‰∫ÜÔºÅÔºÅ //f[i][j][0]Ë°®Á§∫Âú®iÁöÑÂ≠êÊ†ëÈáå‰∫ßÁîüjÁöÑÊî∂ÁõäÔºå‰∏îÂõûÂà∞iÁÇπÁöÑÊúÄÂ∞ëÊ≠•Êï∞//f[i][j][1]Ë°®Á§∫Âú®iÁöÑÂ≠êÊ†ëÈáå‰∫ßÁîüjÁöÑÊî∂ÁõäÁöÑÊúÄÂ∞ëÊ≠•Êï∞ inline void dfs(int x,int fa)&#123; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa)&#123; dfs(e[i].to,x); for(int j=ub;j&gt;=1;--j)&#123; for(int k=j;k;--k)&#123; f[x][j][0]=min(f[x][j][0],f[e[i].to][k][0]+f[x][j-k][0]+2*e[i].f); f[x][j][1]=min(f[x][j][1],f[e[i].to][k][0]+f[x][j-k][1]+2*e[i].f); f[x][j][1]=min(f[x][j][1],f[e[i].to][k][1]+f[x][j-k][0]+e[i].f); //cout&lt;&lt;x&lt;&lt;&apos; &apos;&lt;&lt;e[i].to&lt;&lt;&apos; &apos;&lt;&lt;j&lt;&lt;&apos; &apos;&lt;&lt;k&lt;&lt;&apos; &apos;&lt;&lt;f[x][j][0]&lt;&lt;&apos; &apos;&lt;&lt;f[x][j][1]&lt;&lt;&apos; &apos;&lt;&lt;f[e[i].to][k][0]&lt;&lt;&apos; &apos;&lt;&lt;f[i][j-k][0]&lt;&lt;&apos;\n&apos;; &#125; &#125; &#125; &#125;&#125;int main()&#123; memset(f,0x3f,sizeof(f)); n=read(); for(int i=1;i&lt;=n;++i)&#123; v[i]=read(); f[i][v[i]][0]=f[i][v[i]][1]=0; ub+=v[i]; &#125; for(int i=1;i&lt;n;++i)&#123; a=read();b=read();w=read(); addedge(a,b,w); addedge(b,a,w); &#125; dfs(1,0); q=read(); while(q--)&#123; d=read(); for(int j=ub;j&gt;=0;--j)&#123; if(f[1][j][1]&lt;=d)&#123; printf(&quot;%d\n&quot;,j); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ê†ë‰∏ädp</tag>
        <tag>ËÉåÂåÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2014 ÈÄâËØæ]]></title>
    <url>%2F2018%2F04%2F12%2Fluogu2014%20%E9%80%89%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[123ÂÅöÂÆåapple tree‰ª•ÂêéËøôÈ¢òÂ∞±ÂæàÁÆÄÂçïÂï¶f[i][j]Ë°®Á§∫iÁöÑÂ≠êÊ†ë‰∏≠ÈÄâj‰∏™ËØæÁ®ãÁöÑÊúÄÂ§ßÂ≠¶ÂàÜ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=308;int n,m;int fa;int nume,head[N];struct node&#123; int to,nxt;&#125;e[N];inline void addedge(int x,int y)&#123; e[++nume]=(node)&#123;y,head[x]&#125;;head[x]=nume;&#125;int f[N][N];inline void dfs(int x)&#123; for(int i=head[x];i;i=e[i].nxt)&#123; dfs(e[i].to); for(int j=m;j;--j)&#123; for(int k=1;k&lt;j;++k)&#123; f[x][j]=max(f[x][j],f[e[i].to][k]+f[x][j-k]); &#125; &#125; &#125;&#125;int main()&#123; n=read();m=read();++m; for(int i=1;i&lt;=n;++i)&#123; fa=read();f[i][1]=read(); addedge(fa,i); &#125; dfs(0); printf(&quot;%d&quot;,f[0][m]); return 0;&#125;]]></content>
      <tags>
        <tag>Ê†ë‰∏ädp</tag>
        <tag>ËÉåÂåÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2486 Apple Tree]]></title>
    <url>%2F2018%2F04%2F12%2Fpoj2486%20Apple%20Tree%2F</url>
    <content type="text"><![CDATA[12345678910Â•Ω‰πÖÊ≤°ÂÜôÊ†ë‰∏ädpÂíåËÉåÂåÖ‰∫ÜÁúã‰∫ÜÂ•Ω‰πÖÈ¢òËß£ÊØè‰∏™ÁÇπÊùÉÈÉΩÊòØÈùûË¥üÁöÑÊâÄ‰ª•Â§ö‰ΩôÁöÑÊ≠•Êï∞Ëµ∞‰∫Ü‰πü‰∏ç‰ºö‰ΩøÁ≠îÊ°àÂèòÂ∑ÆÊØè‰∏ÄÊ≠•ÂèØ‰ª•ÈÄâÊã©ÂÅúÂú®ÂéüÂú∞‰∏çÂä®f[i][j][0]Ë°®Á§∫Âú®ËäÇÁÇπiÁöÑÂ≠êÊ†ë‰∏≠Ëµ∞jÊ≠•Ôºå‰∏îÊúÄÁªàÂõûÂà∞iÁöÑÊúÄÂ§ßÊî∂Áõäf[i][j][1]Ë°®Á§∫Âú®ËäÇÁÇπiÁöÑÂ≠êÊ†ë‰∏≠Ëµ∞jÊ≠•ÁöÑÊúÄÂ§ßÊî∂ÁõäÂõ†‰∏∫‰∏Ä‰∏™Â≠êÊ†ëÈáçÂ§çËøõÂéªÊòØÊ≤°ÊúâÊî∂ÁõäÁöÑÊâÄ‰ª•Áõ∏ÂΩì‰∫é‰∏Ä‰∏™01ËÉåÂåÖjË¶Å‰ªéÂ§ßÂà∞Â∞èÊûö‰∏æ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108,K=208;int n,k,u,v;int w[N];int nume,head[N];struct node&#123; int to,nxt;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y)&#123; e[++nume]=(node)&#123;y,head[x]&#125;;head[x]=nume;&#125;int f[N][K][2];//f[i][j][0]Ë°®Á§∫Âú®ËäÇÁÇπiÁöÑÂ≠êÊ†ë‰∏≠Ëµ∞jÊ≠•Ôºå‰∏îÊúÄÁªàÂõûÂà∞iÁöÑÊúÄÂ§ßÊî∂Áõä//f[i][j][1]Ë°®Á§∫Âú®ËäÇÁÇπiÁöÑÂ≠êÊ†ë‰∏≠Ëµ∞jÊ≠•ÁöÑÊúÄÂ§ßÊî∂Áõä //Â§ö‰ΩôÁöÑÊ≠•Êï∞Âπ∂‰∏çÂΩ±ÂìçÁ≠îÊ°àÔºåÊØè‰∏ÄÊ≠•ÂèØ‰ª•ÈÄâÊã©ÂÅúÂú®ÂéüÂú∞‰∏çÂä® inline void dfs(int x,int fa)&#123; for(int j=0;j&lt;=k;++j) f[x][j][0]=f[x][j][1]=w[x]; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa)&#123; dfs(e[i].to,x); for(int j=k;j&gt;=1;--j)&#123; for(int kk=j-1;kk&gt;=0;--kk)&#123;//‰ªéÂ∞èÂà∞Â§ßÂíå‰ªéÂ§ßÂà∞Â∞èÊòØÊ≤°ÊúâÂΩ±ÂìçÁöÑ if(j-kk&gt;=2)&#123; f[x][j][0]=max(f[x][j][0],f[e[i].to][kk][0]+f[x][j-kk-2][0]); f[x][j][1]=max(f[x][j][1],f[e[i].to][kk][0]+f[x][j-kk-2][1]); &#125; f[x][j][1]=max(f[x][j][1],f[e[i].to][kk][1]+f[x][j-kk-1][0]); &#125; &#125; &#125; &#125;&#125;int main()&#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF)&#123; nume=1; memset(head,0,sizeof(head)); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;w[i]); &#125; for(int i=1;i&lt;n;++i)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v); addedge(v,u); &#125; dfs(1,0); printf(&quot;%d\n&quot;,f[1][k][1]);//‰∏Ä‰∏™‰ºòÁßÄÁöÑÁ≠îÊ°àÊÄªÊòØ‰∏ç‰ºöÂõûÂÆ∂ÁöÑ &#125; return 0;&#125; 1234ËøòÊúâ‰∏ÄÁßçÂÜôÊ≥ï‰∏çÂêàÊ≥ïÁöÑÊÉÖÂÜµÁõ¥Êé•‰∏∫0ËµãÂàùÂÄºÁöÑËØùÂè™Êúâf[i][0][0]Âíåf[i][0][1]ÊúÄÂêéÂú®ÊâÄÊúâÊ≠•Êï∞ÈáåÈù¢ÂèñmaxÂ∞±ÂèØ‰ª•‰∫Ü 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108,K=208;int n,k,u,v;int w[N];int ans;int nume,head[N];struct node&#123; int to,nxt;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y)&#123; e[++nume]=(node)&#123;y,head[x]&#125;;head[x]=nume;&#125;int f[N][K][2];inline void dfs(int x,int fa)&#123; //for(int j=0;j&lt;=k;++j) f[x][j][0]=f[x][j][1]=w[x]; f[x][0][0]=f[x][0][1]=w[x]; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa)&#123; dfs(e[i].to,x); for(int j=k;j&gt;=1;--j)&#123; for(int kk=j-1;kk&gt;=0;--kk)&#123; if(j-kk&gt;=2)&#123; f[x][j][0]=max(f[x][j][0],f[e[i].to][kk][0]+f[x][j-kk-2][0]); f[x][j][1]=max(f[x][j][1],f[e[i].to][kk][0]+f[x][j-kk-2][1]); &#125; f[x][j][1]=max(f[x][j][1],f[e[i].to][kk][1]+f[x][j-kk-1][0]); &#125; &#125; &#125; &#125;&#125;int main()&#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF)&#123; nume=1; memset(head,0,sizeof(head)); memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;w[i]); &#125; for(int i=1;i&lt;n;++i)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v); addedge(v,u); &#125; dfs(1,0); //printf(&quot;%d\n&quot;,f[1][k][1]); ans=0; for(int j=0;j&lt;=k;++j)&#123; ans=max(ans,f[1][j][1]); &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Ê†ë‰∏ädp</tag>
        <tag>ËÉåÂåÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2805 [NOI2009]Ê§çÁâ©Â§ßÊàòÂÉµÂ∞∏]]></title>
    <url>%2F2018%2F04%2F11%2Fluogu2805%20%5BNOI2009%5D%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%2F</url>
    <content type="text"><![CDATA[123456789101112131415ÈÄâÊüê‰∏™Ê§çÁâ©Â∞±Ë¶ÅÈÄâ‰øùÊä§ÂÆÉÁöÑÊâÄÊúâÊ§çÁâ©ÂÖ∏ÂûãÁöÑÊúÄÂ§ßÊùÉÈó≠ÂêàÂ≠êÂõæÊÑâÂø´ÁöÑÊâìÂÆå‰∫Ü‰∏ÄÊµãÊ†∑‰æã225?ÂèëÁé∞Âá∫Áé∞‰∫Ü‰∏Ä‰∏™ÁéØÔºàËâØÂøÉÊ†∑‰æã‰∏çÂ§öËßÅ‰∫ÜÔºâÊÄé‰πàÂéªÊéâÁéØÂë¢tarjan?ÂèëÁé∞ÁéØËøûÂá∫ÂéªÁöÑÁÇπÈÉΩÁõ∏ÂΩì‰∫éÊó†ÊïåÁöÑÊâÄ‰ª•Âì™‰∫õÁÇπÊòØÂèØ‰ª•Ë¢´ÊîªÂáªÁöÑÂë¢ÊêúÁ¥¢ÔºÅÂèëÁé∞Â•áÊÄ™ÁöÑÊÄßË¥®„ÄÇ„ÄÇËøôÊòØtopsort!ÊÑâÂø´ÁöÑÊãìÊâë‰∏ÄÈÅçÔºåÁÑ∂ÂêéÈáçÂª∫ËæπÂÜçdinicË∑ë‰∏ÄÈÅç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=608;int n,m;int v[N],d[N];int x,y,z;int s,t;int ans;inline int getid(int x,int y)&#123; return (x-1)*m+y;&#125;int nume,head[N],cur[N],headx[N];struct node&#123; int to,nxt,f;&#125;e[N*N*4],ex[N*N];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;inline void insert(int x,int y)&#123; ++d[y]; ex[++nume]=(node)&#123;y,headx[x]&#125;;headx[x]=nume;&#125;bool del[N];int q[N],he,ta;inline void topsort()&#123; for(int i=1;i&lt;=n*m;++i)&#123; if(!d[i]) q[++ta]=i; else del[i]=1; &#125; while(ta)&#123; int x=q[ta];del[x]=0; --ta; for(int i=headx[x];i;i=ex[i].nxt)&#123; --d[ex[i].to]; if(!d[ex[i].to]) q[++ta]=ex[i].to; &#125; &#125;&#125;inline void rebuild()&#123; nume=1; s=0;t=n*m+1; for(int i=1;i&lt;=n*m;++i)&#123; if(!del[i])&#123; if(v[i]&gt;0)&#123; ans+=v[i]; addedge(s,i,v[i]); &#125; else&#123; addedge(i,t,-v[i]); &#125; for(int j=headx[i];j;j=ex[j].nxt)&#123; if(!del[ex[j].to])&#123; addedge(ex[j].to,i,INT_MAX); &#125; &#125; &#125; &#125;&#125;int dis[N];inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=s;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; v[getid(i,j)]=read(); z=read(); while(z--)&#123; x=read();y=read(); ++x;++y; insert(getid(i,j),getid(x,y)); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=2;j&lt;=m;++j)&#123; insert(getid(i,j),getid(i,j-1)); &#125; &#125; topsort(); rebuild(); ans-=dinic(); printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>ÁΩëÁªúÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2396 yyy loves Maths VII]]></title>
    <url>%2F2018%2F04%2F11%2Fluogu2396%20yyy%20loves%20Maths%20VII%2F</url>
    <content type="text"><![CDATA[123456ÂæàÊòéÊòæÁöÑÁä∂ÂéãÁúã‰∏äÂéªÊå∫Âç°Êó∂Èó¥ÁöÑÂÆûÈôÖ‰πüÂæàÂç°Êó∂Èó¥ÂºÄ‰∫ÜO2ÊâçËøáÊáíÂæó‰ºòÂåñ‰∫ÜO(2^n*n)Ëøá24 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=25,mod=1000000007;int n,m;int b[3];int dis[1&lt;&lt;24],f[1&lt;&lt;24];int ub;int main()&#123; n=read(); for(int i=0;i&lt;n;++i)&#123; dis[1&lt;&lt;i]=read(); &#125; m=read(); for(int i=1;i&lt;=m;++i)&#123; b[i]=read(); &#125; ub=1&lt;&lt;n; f[0]=1; for(int i=1;i&lt;ub;++i)&#123; int j=i&amp;-i,k=i; dis[i]=dis[i^j]+dis[j]; if(dis[i]==b[1]||dis[i]==b[2]) continue; while(k)&#123; f[i]+=f[i^j]; if(f[i]&gt;=mod) f[i]-=mod; k^=j; j=k&amp;-k; &#125; &#125; printf(&quot;%d&quot;,f[ub-1]); return 0;&#125;]]></content>
      <tags>
        <tag>Áä∂Âéã</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2114 [NOI2014]Ëµ∑Â∫äÂõ∞ÈöæÁªºÂêàÁóá]]></title>
    <url>%2F2018%2F04%2F11%2Fluogu2114%20%5BNOI2014%5D%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87%2F</url>
    <content type="text"><![CDATA[12345Ë¥™ÂøÉ‰ªéÈ´òÂà∞‰ΩéÊØè‰∏Ä‰ΩçËÄÉËôëÊîæ0ËøòÊòØ10ËÉΩÈÄ†Êàê‰º§ÂÆ≥Â∞±Êîæ0Âê¶ÂàôÔºå1ËÉΩÈÄ†ÊàêÂ∞±Êîæ1Âê¶ÂàôÔºå‰∏çÊîæ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m,maxi,ans;char s[5];struct node&#123; int type,x; inline int calc(const int &amp;y)&#123; if(type==0)&#123; return x|y; &#125; else if(type==1)&#123; return x&amp;y; &#125; else&#123; return x^y; &#125; &#125;&#125;a[N];inline int solve(int x)&#123; for(int i=1;i&lt;=n;++i)&#123; x=a[i].calc(x); &#125; return x;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s); if(s[0]==&apos;O&apos;)&#123; a[i].type=0; &#125; else if(s[0]==&apos;A&apos;)&#123; a[i].type=1; &#125; else&#123; a[i].type=2; &#125; a[i].x=read(); &#125; for(maxi=1;maxi&lt;=m;maxi&lt;&lt;=1); for(maxi&gt;&gt;=1;maxi;maxi&gt;&gt;=1)&#123; if(solve(0)&amp;maxi)&#123; continue; &#125; if((ans^maxi)&lt;=m&amp;&amp;(solve(maxi)&amp;maxi))&#123; ans^=maxi; &#125; &#125; printf(&quot;%d&quot;,solve(ans)); return 0;&#125;]]></content>
      <tags>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1580 yyy loves Easter_Egg I]]></title>
    <url>%2F2018%2F04%2F11%2Fluogu1580%20yyy%20loves%20Easter_Egg%20I%2F</url>
    <content type="text"><![CDATA[1234ÂùëÂú®‰∫éËæìÂÖ•windows‰∏ãÊØèË°åÁªìÊùüÊúâ‰∏§‰∏™Â≠óÁ¨¶Ôºå‰∏∫\rÂíå\nlinux‰∏ãÂè™Êúâ\n‰ª•ÂèäË¢´Èí¶ÁÇπÁöÑ‰∫∫Âè™Ë¶ÅÂê±Â£∞Â∞±ÁÆóÊàêÂäüÊ≤πÁÇ∏Ôºå‰∏çÁÆ°‰ªñÊòØ‰∏çÊòØ@Ëá™Â∑± 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;int n,num,cnt;string s,name,name2;inline string get(int x)&#123; string tmp=&quot;&quot;; for(int i=x;;++i)&#123; if(s[i]==&apos;\0&apos;||s[i]==&apos; &apos;)&#123; return tmp; &#125; tmp+=s[i]; &#125;&#125;inline string get_at_name()&#123; for(int i=0;i&lt;n;++i)&#123; if(s[i]==&apos;@&apos;)&#123; return get(i+11); &#125; &#125;&#125;inline string get_his_name()&#123; return get(10);&#125;int main()&#123; getline(cin,s,&apos;\r&apos;);getchar();//getchar()Â§ÑÁêÜÊéâ&apos;\n&apos; ++num; n=s.size(); name=get_at_name(); while(1)&#123; getline(cin,s,&apos;\r&apos;);getchar(); if(s==&quot;&quot;)&#123; break; &#125; ++num; n=s.size(); cnt=0; for(int i=0;i&lt;n;++i)&#123; if(s[i]==&apos;@&apos;)&#123; ++cnt; &#125; &#125; name2=get_his_name(); if(name2==name)&#123; cout&lt;&lt;&quot;Successful @yyy loves &quot;&lt;&lt;name&lt;&lt;&quot; attempt\n&quot;; &#125; if(cnt!=1||name!=get_at_name())&#123; cout&lt;&lt;&quot;Unsuccessful @yyy loves &quot;&lt;&lt;name&lt;&lt;&quot; attempt\n&quot;; cout&lt;&lt;num&lt;&lt;&apos;\n&apos;; cout&lt;&lt;&quot;yyy loves &quot;&lt;&lt;name2&lt;&lt;&apos;\n&apos;; return 0; &#125; &#125; cout&lt;&lt;&quot;Unsuccessful @yyy loves &quot;&lt;&lt;name&lt;&lt;&quot; attempt\n&quot;; cout&lt;&lt;num&lt;&lt;&apos;\n&apos;; puts(&quot;Good Queue Shape&quot;); return 0;&#125;]]></content>
      <tags>
        <tag>Ê®°Êãü</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2987 Firing]]></title>
    <url>%2F2018%2F04%2F10%2Fpoj2987%20Firing%2F</url>
    <content type="text"><![CDATA[12345ÊúÄÂ§ßÊùÉÈó≠ÂêàÂ≠êÂõæÊúÄÂ∞èÂâ≤‰∏ÄÂÆöÊòØÁÆÄÂçïÂâ≤ÔºåÂç≥Âè™Ââ≤‰∏ésÊàñtÁõ∏ËøûÁöÑËæπÂú®poj‰∫§ceÔºå&apos;LONG_LONG_MAX&apos; was not declared in this scopeÔºå‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πàÊîπÊàêINFÂ∞±Ëøá‰∫ÜÁî®C++ÁºñËØë‰ºöceÔºåG++ÊâçËÉΩËøá„ÄÇ„ÄÇ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=5008,M=60008;const LL INF=1e16;int n,m,u,v;int s,t;int b[N];int num;LL ans;int nume=1,head[N],cur[N];struct node&#123; int to,nxt; LL f;&#125;e[M*2+N*2];inline void addedge(int x,int y,LL z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[N];int q[N],he,ta;inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline LL dfs(int x,LL low)&#123; if(x==t||!low) return low; LL flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline LL dinic()&#123; LL maxflow=0; while(bfs())&#123; for(int i=s;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INF); &#125; return maxflow;&#125;bool vis[N];inline void calc(int x)&#123; vis[x]=1; ++num; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!vis[e[i].to])&#123; calc(e[i].to); &#125; &#125;&#125;int main()&#123; n=read();m=read(); s=0;t=n+1; for(int i=1;i&lt;=n;++i)&#123; b[i]=read(); if(b[i]&lt;0)&#123; addedge(i,t,-b[i]); addedge(t,i,0); &#125; else&#123; ans+=b[i]; addedge(s,i,b[i]); addedge(i,s,0); &#125; &#125; for(int i=1;i&lt;=m;++i)&#123; u=read();v=read(); addedge(u,v,INF); addedge(v,u,0); &#125; ans-=dinic(); calc(s); printf(&quot;%d %lld&quot;,num-1,ans); return 0;&#125;]]></content>
      <tags>
        <tag>ÁΩëÁªúÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uva1515 pool construction]]></title>
    <url>%2F2018%2F04%2F10%2Fuva1515%20pool%20construction%2F</url>
    <content type="text"><![CDATA[123456Âª∫ÂõæÂæàÂ¶ôÂïäÊúÄÂ∞èÂâ≤ÁöÑÂ∫îÁî®Ê≥®ÊÑèÊâÄÊúâÁõ∏ÈÇªÁöÑÊ†ºÂ≠êÈÉΩË¶ÅËøûËæπÂè™Ë¶ÅÁõ∏ÈÇªÁöÑÊ†ºÂ≠êÊâÄÂ±ûÁöÑÈõÜÂêà‰∏çÂêåÔºåËøôÊù°ËæπÂ∞±Ë¶ÅË¢´Ââ≤ÊéâÊ≥®ÊÑè‰∏çË¶ÅÊâìÈîôÂèòÈáèÂêçÔºàÂú®vjudge‰∏äÁöÑ‰∏§‰∏™oj‰∫§a‰∫ÜÔºåËøòÊúâ‰∏Ä‰∏™oj‰∏ämleÔºåÂ∞ÜÁ©∫Èó¥Áº©Â∞èÂà∞1/4Â∞±a‰∫ÜÔºåÂæàËø∑Ôºâ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=2508;int T;int w,h,d,f,b;int s,t,x,y;int ans;char c,a[58][58];int nume,head[N],cur[N];struct node&#123; int to,nxt,f;&#125;e[N*N*4];int dx[2]=&#123;0,1&#125;,dy[2]=&#123;1,0&#125;,tx,ty;inline int getid(int x,int y)&#123; return (x-1)*w+y;&#125;inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[N];int q[N],he,ta;inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=s;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int main()&#123; T=read(); while(T--)&#123; ans=0; nume=1; memset(head,0,sizeof(head)); w=read();h=read(); s=0;t=w*h+1; d=read();f=read();b=read(); for(int i=1;i&lt;=h;++i)&#123; for(int j=1;j&lt;=w;++j)&#123; c=getchar(); while(c!=&apos;.&apos;&amp;&amp;c!=&apos;#&apos;) c=getchar(); a[i][j]=c; if((i==1||i==h||j==1||j==w))&#123; if(a[i][j]==&apos;.&apos;)&#123; a[i][j]=&apos;#&apos;; ans+=f; &#125; x=getid(i,j); addedge(s,x,INT_MAX); addedge(x,s,0); &#125; &#125; &#125; for(int i=1;i&lt;h;++i)&#123; for(int j=1;j&lt;w;++j)&#123; x=getid(i,j); if(i!=1&amp;&amp;j!=1)&#123; if(a[i][j]==&apos;#&apos;)&#123; addedge(s,x,d); addedge(x,s,0); &#125; else&#123; addedge(x,t,f); addedge(t,x,0); &#125; &#125; for(int k=0;k&lt;2;++k)&#123; tx=i+dx[k]; ty=j+dy[k]; if(tx&lt;1||tx&gt;h||ty&lt;1||ty&gt;w) continue; y=getid(tx,ty); addedge(x,y,b); addedge(y,x,b); &#125; &#125; &#125; printf(&quot;%d\n&quot;,ans+dinic()); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ÁΩëÁªúÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2766 ÊúÄÈïø‰∏ç‰∏ãÈôçÂ≠êÂ∫èÂàóÈóÆÈ¢ò]]></title>
    <url>%2F2018%2F04%2F09%2Fluogu2766%20%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[123456789Á¨¨‰∏ÄÈóÆlisÁ¨¨‰∫åÈóÆÂíåÁ¨¨‰∏âÈóÆÈÉΩÊòØÁΩëÁªúÊµÅÁ¨¨‰∫åÈóÆÁöÑÂª∫ÂõæÔºös - 1 - i (f[i]==1)i - 1 - i&apos;i&apos; - 1 - j (f[i]+1==f[j]&amp;&amp;a[i]&lt;=a[j]&amp;&amp;i&lt;j)i&apos; - 1 - t (f[i]==ans)Á¨¨‰∏âÈóÆÂè™Ë¶ÅÊää(s,1),(1,1&apos;),(n,n&apos;),(n&apos;,t)ÁöÑÊµÅÈáèÊîπÊàêINF82ÂàÜÁöÑÂéüÂõ†ÊòØÂä†ËæπÁöÑÊó∂ÂÄôÂøòËÆ∞Âà§a[i]&gt;=a[j] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=508;int n,s,t,tmp;int a[N];int f[N],lis[N],num;int ans;int nume=1,head[N*2],cur[N*2];struct node&#123; int to,nxt,f;&#125;e[N*N*2];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;int dis[N*2];int q[N*2],he,ta;inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=0;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;inline void init()&#123; for(int i=0;i&lt;=t;++i)&#123; for(int j=head[i];j;j=e[j].nxt)&#123; if(j%2==0)&#123; if((i==0&amp;&amp;e[j].to==1) || (i==1&amp;&amp;e[j].to==1+n) || (i==n&amp;&amp;e[j].to==n+n) || (i==n+n&amp;&amp;e[j].to==t))&#123; e[j].f=INT_MAX; e[j^1].f=0; &#125; else&#123; e[j].f+=e[j^1].f; e[j^1].f=0; &#125; &#125; &#125; &#125;&#125;int main()&#123; n=read(); s=0;t=n+n+1; for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;=n;++i)&#123; if(a[i]&gt;=lis[num])&#123; lis[++num]=a[i]; f[i]=num; &#125; else&#123; tmp=upper_bound(lis+1,lis+num+1,a[i])-lis; lis[tmp]=a[i]; f[i]=tmp; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; ans=max(ans,f[i]); &#125; printf(&quot;%d\n&quot;,ans); for(int i=1;i&lt;=n;++i)&#123; addedge(i,i+n,1); if(f[i]==1) addedge(s,i,1); if(f[i]==ans) addedge(i+n,t,1); for(int j=1;j&lt;i;++j)&#123; if(f[i]==f[j]+1&amp;&amp;a[i]&gt;=a[j])&#123; addedge(j+n,i,1); &#125; &#125; &#125; printf(&quot;%d\n&quot;,dinic()); init(); printf(&quot;%d\n&quot;,dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>ÁΩëÁªúÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2774 ÊñπÊ†ºÂèñÊï∞ÈóÆÈ¢ò]]></title>
    <url>%2F2018%2F04%2F09%2Fluogu2774%20%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1234567ÂØπÊúÄÂ∞èÂâ≤ËøòÊòØ‰∏çÁÜüÁ≠îÊ°à‰∏∫ÊâÄÊúâÁöÑÂÄºÂáèÂéªÊéâÁöÑÊúÄÂ∞èÂÄº„ÄÇÂéªÊéâÁöÑÂéüÂõ†ÊòØÁõ∏ÈÇªÊ†ºÂ≠ê‰∏çËÉΩÂêåÊó∂Âèñ„ÄÇÈªëÁôΩÊüìËâ≤Ôºå‰πüÂ∞±ÊòØË¶Å‰πà‰∏çÂèñÈªëÔºåË¶Å‰πà‰∏çÂèñÁôΩÁõ∏ÈÇªÁöÑËøûËæπ s - black&apos;s key - black - INF - white - white&apos;s key - tÈÇ£ÊúÄÂ∞èÂâ≤Â∞±ÊòØÂéªÊéâÁöÑÊúÄÂ∞èÂÄº64ÂàÜÁöÑÈîôËØØÂéüÂõ†ÊòØÁî®uÁöÑÂ•áÂÅ∂ÊÄßÂà§Êñ≠ÈªëÁôΩ‰∫Ü 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108;int n,m,u,v,s,t;int a[N][N];int dx[4]=&#123;-1,0,0,1&#125;,dy[4]=&#123;0,-1,1,0&#125;,tx,ty;LL ans;inline int getid(int x,int y)&#123; return (x-1)*m+y;&#125;int nume=1,head[N*N],cur[N*N];struct node&#123; int to,nxt,f;&#125;e[N*N*4];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;int dis[N*N];int q[N*N],he,ta;inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125; inline LL dinic()&#123; LL maxflow=0; while(bfs())&#123; for(int i=0;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int main()&#123; n=read();m=read(); s=0;t=n*m+1; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; a[i][j]=read(); ans+=a[i][j]; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; u=getid(i,j); if((i+j)%2==0)&#123; addedge(s,u,a[i][j]); for(int k=0;k&lt;4;++k)&#123; tx=i+dx[k]; ty=j+dy[k]; if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;m) continue; v=getid(tx,ty); addedge(u,v,INT_MAX); &#125; &#125; else&#123; addedge(u,t,a[i][j]); &#125; &#125; &#125; printf(&quot;%lld&quot;,ans-dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>ÁΩëÁªúÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2763 ËØïÈ¢òÂ∫ìÈóÆÈ¢ò]]></title>
    <url>%2F2018%2F04%2F09%2Fluogu2763%20%E8%AF%95%E9%A2%98%E5%BA%93%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1Âü∫Á°ÄÁΩëÁªúÊµÅÔºå‰∏çË¶ÅÊâìÈîôÂèòÈáèÂêçÔºÅÔºÅ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int K=28,N=1008;int n,m,k,p,tmp;int s,t;int req[K];int ans;int nume=1,head[N+K],cur[N+K];struct node&#123; int to,nxt,f;&#125;e[N*K*2];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;int dis[N+K];int he,ta,q[N+K];inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=0;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;vector&lt;int&gt; plan[K];inline void print()&#123; for(int i=1;i&lt;=n;++i)&#123; for(int j=head[i];j;j=e[j].nxt)&#123; if(j%2==0&amp;&amp;e[j].f==0)&#123;//i/j plan[e[j].to-n].pb(i);//i/j break; &#125; &#125; &#125; for(int i=1;i&lt;=k;++i)&#123; printf(&quot;%d:&quot;,i); for(int j=0;j&lt;plan[i].size();++j)&#123; printf(&quot; %d&quot;,plan[i][j]); &#125; puts(&quot;&quot;); &#125;&#125;int main()&#123; k=read();n=read(); s=0;t=n+k+1; for(int i=1;i&lt;=k;++i)&#123; req[i]=read(); addedge(i+n,t,req[i]); m+=req[i]; &#125; for(int i=1;i&lt;=n;++i)&#123; addedge(s,i,1); p=read(); for(int j=1;j&lt;=p;++j)&#123; tmp=read(); addedge(i,tmp+n,1); &#125; &#125; ans=dinic(); if(ans!=m)&#123; puts(&quot;No Solution!&quot;); &#125; else&#123; print(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ÁΩëÁªúÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2765È≠îÊúØÁêÉÈóÆÈ¢ò]]></title>
    <url>%2F2018%2F04%2F08%2Fluogu2765%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[12345Ê≠£Á°ÆÁöÑÂÅöÊ≥ïÊòØÁΩëÁªúÊµÅËã•i+j‰∏∫Âπ≥ÊñπÊï∞(i&lt;j), i - 1 - jËΩ¨ÂåñÊàêÊúÄÂ∞èË∑ØÂæÑË¶ÜÁõñÂΩìÊúÄÂ∞èË∑ØÂæÑË¶ÜÁõñ&gt;nÊó∂ÔºåÂâç‰∏Ä‰∏™‰∏∫Á≠îÊ°àËÆ∞ÂæóÂú®‰∏ä‰∏ÄÊ¨°ÁöÑÊÆã‰ΩôÁΩëÁªúÈáåË∑ëÔºå‰∏çÁî®Ê∏ÖÁ©∫ÊµÅÈáè 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=3508;int n,s,t;int ans;int nume=1,head[N],cur[N];struct node&#123; int to,nxt,f;&#125;e[N*N];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],z&#125;;head[y]=nume;&#125;int q[N],he,ta;int dis[N];inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;e[i].f&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic(int x)&#123; int maxflow=0; while(bfs())&#123; cur[0]=head[0]; cur[t]=head[t]; for(int i=1;i&lt;=x;++i)&#123; cur[i]=head[i]; cur[i+1700]=head[i+1700]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int nxt[N],d[N];inline void print(int x)&#123; for(int u=1;u&lt;=x;++u)&#123; for(int i=head[u];i;i=e[i].nxt)&#123; if(i%2==0&amp;&amp;e[i].f==0)&#123; nxt[u]=e[i].to-1700; ++d[e[i].to-1700]; break; &#125; &#125; &#125; for(int u=1;u&lt;=x;++u)&#123; if(d[u]) continue; int i=u; while(i)&#123; printf(&quot;%d &quot;,i); i=nxt[i]; &#125; puts(&quot;&quot;); &#125;&#125; bool vis[4000];int main()&#123; for(int i=1;i&lt;=60;++i)&#123; vis[i*i]=1; &#125; n=read(); s=0;t=3500; for(int i=1;;++i)&#123; addedge(s,i,1); addedge(1700+i,t,1); for(int j=i-1;j;--j)&#123; if(vis[j+i])&#123; addedge(j,1700+i,1); &#125; &#125; ans+=dinic(i); if(i-ans&gt;n)&#123; printf(&quot;%d\n&quot;,i-1); print(i-1); return 0; &#125; &#125; return 0;&#125; 123Ë¥™ÂøÉ‰∏çÁü•ÈÅìÂ¶Ç‰ΩïËØÅÊòéË¥™ÂøÉÊ≠£Á°Æ‰∏™‰∫∫ËÆ§‰∏∫ÂΩìnÁâπÂà´Â§ßÊó∂ËÉΩÂç°ÊéâË¥™ÂøÉ]]></content>
      <tags>
        <tag>ÁΩëÁªúÊµÅ</tag>
        <tag>Ë¥™ÂøÉ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2764ÊúÄÂ∞èË∑ØÂæÑË¶ÜÁõñÈóÆÈ¢ò]]></title>
    <url>%2F2018%2F04%2F08%2Fluogu2764%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1234n‰∏™ÁÇπÂ∞±ÊòØnÊù°Ë∑ØÂæÑs-1-x- [ÊúâËæπ]*1 -y - 1 -tÊØèÊ¨°Â∞Ü‰∏§‰∏™ÁÇπËøûÂú®‰∏ÄËµ∑Â∞±ÂáèÂ∞ë1Êù°ËæπÔºåÂ¢ûÂä†1ÁÇπÊµÅÈáèÊâÄ‰ª•ÊúÄÂ∞èË∑ØÂæÑÊï∞=n-ÊúÄÂ§ßÊµÅ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=308,M=6008; int n,m,u,v,s,t,ans;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[M*2+N*4];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;int cur[N],dis[N];int he,ta,q[N];inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp;//¬¥√≤¬¥√≠+- if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow; &#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=0;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int nxt[N],ind[N];inline void print()&#123; /*for(u=0;u&lt;=t;++u)&#123; cout&lt;&lt;&quot;!!&quot;&lt;&lt;u&lt;&lt;&apos;\n&apos;; for(int i=head[u];i;i=e[i].nxt)&#123; cout&lt;&lt;e[i].to&lt;&lt;&apos; &apos;&lt;&lt;e[i].f&lt;&lt;&apos;\n&apos;; &#125; &#125;*/ for(u=1;u&lt;=n;++u)&#123; for(int i=head[u];i;i=e[i].nxt)&#123; if(i%2==0&amp;&amp;e[i].to&gt;n&amp;&amp;e[i].f==0)&#123; nxt[u]=e[i].to-n; ++ind[e[i].to-n]; &#125; &#125; &#125; for(u=1;u&lt;=n;++u)&#123; if(!ind[u])&#123; v=u; while(v)&#123; printf(&quot;%d &quot;,v); v=nxt[v]; &#125; puts(&quot;&quot;); &#125; &#125;&#125;int main()&#123; nume=1; n=read();m=read(); s=0;t=n+n+1; for(int i=1;i&lt;=m;++i)&#123; u=read();v=read(); addedge(u,n+v,1); &#125; for(int i=1;i&lt;=n;++i)&#123; addedge(s,i,1); addedge(n+i,t,1); &#125; ans=dinic(); print(); printf(&quot;%d&quot;,n-ans); return 0;&#125;]]></content>
      <tags>
        <tag>ÁΩëÁªúÊµÅ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÈîôËØØ]]></title>
    <url>%2F2018%2F04%2F08%2F%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[Èâ¥‰∫éÁúÅÈÄâÁ¨¨‰∏ÄËΩÆÂ∑≤ÁªèÊªöÁ≤ó‰∫Ü„ÄÇ„ÄÇÊàëÊääÊàëÁäØËøáÁöÑÈîôËØØÂèäÂØπÂ∫îÁöÑÈ¢òÁõÆËÆ∞‰∏ãÊù•Ôºå‰ª•Ë≠¶Á§∫Ëá™Â∑±„ÄÇ ÔºÅÔºÅÔºö‰∏çÂÆπÊòìÂú®Ë∞ÉËØïÊó∂ÂèëÁé∞ËÄÉËØïÂâç‰∏ÄÂÆöË¶Å‰øùÊåÅÊ∏ÖÈÜí&amp;ÂÖÖË∂≥Áù°Áú†Âπ≥Êó∂ËÆ≠ÁªÉ‰∏ÄÂÆöË¶Å‰øùËØÅÊ∏ÖÈÜí&amp;ÂÖÖË∂≥Áù°Áú† ‰∏âÊòéÊ≤ªÁ≠âÂê´ÊúâÈ∏°ËõãÊàñÁÅ´ËÖøÁöÑÈ£üÁâ©‰∏çË¶ÅÂêÉÔºÅÔºàÊ≤ôÈó®Ê∞èËèåÔºâ Â≠¶‰ºöÈùôÊÄÅ+‰∫∫ÁúºÔºàÁî®ËÑëÂ≠êÔºâÊü•ÈîôÔºÅÔºÅÊòéÊòéÊ≤°ÊúâÊîπÂÆÉÔºå‰∏∫‰ªÄ‰πàÂÆÉÂèò‰∫ÜÔºüÔºüÔºÅÔºÅË∂äÁïå‰∫ÜÔºÅÔºÅÊ£ÄÊü•Âæ™ÁéØÂèòÈáèÔºÅÔºÅ ÂØπÊãçË¶ÅËØïËØïÊûÅÈôêÊï∞ÊçÆÁúãÁúãÊòØÂê¶Ë∂ÖÊó∂ ‰∫§‰∏äÂéª‰∏Ä‰∏™‰ºòÁßÄÁöÑÊö¥ÂäõÔºàÊúÄ‰ºòÂåñÂâ™Êûù ÊµÆË∫ÅÔºåÊòØ‰∫∫Áîü‰∏≠ÊúÄÂ§ßÁöÑÈîôËØØ„ÄÇ ÂÜçÁúãÊº´ÁîªÊàñËÄÖÊâìÊ∏∏ÊàèÂ∞±Ë¶ÅÂèòÂ∞èÁãó‰∫Üww 1) Â§öÊµãÊ≤°ÊúâÊ∏ÖÁ©∫Â∫îÂΩìÊ∏ÖÁ©∫ÁöÑÊï∞ÁªÑÊàñÂèòÈáèÔºàÂåÖÊã¨Êüê‰∫õËæìÂÖ•ÁöÑÊï∞ÁªÑÔºâÔºÅÔºÅ luogu4382 ÂäàÈÖç luogu2055 [ZJOI2009]ÂÅáÊúüÁöÑÂÆøËàç poj3691 DNA repair UVA10652 Board Wrapping 2) Ê≤°ÊúâÂéªÊéâË∞ÉËØïÊó∂ÁöÑËæìÂá∫ÔºàËØ∑Áî®cerr!Ôºâ luogu4365 ÁßòÂØÜË¢≠Âáª 3) ÈÇªÊé•Ë°®ÁöÑnumeÂá∫ÈîôÔºàÂºÇÊàñÊó∂Ê≤°ÊúâÊàêÂØπÂá∫Áé∞ÊàñËÄÖÁ¨¨‰∏Ä‰∏™nume‰∏∫0ÔºåËØ∑int nume=1;) luogu2765 È≠îÊúØÁêÉÈóÆÈ¢ò zkwË¥πÁî®ÊµÅ 4) ÂèòÈáèÂêç/Êï∞ÁªÑÂêçÊâìÈîô(i/j/x,n/m,x/y)(ÊêûÈîôÂØπË±°)ÔºÅÔºÅ luogu2763 ËØïÈ¢òÂ∫ìÈóÆÈ¢ò uva1515 pool construction poj2947 Widget Factory luogu2051 [AHOI2009]‰∏≠ÂõΩË±°Ê£ã hdu3414 Tour Route luogu1903 [ÂõΩÂÆ∂ÈõÜËÆ≠Èòü]Êï∞È¢úËâ≤ poj2985The k-th Largest Group luogu3502 [POI2010]Hamsters hiho1419 ÂêéÁºÄÊï∞ÁªÑÂõõ¬∑ÈáçÂ§çÊóãÂæã4 UVA11796 Dog Distance luogu3157 [CQOI2011]Âä®ÊÄÅÈÄÜÂ∫èÂØπ luogu3377 „ÄêÊ®°Êùø„ÄëÂ∑¶ÂÅèÊ†ëÔºàÂèØÂπ∂Â†ÜÔºâ zroi#363. ÈôàÂ§™Èò≥‰∏é‰πêË∞± *2ÔºÅÔºÅ #444. ÂΩ©ËôπÁ≥ñ ch5103 ‰º†Á∫∏Êù°ÔºàË¢´wyyÊâπÂà§ÊïôËÇ≤‰∫Ü‰∏ÄÁï™Ôºâ 5) ËæπÁïåÂá∫Èîô(n/n+1ÔºâÔºÅÔºÅ luogu2447 [SDOI2010]Â§ñÊòüÂçÉË∂≥Ëô´ 6) Á≠îÊ°àÂøòËÆ∞Êõ¥Êñ∞ÊàñËÄÖÂú®ÊüêÂ§ÑÂ∞ëÊõ¥Êñ∞ÔºÅÔºÅ‰øÆÊîπÊìç‰ΩúÂ∞ë‰øÆÊîπÊüê‰∫õÂÄºÔºÅÔºÅ luogu2447 [SDOI2010]Â§ñÊòüÂçÉË∂≥Ëô´ bzoj1453: [Wc]DfaceÂèåÈù¢Ê£ãÁõò 7) ËæìÂá∫‰∏éÈ¢òÊÑè‰∏çÁ¨¶ÔºàÂ∞ëÂ§çÂà∂‰∫Ü‰ªÄ‰πàÔºâÔºÅÔºÅ poj2947 Widget FactoryÔºàÂ∞ëËæìÂá∫‚Äô.‚ÄôÔºâ bzoj1027 [JSOI2007]ÂêàÈáë Ôºà1ËæìÊàê-1Ôºâ 8) Ê≤°ÊúâÂàùÂßãÂåñÊàñÂàùÂßãÂåñÂá∫ÈîôÔºÅÔºÅ(dpÁ≠â) luogu1070 ÈÅìË∑ØÊ∏∏Êàè luogu3502 [POI2010]Hamsters 9) Â§öÊµãÊ≤°ÊúâÊääÊï∞ÊçÆËØªÂÆåÂ∞±ËæìÂá∫ hdu3414 Tour Route 10) ÂÅöÂÆå‰∏Ä‰∏™Â∞±Ë¶ÅbreakÔºàÂæ™ÁéØÂøòËÆ∞ÈÄÄÂá∫ÔºâÔºÅÔºÅ hdu3414 Tour Route 11) Êï∞ÁªÑÂºÄÂ∞è‰∫ÜÔºàÁÇπÊï∞ÁÆóÂ∞ë‰∫Ü/ËæπÊï∞ÁÆóÂ∞ë‰∫ÜÔºâÔºÅÔºÅ luogu1341 Êó†Â∫èÂ≠óÊØçÂØπ luogu2055 [ZJOI2009]ÂÅáÊúüÁöÑÂÆøËàç luogu1345 [USACO5.4]Â•∂ÁâõÁöÑÁîµ‰ø°Telecowmunication luogu3502 [POI2010]Hamsters luogu2463 [SDOI2008]SandyÁöÑÂç°Áâá luogu2657 [SCOI2009]windyÊï∞ Ê≠£Áùø2018ÊöëÊúüÈõÜËÆ≠ABÁè≠Âà∑È¢òËê•Day2 B. ÈÖçÂØπ #378. „Äê2018ÊôÆËΩ¨Êèêday19‰∏ìÈ¢ò„ÄëÊâìÊû∂ ch5102 Mobile Service hdu5634 Rikka with PhiÔºàzybÁöÑÊïôÂØºÔºöÂõ†‰∏∫Êï∞ÁªÑË∂äÁïåÂêé‰ºöÂèëÁîü‰ªÄ‰πàË∞Å‰πü‰∏çÁü•ÈÅìÂïä„ÄÇ„ÄÇwa,tle,redÈÉΩÊúâÂèØËÉΩ„ÄÇ„ÄÇzyf‰πüÂõ†‰∏∫Êï∞ÁªÑÂºÄÂ∞èt‰∫Ü„ÄÇ„ÄÇÔºâ 12) ËæìÂÖ•Êó∂Âá∫ÈîôÔºàÂá∫Áé∞0‰πãÁ±ªÁöÑÔºåËØªÈîôÔºåÂ§öÂ∫¶ÔºåÂ∞ëËØªÔºâÔºÅÔºÅ luogu1346 ÁîµËΩ¶ 13) ÁàÜintÁàÜintÁàÜint,Á±ªÂûãÂá∫ÈîôÔºåÂøòËÆ∞Âº∫Âà∂Á±ªÂûãËΩ¨Êç¢,LLÂÜôÊàêintÔºàint√óintÁàÜintÔºâÔºÅÔºÅ luogu1265 ÂÖ¨Ë∑Ø‰øÆÂª∫ bzoj4765 ÊôÆÈÄöËÆ°ÁÆóÂß¨ UVA10368 Euclid‚Äôs GameÔºàÊ≤°ÊúâÊï∞ÊçÆËåÉÂõ¥„ÄÇÔºâ Ê≠£Áùø2018ÊöëÊúüÈõÜËÆ≠ABÁè≠Âà∑È¢òËê•Day5 A. ÂèãË∞äÂ∑®ËΩÆ bzoj2115 [Wc2011] Xor luogu3066 [Usaco2012 Dec]Running Away From the Barn ÂçóÂ§ñÊ†°ÂÜÖ18-10-16 a ÂçóÂ§ñÊ†°ÂÜÖ18-10-23 cÔºàÂâçÈù¢ÊîπËøáÁöÑLLÂêéÈù¢Áõ∏Â∫îÁöÑÊ≤°ÊîπÔºâ bzoj2124: Á≠âÂ∑ÆÂ≠êÂ∫èÂàóÔºàÊâÄÊúâÂíåhashÁõ∏ÂÖ≥ÁöÑÈáèÈÉΩË¶ÅÁî®llÔºÅÔºÅÔºâ 14) Á®ãÂ∫èÁöÑÈ°∫Â∫èÂá∫ÈîôÔºàÈÄªËæëÈ°∫Â∫èÔºâÊàñËÄÖÈÄªËæëÈîôËØØÔºàÁªèÂ∏∏ÊÄßÁöÑÈîôËØØÔºå‰∏çËøáÊ≤°ÊúâËÆ∞ÂΩïÔºåÂ§ßÊ¶ÇÊòØËÆ§‰∏∫ÂíåÈ¢òÁõÆÊúâÂÖ≥ÔºåÂÆûÈôÖ‰∏äÊòØÊÄùÁª¥‰∏•Ë∞®ÊÄßÁöÑÈóÆÈ¢òÔºåÊÑüÊÄßÁêÜËß£‰πãÂêéË¶Å‰∏•Ë∞®ÁöÑËØÅÊòéÔºâ luogu1484 ÁßçÊ†ë #109. „Äê17 ÊèêÈ´ò 7„ÄëÂΩìÈÇ£‰∏ÄÂ§©Êù•‰∏¥ bzoj2124: Á≠âÂ∑ÆÂ≠êÂ∫èÂàóÔºàÂèòÈáèÂêçÊâìÂèçÔºâ 15) ‰∏ãÊ†áÂá∫Áé∞Ë¥üÊï∞/‰∏ãÊ†áË∂äÁïå bzoj4765 ÊôÆÈÄöËÆ°ÁÆóÂß¨ bzoj2124: Á≠âÂ∑ÆÂ≠êÂ∫èÂàó 16) È¢òÁõÆÂàÜÊûêÊúâËØØ luogu2022 ÊúâË∂£ÁöÑÊï∞ 17) max/minËÆæÁΩÆÁöÑÊúâËØØ luogu3369 „ÄêÊ®°Êùø„ÄëÊôÆÈÄöÂπ≥Ë°°Ê†ë 18) epsËÆæÁΩÆÂ§™Â∞è‰ºöt 19) (apio2018)‰ΩøÁî®setÊü•ÊâæÊó∂Â∞ΩÈáè‰∏çË¶ÅÁî®pairÔºåÂØπÂèåÂÖ≥ÈîÆÂ≠óÊéíÂ∫èË¶ÅÊ≥®ÊÑè 20) Êï∞ÁªÑ‰∏ãÊ†áÊâìÂèç bzoj1027 [JSOI2007]ÂêàÈáë 21) Á®ãÂ∫èÊîπ‰∏ÄÂçäÂøò‰∫Ü bzoj1027 [JSOI2007]ÂêàÈáë 22) ÂØπÊãçÂøòËÆ∞srand hiho1419 ÂêéÁºÄÊï∞ÁªÑÂõõ¬∑ÈáçÂ§çÊóãÂæã4 23) Êú™ÂÆö‰πâË°å‰∏∫ UVA1342 That Nice Euler CircuitÔºàa[i]=point(read(),read())ÂÖ∂‰∏≠ËØªÂÖ•ÁöÑÈ°∫Â∫èÂèØËÉΩ‰ºöÂèçËøáÊù•Ôºâ 24) ÂõõËàç‰∫îÂÖ•ÂæóÂà∞-0ÔºåÊ≠£Á°ÆÁöÑÂßøÂäøÊòØint(x+0.5)„ÄÇ‰øùÁïô1‰ΩçÂ∞èÊï∞ÂàôÊòØprintf(‚Äú%.1f‚Äù,int(a10+0.5)1.0/10); 25) Ê≤°ÊúâÂèñÊ®°ÔºÅÔºÅ Ê≠£Áùø2018ÊöëÊúüÈõÜËÆ≠ABÁè≠Âà∑È¢òËê•Day2 B. ÈÖçÂØπ #108. „Äê17 ÊèêÈ´ò 7„ÄëÂº∫ÂÜõÊàòÊ≠å 26) (a+=b)%=c ËÄå‰∏çÊòØ (a+=b)%c; 27) long longÁî®%dËæìÂá∫ zroi #261. ËêåÊñ∞ÊãÜÂ°î 28) Ê®°ÊãüËµõ‰∏≠ÁäØÁöÑÈîô Ê≤°ÊúâÊääÊâÄÊúâÂ§çÂà∂ÁöÑÂú∞ÊñπÈÉΩÊîπÊ≠£„ÄÇ Áî®Èîô‰∫ÜÂèòÈáè dijkÊ≤°ÊîπÊàêÂ∞èÊ†πÂ†ÜÔºÅÔºÅÂ•ΩÂá†Ê¨°‰∫ÜÂïäÔºÅ 29) doubleÂÜôÊàêint luogu4525 „ÄêÊ®°Êùø„ÄëËá™ÈÄÇÂ∫îËæõÊôÆÊ£ÆÊ≥ï1 30) Ê±ÇÂâ≤ËæπÁî®fa #359. „Äê2018ÊôÆËΩ¨Êèêday18‰∏ìÈ¢ò„ÄëÂò§Âò§ 31) 1Âà∞nÁöÑÊúÄÁü≠Ë∑Ø‰∏äÁöÑËæπÁî®ds[x]+e[i].f+dt[y]==ds[n]Âà§Êñ≠Ôºå‰ªésÊàñtÂêëÂ§ñÂª∂‰º∏ÈÉΩÊòØÈîôÁöÑ #359. „Äê2018ÊôÆËΩ¨Êèêday18‰∏ìÈ¢ò„ÄëÂò§Âò§ 32) memset(a,0x3f,sizeof(a))Â¶ÇÊûúaÊòØÊåáÈíàÔºåsizeof(a)Âè™Êúâ8‰∏™Â≠óËäÇ #359. „Äê2018ÊôÆËΩ¨Êèêday18‰∏ìÈ¢ò„ÄëÂò§Âò§ 33) Êï∞ÁªÑÂè™ÂºÄÂ§ß1ËÄåË∂äÁïå‰∫Ü„ÄÇ„ÄÇ 34) Ê†ë‰∏ädpÊó∂szÊ≤°ÊúâÂíåËÉåÂåÖÂ§ßÂ∞èÂèñmin ÂçóÂ§ñÊ†°ÂÜÖ18-10-16 a 35) ‰ª•‰∏∫Ê≤°ÁàÜintÂÆûÈôÖÁàÜ‰∫ÜÔºå‰∏â‰∏™intÁõ∏Âä†ÁàÜ‰∫ÜÔºå‰ª•‰∏∫Á±ªÂûãËΩ¨Êç¢‰∫ÜÂÆûÈôÖÊ≤°ÊúâËΩ¨„ÄÇ„ÄÇ ÂçóÂ§ñÊ†°ÂÜÖ18-10-16 a 36) ÈÄíÂΩíÂèòÈáèÂíåÂÖ®Â±ÄÂèòÈáèÈáçÂ§ç #423. ÈîÖÈîÖ 37) ‰ΩøÁî®stlÂÆπÂô®ÂâçÊ≤°ÊúâÂà§ÊòØÂê¶‰∏∫Á©∫ÔºàÂ¶ÇsetÔºâ #467. Êï∞ÁöÑË∑ùÁ¶ª 38) Ê∂âÂèäÂõæÁöÑÈ¢òÁõÆÔºåË¶ÅÊ≥®ÊÑèÈáçËæπÂíåËá™ÁéØÔºÅÔºÅ luoguP1850 Êç¢ÊïôÂÆ§ 39) Ê≥®ÊÑèËøêËæìÁ¨¶ÁöÑÁªìÂêàÂæãÔºåËøûÁ≠âÁöÑÊó∂ÂÄôË¶ÅÊ≥®ÊÑèÂèòÈáèÁöÑÊîπÂèòÔºÅ #322. „ÄêJiangsu Training Contest 5„ÄëGraph 40) ËæìÂÖ•scanf(‚Äú%d‚Äù,a+i)ÂÜôÊàêscanf(‚Äú%d‚Äù,a+1) bzoj3585‚ï±luogu4137 mex 41) add_ansÂíåass_ansÊêûÊ∑∑ csa Min Max Sum]]></content>
      <tags>
        <tag>ÂøÉÊÉÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces 891C]]></title>
    <url>%2F2017%2F11%2F19%2Fcodeforces%20891C%2F</url>
    <content type="text"><![CDATA[È¢òÊÑèÔºö891C. Envytime limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output For a connected undirected weighted graph $G$, MST (minimum spanning tree) is a subgraph of $G$ that contains all of $G$‚Äôs vertices, is a tree, and sum of its edges is minimum possible. You are given a graph $G$. If you run a MST algorithm on graph it would give you only one MST and it causes other edges to become jealous. You are given some queries, each query contains a set of edges of graph $G$, and you should determine whether there is a MST containing all these edges or not. InputThe first line contains two integers $n$, $m$ (2‚â§$n$,$m$‚â§5¬∑10$^5$, $n$-1‚â§$m$) ‚Äî the number of vertices and edges in the graph and the number of queries. The $i$-th of the next $m$ lines contains three integers $ui$, $vi$, $wi$ ($ui$‚â†$vi$, 1‚â§$wi$‚â§5¬∑10$^5$) ‚Äî the endpoints and weight of the $i$-th edge. There can be more than one edges between two vertices. It‚Äôs guaranteed that the given graph is connected. The next line contains a single integer $q$ (1‚â§$q$‚â§5¬∑10$^5$) ‚Äî the number of queries. $q$ lines follow, the $i$-th of them contains the $i$-th query. It starts with an integer $ki$ (1‚â§$ki$‚â§$n$-1) ‚Äî the size of edges subset and continues with $ki$ distinct space-separated integers from 1 to $m$ ‚Äî the indices of the edges. It is guaranteed that the sum of $ki$ for 1‚â§$i$‚â§$q$ does not exceed 5¬∑10$^5$. OutputFor each query you should print ‚ÄúYES‚Äù (without quotes) if there‚Äôs a MST containing these edges and ‚ÄúNO‚Äù (of course without quotes again) otherwise. Example input 5 7 1 2 2 1 3 2 2 3 1 2 4 1 3 4 1 3 5 2 4 5 2 4 2 3 4 3 3 4 5 2 1 7 2 1 2 output YES NO YES NO È¢òËß£ÔºöÁúãÊù•lzÂ§™Âº±‰∫ÜÔºåÊ≠§È¢òË¢´Âàù‰∫åÂ§ß‰Ω¨yhtÊ∞¥Ëøá„ÄÇ‰∏ªË¶ÅÊòØË¶ÅÊÉ≥Âà∞Á¶ªÁ∫øÂ§ÑÁêÜ„ÄÇÊääÊâÄÊúâËØ¢ÈóÆÁöÑËæπ‰ªéÂ∞èÂà∞Â§ßËÄÉËôëÔºåÊØèÊ¨°ËÄÉËôë‰∏ÄÂ†ÜÁõ∏ÂêåÊùÉÂÄºÁöÑËæπ„ÄÇÂÅáÂ¶ÇÂΩìÂâçËæπÁöÑÊùÉÂÄº‰∏∫xÔºåÂàôÂ∞è‰∫éxÁöÑÊâÄÊúâËæπÈÉΩÂ∑≤ÁªèËøõË°åËøá‰∫ÜkruskalÔºåÂä†Ëøõ‰∫ÜÂπ∂Êü•ÈõÜ„ÄÇÂØπÂê´ÊúâÊùÉÂÄº‰∏∫xÁöÑËØ¢ÈóÆÔºåÊàë‰ª¨Â∞ÜÂÖ∂‰∏≠ÊâÄÊúâÊùÉÂÄº‰∏∫xÁöÑÂä†ÂÖ•Âπ∂Êü•ÈõÜÔºåËã•Âá∫Áé∞ÁéØÔºåÂàô‚ÄùNO‚Äù„ÄÇÁÑ∂ÂêéË¶ÅÂ∞ÜÊú¨Ê¨°Êìç‰ΩúÊ∂âÂèäÁöÑÂêàÂπ∂ËøòÂéüÔºàÈáçË¶ÅÔºÅÔºâ„ÄÇÂú®ÂÆåÊàêÊâÄÊúâÊúâÊùÉÂÄº‰∏∫xÁöÑËØ¢ÈóÆÂêéÔºåÂ∞ÜËøô‰∫õËæπÁúüÊ≠£ÁöÑÂä†ÂÖ•Âπ∂Êü•ÈõÜ„ÄÇÂ§çÊùÇÂ∫¶$O(mlogm+\sum ki)$//ÂáΩÊï∞ÈÄíÂΩíÁöÑÂáΩÊï∞Âêç‰∏çËÉΩÂÜôÈîôÂïä~~ ‰ª£Á†ÅÔºö123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;int n,m;int u[500008],v[500008],w[500008],id[500008];int q,k,x;int p1,p2,tmp;int fa[500008];map&lt;int,vector&lt;int&gt; &gt; m1,m2[500008];int qid,l,r;bool vis[500008];int top,val[500008];int *s[500008];inline int find(int x)&#123; return x==fa[x]?x:fa[x]=find(fa[x]);&#125;inline int find2(int x)&#123; if(x==fa[x]) return x; s[++top]=fa+x; val[top]=fa[x]; fa[x]=find2(fa[x]);//Ë∞ÉÁî®find2ÔºåÂÜôÊàêfindÈîô‰∫ÜÂ•ΩÂá†Ê¨° return fa[x];&#125;inline void del()&#123; while(top)&#123; (*s[top])=val[top];--top; &#125;&#125;inline bool cmp(const int a,const int b)&#123; return w[a]&lt;w[b];&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; fa[i]=i; &#125; for(int i=1;i&lt;=m;++i)&#123; u[i]=read();v[i]=read();w[i]=read(); id[i]=i; &#125; sort(id+1,id+m+1,cmp); q=read(); for(int i=1;i&lt;=q;++i)&#123; k=read(); for(int j=1;j&lt;=k;++j)&#123; x=read(); if(m1[w[x]].size()==0||m1[w[x]][m1[w[x]].size()-1]!=i) m1[w[x]].push_back(i); m2[i][w[x]].push_back(x); &#125; &#125; for(int i=1;i&lt;=m;++i)&#123; l=i;r=i; while(w[id[r+1]]==w[id[l]]&amp;&amp;r+1&lt;=m) ++r; for(int j=0;j&lt;m1[w[id[i]]].size();++j)&#123; qid=m1[w[id[i]]][j]; if(vis[qid]) continue; for(int k=0;k&lt;m2[qid][w[id[i]]].size();++k)&#123; tmp=m2[qid][w[id[i]]][k]; p1=find2(u[tmp]); p2=find2(v[tmp]); if(p1!=p2)&#123; s[++top]=fa+p1; val[top]=fa[p1]; fa[p1]=p2; &#125; else&#123; vis[qid]=1; break; &#125; &#125; del(); &#125; for(int j=l;j&lt;=r;++j)&#123; tmp=id[j]; p1=find(u[tmp]); p2=find(v[tmp]); if(p1!=p2)&#123; fa[p1]=p2; &#125; &#125; i=r; &#125; for(int i=1;i&lt;=q;++i)&#123; puts(vis[i]?&quot;NO&quot;:&quot;YES&quot;); &#125; return 0;&#125; Ê¨¢ËøéËΩ¨ËΩΩÊàñÂºïÁî®ÔºåËÉΩÈôÑ‰∏älzÁöÑÁΩëÂùÄÂ∞±Êõ¥Â•ΩÂï¶]]></content>
  </entry>
  <entry>
    <title><![CDATA[NOIP 2017 Â§çËµõÁªÉ‰π†Âç∑Ôºà‰∏Ä)game]]></title>
    <url>%2F2017%2F06%2F06%2FNOIP-2017-%E5%A4%8D%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%8D%B7%EF%BC%88%E4%B8%80%EF%BC%89-game%2F</url>
    <content type="text"><![CDATA[È¢òÊÑèÔºöÂ∞èMÂú®Áé©‰∏Ä‰∏™Ê∏∏Êàè„ÄÇÊ∏∏ÊàèÊúâNËΩÆÔºåÊØè‰∏ÄËΩÆÔºåÁ≥ªÁªüÁªôÂá∫‰∏§‰∏™Êï∞XÂíåYÔºåÂ•πÁöÑ‰ªªÂä°ÊòØÂ∞ÜÂΩìÂâçÂæóÂà∞ÁöÑÊâÄÊúâXÂíåY‰∏§‰∏§ÈÖçÂØπÔºåÂ∞ÜÊØèÂØπX„ÄÅYÊ±ÇÂíåÔºå‰ΩøÂæóÊúÄÂ§ßÁöÑÂíåÊúÄÂ∞è„ÄÇÂ∞èMÁÆóÊôï‰∫ÜÔºå‰∫éÊòØÊâæ‰Ω†Â∏ÆÂøô~„ÄêËæìÂÖ•Ê†ºÂºè„ÄëËæìÂÖ•Á¨¨‰∏ÄË°åÂåÖÂê´‰∏Ä‰∏™Êï¥Êï∞NÔºà1&lt;=N&lt;=100000ÔºâÊé•‰∏ãÊù•NË°åÔºåÊØèË°å‰∏§‰∏™Êï¥Êï∞X„ÄÅYÔºà1&lt;=X,Y&lt;=100Ôºâ„ÄêËæìÂá∫Ê†ºÂºè„ÄëËæìÂá∫ÂÖ±NË°åÔºåÊØèË°å‰∏Ä‰∏™Êï¥Êï∞ÔºåÂØπ‰∫éÂΩìÂâçÂæóÂà∞ÁöÑÊâÄÊúâXÂíåYËøõË°åÈÖçÂØπÔºåËæìÂá∫ÊúÄÂ§ßÂíåÊúÄÂ∞èÁöÑÂÄº„ÄÇ„ÄêÊ†∑‰æãËæìÂÖ•„Äë32 83 11 4„ÄêÊ†∑‰æãËæìÂá∫„Äë10109„ÄêÊï∞ÊçÆËåÉÂõ¥„ÄëÂØπ‰∫é50%ÁöÑÊï∞ÊçÆÔºåN&lt;=200ÔºõÂØπ‰∫é100%ÁöÑÊï∞ÊçÆÔºåN&lt;=100000„ÄÇ È¢òËß£Ôºölz‰πü‰∏ç‰ºö„ÄÇ„ÄÇ‰ΩÜlzÊúâÂ§ß‰Ω¨ÔºàorzÔºâ„ÄÇÂ§ß‰Ω¨ÁöÑËß£Ê≥ïÂü∫‰∫é‚ÜìÊâÄÊúâÂè™Ë¶ÅÊ±Ç{Xi,Yn-i+1}max„ÄÇ‰ΩÜÊòØlz‰∏ç‰ºöÂÅöÔºå‰∫éÊòØÂ§ß‰Ω¨ÂëäËØâÊàëÔºåx,yÂ∞è‰∫é100ÔºåÁî®Á±ª‰ººÊ°∂ÊéíÂ∫èÁöÑÊñπÊ≥ïÂÅö„ÄÇ„ÄÇÂèØÊòØlzËøòÊòØ‰∏ç‰ºöÔºå‰∫éÊòØÂ§ß‰Ω¨Âú®‰∏§ÂàÜÈíüÂÜÖÁªôlzÊâì‰∫Ü‰∏Ä‰ªΩÁ≤æËæüÁöÑ‰ª£Á†ÅÔºå‰ΩÜlzÂπ∂Ê≤°ÊúâËÉΩÂäõÂÜôÂæóÂ¶ÇÊ≠§Á≤æËæüÔºå‰∫éÊòØÂè™ËÉΩÂ∞ÜÂ∞±ÁöÑËÆ≤‰∏Ä‰∏ãlzÁöÑÊñπÊ≥ï‚ÜìÊ±ÇÂä®ÊÄÅÁöÑ{Xi,Yn-i+1}maxÔºå‰∏ÄËà¨ÁöÑÊéíÂ∫èËÇØÂÆö‰∏çË°å„ÄÇ‰ΩÜÊòØx,yÁöÑÂÄºÂæàÂ∞èÔºå‰∫éÊòØÊääÂÆÉ‰ª¨‰∏¢Âà∞‰∏Ä‰∏™[100]ÁöÑÊï∞ÁªÑÈáå„ÄÇÊØèÊ¨°‰ªéx‰ªé1Âà∞100Ôºåy‰ªé100Âà∞1ËøôÊ†∑ÊêúÔºåÂπ∂Áî®tx„ÄÅtyËÆ∞ÂΩïxÁî®‰∫ÜÂá†‰∏™ÔºåyÁî®‰∫ÜÂá†‰∏™„ÄÇËøôÊ†∑ÁöÑÊØèÊ¨°Ê±ÇËß£Â§çÊùÇÂ∫¶Âè™Êúâ100*2„ÄÇ ‰ª£Á†ÅÔºö12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read()&#123; int x=0;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=x*10+ch-&apos;0&apos;;ch=getchar();&#125; return x;&#125;int n,t,ans,tx,ty;int num[2][108];int main()&#123; n=read(); while(n--)&#123; ans=0;tx=0;ty=0; for(int i=0;i&lt;=1;i++)&#123; t=read(); num[i][t]++; &#125; int j=101; for(int i=1;i&lt;=100;i++)&#123; if(num[0][i])&#123; while(tx&gt;=ty)&#123;//Âè™Áî®ÂΩìtx&lt;tyÊó∂ÔºåÂΩìÂâçi‰∏éÂΩìÂâçjÊâç‰ºöÂú®Âêå‰∏Ä‰ΩçÁΩÆ while(!num[1][--j]); ty+=num[1][j]; &#125; ans=max(ans,i+j); tx+=num[0][i]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;&apos;\n&apos;; &#125; return 0;&#125; Ê¨¢ËøéËΩ¨ËΩΩÊàñÂºïÁî®ÔºåËÉΩÈôÑ‰∏älzÁöÑÁΩëÂùÄÂ∞±Êõ¥Â•ΩÂï¶]]></content>
  </entry>
  <entry>
    <title><![CDATA[NOIP 2017 Â§çËµõÁªÉ‰π†Âç∑Ôºà‰∏Ä)word]]></title>
    <url>%2F2017%2F06%2F04%2FNOIP-2017-%E5%A4%8D%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%8D%B7%EF%BC%88%E4%B8%80%EF%BC%89-word%2F</url>
    <content type="text"><![CDATA[È¢òÁõÆÔºöÂÆö‰πâÔºö‰∏Ä‰∏™ P ÂçïËØçÊòØÊåáÔºåËøô‰∏™ÂçïËØç‰∏çÂåÖÂê´ 3 ‰∏™ËøûÁª≠ÁöÑËæÖÈü≥Â≠óÊØçÔºå‰∏î‰∏çÂåÖÂê´ 3 ‰∏™ËøûÁª≠ÁöÑÂÖÉÈü≥Â≠óÊØçÔºå‰∏îËá≥Â∞ëÂåÖÂê´‰∏Ä‰∏™Â≠óÊØç L„ÄÇÁé∞Êúâ‰∏Ä‰∏™Áî±Â§ßÂÜôÂ≠óÊØç‰∏é‰∏ãÂàíÁ∫øÊûÑÊàêÁöÑÂçïËØçÔºåË¶ÅÊ±ÇÂ∞ÜÊâÄÊúâ‰∏ãÂàíÁ∫øÊõøÊç¢ÊàêÂ§ßÂÜôÂ≠óÊØçÔºåÊûÑÊàê‰∏Ä‰∏™Êñ∞ÁöÑÂçïËØçÔºåÊ±ÇÊûÑÊàê P ÂçïËØçÁöÑÊñπÊ°àÊï∞„ÄÇÂÖÉÈü≥Â≠óÊØçÊòØÊåá AÔºåEÔºåIÔºåOÔºåUÔºåÂÖ∂‰ΩôÂ≠óÊØçÈÉΩÊòØËæÖÈü≥Â≠ó„ÄÇ„ÄêËæìÂÖ•„Äë‰∏ÄË°åÔºå‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÔºàÈïøÂ∫¶‰∏çË∂ÖËøá 100Ôºå‰∏ãÂàíÁ∫ø‰∏™Êï∞‰∏çË∂ÖËøá 10Ôºâ„ÄÇ„ÄêËæìÂá∫„Äë‰∏ÄË°åÔºå‰∏Ä‰∏™Êï¥Êï∞ÔºåË°®Á§∫ÊûÑÊàê P ÂçïËØçÁöÑÊñπÊ°àÊï∞„ÄÇ„ÄêÊ†∑‰æãËæìÂÖ•‰∏Ä„ÄëLV„ÄêÊ†∑‰æãËæìÂá∫‰∏Ä„Äë5„ÄêÊ†∑‰æãËæìÂÖ•‰∫å„ÄëV _K„ÄêÊ†∑‰æãËæìÂá∫‰∫å„Äë10„ÄêÊ†∑‰æãËæìÂÖ•‰∏â„ÄëJA_BU_K_A„ÄêÊ†∑‰æãËæìÂá∫‰∏â„Äë485 È¢òËß£ÔºöÂ∞ÜÂÖÉÈü≥Â≠óÊØçÁî®0Ë°®Á§∫ÔºåËæÖÈü≥Â≠óÊØçÁî®1Ë°®Á§∫„ÄÇdp[i][j]ÔºåÂÖ∂‰∏≠i=0/1ÔºåË°®Á§∫Á¨¨j‰ΩçÈÄâÊã©iÊó∂ÁöÑÊÄªÊñπÊ°àÊï∞„ÄÇ‰ΩÜÊòØÂÜôËµ∑Êù•ÊúâÁÇπÈ∫ªÁÉ¶ÔºåÊúÄÂêéÂÜ≥ÂÆöÂê¨ÂèñÂ§ß‰Ω¨ÁöÑÂª∫ËÆÆÔºåÊç¢Áî®Êö¥ÂäõÂÅö‚ÜìÊö¥ÂäõÊûö‰∏æ10‰∏™‰∏ãÊªëÁ∫øÔºåÂÜçÂà§Êñ≠„ÄÇÁ¨¨‰∏ÄÈÅçÂÅöÁöÑÊó∂ÂÄôÊ≤°ÁúãËßÅÂøÖÈ°ªË¶ÅÊúâ‰∏Ä‰∏™LÔºå‰∫éÊòØgg„ÄÇ„ÄÇÊâÄÊúâÂà§Êñ≠ÂéüÂÖàÊòØÂê¶Â∑≤ÊúâL,Êúâ‰∫ÜÊ≠£Â∏∏ÂÅöÔºåÊ≤°ÊúâÁöÑËØù‚ÜìÂ∞ÜÂæóÂà∞ÁöÑÊñπÊ°àÊï∞ÂáèÂéªÊ≤°Êúâ‰∏Ä‰∏™LÁöÑÊñπÊ°àÊï∞„ÄÇËÆ∞‰ΩèÂºÄlong long„ÄÇ ‰ª£Á†ÅÔºö1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read()string s;int a[108],p[18];int n,num;bool suc;LL ans,tmp=1,gg;inline bool check()&#123; for(int i=1;i&lt;=n-2;i++) if(a[i]==a[i+1]&amp;&amp;a[i]==a[i+2]) return 0; return 1;&#125;void dfs(int t)&#123; if(t&gt;num)&#123; if(check())&#123; ans+=tmp; if(!suc)&#123; gg=tmp; while(gg%21==0&amp;&amp;gg&gt;0)&#123; gg=gg/21*20; &#125; ans-=gg; &#125; &#125; return; &#125; for(int i=0;i&lt;=1;i++)&#123; a[p[t]]=i; if(i==0) tmp*=5; else tmp*=21; dfs(t+1); if(i==0) tmp/=5; else tmp/=21; &#125;&#125;int main()&#123; cin&gt;&gt;s; for(int i=0;i&lt;s.size();i++)&#123; if(s[i]==&apos;L&apos;) suc=1; if(s[i]==&apos;_&apos;)&#123; p[++num]=i+1; &#125; else if(s[i]==&apos;A&apos;||s[i]==&apos;E&apos;||s[i]==&apos;I&apos;||s[i]==&apos;O&apos;||s[i]==&apos;U&apos;) a[i+1]=0; else a[i+1]=1; &#125; n=s.size(); dfs(1); cout&lt;&lt;ans; return 0;&#125; Ê¨¢ËøéËΩ¨ËΩΩÊàñÂºïÁî®ÔºåËÉΩÈôÑ‰∏älzÁöÑÁΩëÂùÄÂ∞±Êõ¥Â•ΩÂï¶]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Usaco2015 Open Gold]Trapped in the Haybales]]></title>
    <url>%2F2017%2F06%2F03%2FUsaco2015-Open-Gold-Trapped-in-the-Haybales%2F</url>
    <content type="text"><![CDATA[È¢òÊÑèÔºöÂÜúÊ∞ëÁ∫¶Áø∞Â∑≤ÁªèÊî∂Âà∞‰∫Ü‰∏ÄÊâπÊúâN‰∏™ÁöÑÂ§ßÂûãÂπ≤ËçâÂåÖÔºà1&lt;=N&lt;=100,000ÔºâÔºåÂπ∂ÊîæÁΩÆÂú®Ê≤øÁùÄÈÄöÂæÄ‰ªñÁöÑË∞∑‰ªìÁöÑË∑Ø‰∏çÂêå‰ΩçÁΩÆ„ÄÇ‰∏çÂπ∏ÁöÑÊòØÔºå‰ªñÂÆåÂÖ®ÂøòËÆ∞‰∫ÜBessieÁâõÊòØÊîæÁâßÁöÑË∑Ø‰∏äÔºåÂ•πÁé∞Âú®ÂèØËÉΩË¢´Âõ∞Âú®ÈÇ£‰∫õÂπ≤ËçâÂåÖ‰∏≠ÔºÅÊØè‰∏™Âπ≤ËçâÂåÖJÈÉΩÊúâ‰∏Ä‰∏™Â§ßÂ∞èS[J]Âíå‰∏Ä‰∏™‰ΩçÁΩÆP[J]ÔºåÊèê‰æõÈÇ£‰∏™Âπ≤ËçâÂåÖÂú®ÈÇ£‰∏™‰∏ÄÁª¥ÈÅìË∑ØÁöÑ‰ΩçÁΩÆ„ÄÇË¥ùËåúÂ•∂ÁâõÂèØ‰ª•Âú®Ë∑Ø‰∏äËá™Áî±Ëµ∞Âä®ÔºåÁîöËá≥Âà∞Ëøô‰∏™Âπ≤ËçâÂåÖÊâÄÂú®ÁöÑ‰ΩçÁΩÆÔºå‰ΩÜÂ•πÊó†Ê≥ïÁ©øË∂äËøô‰∏™‰ΩçÁΩÆ„ÄÇ‰Ωú‰∏∫‰∏Ä‰∏™‰æãÂ§ñÔºåÂ¶ÇÊûúÂ•πÂú®Âêå‰∏Ä‰∏™ÊñπÂêëË∑ëD‰∏™ÈÄüÂ∫¶Âçï‰ΩçÔºåÂ•πÂ∞±ÂèØ‰ª•ÊúâË∂≥Â§üÁöÑÈÄüÂ∫¶Á™ÅÁ†¥ÔºåÂπ∂Ê∞∏‰πÖÊ∂àÈô§‰ªª‰ΩïÂπ≤ËçâÂåÖÔºåÂè™Ë¶ÅÈÇ£‰∏™Âπ≤ËçâÂåÖÂ§ßÂ∞è‰∏•Ê†ºÂ∞è‰∫éD„ÄÇÂΩìÁÑ∂ÔºåÂú®Ëøô‰πãÂêéÔºåÂ•π‰ºöÊâìÂºÄÊõ¥Â§ßÁöÑÁ©∫Èó¥ËÆ©Â•πË∑ëÂêëÂà´ÁöÑÂπ≤ËçâÂåÖÔºåÂπ∂Ê∂àÈô§ÂÆÉ‰ª¨„ÄÇÂ¶ÇÊûúÂ•πËÉΩÁ™ÅÁ†¥ÊúÄÂ∑¶ËæπÊàñÊúÄÂè≥ËæπÁöÑÂπ≤ËçâÂåÖÔºåÂàôË¥ùËåúÂèØ‰ª•ÈÄÉÊéâ„ÄÇËØ∑ËÆ°ÁÆóÁî±ÂÆûÊï∞ÁöÑËµ∑Âßã‰ΩçÁΩÆÁªÑÊàêÁöÑÈÅìË∑ØÊúÄÂ∞èÈúÄË¶ÅÂ§öÈïøÔºå‰ΩøBessie‰∏çËÉΩÈÄÉËÑ±„ÄÇ È¢òÁõÆÈìæÊé•Ôºöhttps://www.luogu.org/problem/show?pid=3127 È¢òËß£ÔºöÈ¢òÁõÆÂ•ΩÁªïÂïä„ÄÇ„ÄÇÂ§ßÊ¶ÇÂ∞±ÊòØÊ±ÇBessieÁ´ôÂú®Âì™ÈáåÈÄÉ‰∏çÂá∫Âéª„ÄÇ„ÄÇÂΩìÁÑ∂ÂèØ‰ª•Êö¥Âäõ„ÄÇ„ÄÇ100000ÔºåÊòæÁÑ∂Âè™ËÉΩÁî®O(nlogn)ÔºåÂÆòÊñπÁöÑÊ†áÁ®ã‰πüÊòØÁî®Ëøô‰∏™Â§çÊùÇÂ∫¶ÁöÑ„ÄÇÂÅáÂ¶ÇBessie‰ªé‰∏Ä‰∏™Âæà‰ΩéÁöÑÂå∫Èó¥‰∏ÄÁõ¥ÂæÄÂ§ñÂÜ≤ÔºåÁªìÊûúÊíûÂú®‰∫ÜÂæàÈ´òÁöÑ‰∏Ä‰∏™Âå∫Èó¥ÁöÑÂπ≤ËçâÂ†Ü‰∏ä„ÄÇÂ¶ÇÊûú‰ªé‰ΩéÂå∫Èó¥ÂæÄÈ´òÂå∫Èó¥Ê±ÇËß£Ôºå‰∏çÊòØÂæà‰∫èÂêó„ÄÇ„ÄÇ‰∫éÊòØ‰ªéÈ´òÂå∫Èó¥Âêë‰ΩéÂå∫Èó¥Ê±ÇËß£‚ÜìÂÖàÊääÂπ≤ËçâÂ†ÜÁöÑÈ´òÂ∫¶ÊéíÈÄíÂáèÂ∫èÔºåÂ∞ÜÊØè‰∏™È´òÂ∫¶ÂÄºÊèíÂÖ•setÔºåÂú®setÈáåÈù¢‰∫åÂàÜÊâæÂÆÉÂ∑¶Âè≥Áõ∏ÈÇªÁöÑÂπ≤ËçâÂ†ÜÔºåÂ¶ÇÊûúËøô‰∏™Âå∫Èó¥Ê≠£Â•ΩËÉΩÊääBessieÊã¶‰ΩèÔºåÂ∞±ÊääËøô‰∏™Âå∫Èó¥ÂÜÖÁöÑÂπ≤ËçâÂ†ÜÊ†áËÆ∞‰∏Ä‰∏ãÔºå‰ª•ÂêéÂ∞±‰∏çÁî®ÂÜçÊ†áËÆ∞‰∫Ü„ÄÇËøôÈáåÈááÁî®Â∑¶Èó≠Âè≥ÂºÄÔºåÂ∞ÜÂ∑¶ËæπÁöÑÂπ≤ËçâÂ†ÜÊ†áËÆ∞ÔºåÂè≥ËæπÁöÑ‰∏çÊ†áËÆ∞„ÄÇËøòÊúâ‰∏ÄÁÇπÔºåÊï∞ÊçÆËææÂà∞1e9ÔºåË¶ÅÁ¶ªÊï£Âåñ„ÄÇÔºàlzÁî®mapÔºâÊó∂Èó¥Â§çÊùÇÂ∫¶Â∞±ÊòØO(nlogn)Ôºå‰ΩÜÁî±‰∫éÁî®‰∫ÜmapÂ∏∏Êï∞‰ºöÂ§ßË∑ëÂæóÊÖ¢„ÄÇ„ÄÇ ‰ª£Á†ÅÔºö123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read()&#123; int x=0;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=x*10+ch-&apos;0&apos;;ch=getchar();&#125; return x;&#125;int n,pos[100008],l,r,ans;struct node&#123; int s,p;&#125;a[100008];map&lt;int,int&gt; m;set&lt;int&gt; s;set&lt;int&gt;::iterator si;bool vis[100008];inline bool cmp(const int a,const int b)&#123;return a&lt;b;&#125;inline bool cmp2(const node a,const node b)&#123;return a.s&gt;b.s;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; a[i].s=read();a[i].p=read(); pos[i]=a[i].p; &#125; sort(pos+1,pos+n+1,cmp); for(int i=1;i&lt;=n;i++) m[pos[i]]=i; sort(a+1,a+n+1,cmp2); s.insert(a[1].p); for(int i=2;i&lt;=n;i++)&#123; if(*s.begin()&lt;a[i].p)&#123; si=--s.upper_bound(a[i].p); l=m[*si];r=m[a[i].p]; if(pos[r]-pos[l]&lt;=a[i].s&amp;&amp;!vis[l])&#123; for(int j=l;j&lt;r;j++) vis[j]=1; &#125; &#125; if(*--s.end()&gt;a[i].p)&#123; si=s.upper_bound(a[i].p); l=m[a[i].p];r=m[*si]; if(pos[r]-pos[l]&lt;=a[i].s&amp;&amp;!vis[l])&#123; for(int j=l;j&lt;r;j++) vis[j]=1; &#125; &#125; s.insert(a[i].p); &#125; for(int i=1;i&lt;n;i++)&#123; if(vis[i]) ans+=pos[i+1]-pos[i]; &#125; cout&lt;&lt;ans; return 0;&#125; Ê¨¢ËøéËΩ¨ËΩΩÊàñÂºïÁî®ÔºåËÉΩÈôÑ‰∏älzÁöÑÁΩëÂùÄÂ∞±Êõ¥Â•ΩÂï¶]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Usaco2015 Open Gold]Palindromic Paths]]></title>
    <url>%2F2017%2F06%2F02%2FUsaco2015-Open-Gold-Palindromic-Paths%2F</url>
    <content type="text"><![CDATA[È¢òÊÑèÔºö‰ªé n√ón ÁöÑÁü©Èòµ Â∑¶‰∏äËßíËµ∞Âà∞Âè≥‰∏ãËßí‰ºöÊúâ‰∏Ä‰∏™ÈïøÂ∫¶ n+n+1 ÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÈóÆÊúâÂ§öÂ∞ëÁßçËµ∞Ê≥ï‰ΩøÂæóË∑ØÂæÑÂ≠óÁ¨¶‰∏≤‰∏∫ÂõûÊñáÔºü È¢òÁõÆÈìæÊé•Ôºöhttps://www.luogu.org/problem/show?pid=3126 ÔºàÊîØÊåÅÊ¥õË∞∑ È¢òËß£ÔºöÂìáÂìáÂìáÊú¨‰∫∫ËíüËíªÂÅö‰∫ÜÂ•Ω‰πÖÂÖ∂ÂÆû‰∏çÈöæ„ÄÇ„ÄÇn=500„ÄÇ„ÄÇÂ•ΩÂÉèÂè™Áî®O(n^3)ÁöÑÊñπÊ≥ïÂèØ‰ª•Ëøá„ÄÇ„ÄÇÈÇ£Â∞±dpÂêßÔºå‰ªéÔºà1,1ÔºâÂíåÔºàn,nÔºâÂêåÊó∂Âêë‰∏≠Èó¥Ëµ∞ÔºàlzÁöÑÁ¨¨‰∏ÄÂèçÂ∫îÊòØÂèåÂêëbfsÔºåË∂ÖÊó∂ÔºåÊîπÊàê‰ªé‰∏§Â§¥ÁöÑdpÔºâÁä∂ÊÄÅÂ§ßÊ¶ÇÂ∞±ÊòØdpÔºài,j,k,lÔºâÔºåË°®Á§∫Ëµ∞Âà∞Ôºài,jÔºâÂíåÔºàk,lÔºâÊó∂ÁöÑÊñπÊ°àÊï∞ÔºåËΩ¨Áßª‚Üìdp[i][j][k][l]=dp[i-1][j][k+1][l]+dp[i-1][j][k][l+1]+dp[i][j-1][k+1][l]+dp[i][j-1][k][l+1]‰ΩÜÊòØÂ•ΩÂÉè‰ºöË∂ÖÊó∂Ë∂ÖÁ©∫Èó¥„ÄÇ„ÄÇÁä∂ÊÄÅÂæó‰øÆÊîπ‰∏Ä‰∏ã‚ÜìÊó∂Èó¥‰ºòÂåñÔºöÊó¢ÁÑ∂ÊòØ‰ªé‰∏§Â§¥ÂêåÊó∂Ëµ∞ÔºåÂèØ‰ª•ËÆ∞‰∏Ä‰∏ãËµ∞ÁöÑÊ≠•Êï∞ÔºåÂÜçÁïô‰∏Ä‰∏™iÂíåkÂ∞±ÂèØ‰ª•‰∫ÜÔºåËøôÊ†∑Â∞±ÂèòÊàêO(n^3)„ÄÇdpÔºàs,i,kÔºâÂÉèËøôÊ†∑Â∞±ÂèØ‰ª•‰∫Ü„ÄÇ„ÄÇlzÂú®ÁΩë‰∏äÁúãÂà∞‰∫ÜÂè¶‰∏ÄÁßçÁä∂ÊÄÅËÆæËÆ°‚Üìdp[i][j][k]Ë°®Á§∫Â∑¶‰∏äÁªìÊùüËäÇÁÇπÊòØÁ¨¨iÊù°ÂâØÂØπËßíÁ∫ø‰∏äÁöÑÁ¨¨j‰∏™ÁÇπÔºåÂè≥‰∏ãÁªìÊùüËäÇÁÇπÊòØÁ¨¨n*2-iÊù°ÂâØÂØπËßíÁ∫ø‰∏äÁöÑÁ¨¨k‰∏™ÁÇπÔºåÊûÑÊàêÂõûÊñáÁöÑÊñπÊ°àÊï∞„ÄÇÔºàÂºïÁî®Âú∞ÂùÄÔºöhttp://www.cnblogs.com/czllgzmzl/p/5645030.htmlÔºâÂÖ∂ÂÆûÔºåÊàë‰πüÊòØÊåâÁÖßËøô‰ΩçÂ§ß‰Ω¨ÁöÑÊñπÊ≥ïÂÅöÁöÑÔºåÂõ†‰∏∫kË°®Á§∫Ëµ∑Êù•ÁÆÄÂçïÂïäÔºà‰ΩÜ‰πüÊúâÈ∫ªÁÉ¶ÁöÑÂú∞ÊñπÔºâËΩ¨Áßª‰∏∫dp[s][i][k]=dp[s-1][i-1][k-1]+dp[s-1][i-1][k]+dp[s-1][i][k-1]+dp[s-1][i][k]ÂÆå‰∫ÜÂêóÔºüÊúâÊ≤°ÊúâÂèëÁé∞Ë¶ÅÂºÄ500^3ÁöÑÊï∞ÁªÑÔºåÁàÜÁ©∫Èó¥‰∫Ü„ÄÇ„ÄÇÁ©∫Èó¥‰ºòÂåñÔºödpÊúÄÂ∏∏ËßÅÁöÑÁ©∫Èó¥‰ºòÂåñ‚Äì&gt;ÊªöÂä®Êï∞ÁªÑÔºàËÉΩÁä∂ÂéãÁöÑÂ§ß‰Ω¨ËØ∑Êó†ËßÜËíüËíªÔºâÁ¨¨‰∏ÄÁª¥Â•ΩÂÉèÂè™ÈúÄË¶Å2‰∏™ÔºàÊØèÊ¨°Âè™Ë∑üÂâç‰∏ÄÊ¨°Áä∂ÊÄÅÊúâÂÖ≥ÔºâÔºåËøôÊ†∑Â∞±ÂèØ‰ª•Âéã‰∫Ü ‰ª£Á†ÅÔºö1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MOD=1000000007;int n;LL dp[2][508][508],ans;char a[508][508];bool now,pre;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]+1; if(a[1][1]!=a[n][n])&#123; cout&lt;&lt;&apos;0&apos;; return 0; &#125; now=1;pre=0; dp[now][1][1]=1; for(int step=3;step&lt;=n+1;step++)&#123;//‰ªéÁ¨¨‰∫åÊù°ÂâØÂØπËßíÁ∫øÂà∞Á¨¨n+1Êù°ÔºåÂ∞±ÊòØËµ∞ÁöÑÊ≠•Êï∞ swap(now,pre); for(int i=1;i&lt;step;i++)&#123; for(int k=1;k&lt;step;k++)&#123; if(a[i][step-i]==a[n-step+1+k][n-k+1])//ÁªÜÂøÉÂú∞Êé®‰∏Ä‰∏ãÂè≥‰∏ãËßíÁÇπÁöÑÂùêÊ†áÔºåÂÆπÊòìÈîô dp[now][i][k]=(dp[pre][i-1][k-1]+dp[pre][i-1][k]+dp[pre][i][k-1]+dp[pre][i][k])%MOD; else dp[now][i][k]=0;//ÊªöÂä®Êï∞ÁªÑ‰∏ÄÂÆöË¶ÅÊ∏ÖÈõ∂Ôºå‰∏çÁÑ∂ÂêéÈù¢‰ºöËØØÁî®ÂâçÈù¢ÁöÑÂÄº &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) ans=(ans+dp[now][i][i])%MOD; cout&lt;&lt;ans; return 0;&#125; Ê¨¢ËøéËΩ¨ËΩΩÊàñÂºïÁî®ÔºåËÉΩÈôÑ‰∏älzÁöÑÁΩëÂùÄÂ∞±Êõ¥Â•ΩÂï¶]]></content>
  </entry>
  <entry>
    <title><![CDATA[first sight]]></title>
    <url>%2F2017%2F05%2F29%2Ffirst-sight%2F</url>
    <content type="text"><![CDATA[ÂìàÂìàÂìà Áªà‰∫éÂª∫Â•Ω‰∫ÜÔºÅ‚Ä¶‚Ä¶*Ôø•Z^@!@# 1234567#include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; cout&lt;&lt;&quot;hello world&quot;; return 0; &#125; hello world ‰Ωú‰∏∫Á¨¨‰∏ÄÁØá‰∏∫‰ªÄ‰πàÂèòÊàê‰º†Áªü‰∫ÜÂë¢„ÄÇ„ÄÇ ÂèãÊÉÖÈìæÊé•Ôºöhttps://li-mi.github.io/]]></content>
      <tags>
        <tag>ÂøÉÊÉÖ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
