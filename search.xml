<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【学习笔记】分块&莫队]]></title>
    <url>%2F2019%2F08%2F20%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%88%86%E5%9D%97%26%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[分块&amp;莫队分块：如果我们把每m个元素分为一块，共有n/m块，每次区间加的操作会涉及O(n/m)个整块，以及区间两侧两个不完整的块中至多2m个元素。每次操作的复杂度是O(n/m)+O(m)，根据均值不等式，当m取√n时总复杂度最低。(hzwer) 分块：123456789for(int i=1;i&lt;=n;++i)&#123; bl[i]=(i-1)/blk+1;&#125;nb=bl[n];for(int i=1;i&lt;=nb;++i)&#123; lblk[i]=(i-1)*blk+1; rblk[i]=i*blk;&#125;rblk[nb]=n; 王室联邦分块：用于树上莫队用法待学1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,"r",stdin);#define fileout(s) freopen(s,"w",stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=1000+8;int n,b;int x,y;int nume,head[N];struct edge&#123; int to,nxt;&#125;e[N&lt;&lt;1];IL void add_edge(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;int k,bl[N],ct[N];//vector&lt;int&gt; s[N];int num,st[N];IL void dfs(int x,int fa)&#123; int tmp=num; for(int i=head[x];i;i=e[i].nxt)&#123; int to=e[i].to; if(to!=fa)&#123; dfs(to,x); if(num-tmp&gt;=b)&#123; ++k; ct[k]=x; while(num&gt;tmp)&#123; //s[k].pb(st[num]); bl[st[num]]=k; --num; &#125; &#125; &#125; &#125; st[++num]=x;&#125;int main()&#123; n=io;b=io; for(int i=1;i&lt;n;++i)&#123; x=io;y=io; add_edge(x,y); add_edge(y,x); &#125; dfs(1,0); //if(!num) ct[++num]=1; while(num&gt;0)&#123; //s[k].pb(st[num]); bl[st[num]]=k; --num; &#125; printf("%d\n",k); for(int i=1;i&lt;=n;++i)&#123; printf("%d ",bl[i]); &#125; printf("\n"); for(int i=1;i&lt;=k;++i)&#123; printf("%d ",ct[i]); &#125; return 0;&#125; 莫队：普通莫队、带修改莫队、树上莫队、回滚莫队（见全网最详细、最深的四类莫队算法讲解）普通莫队：先按左指针所在块升序，同一块按右指针升序。复杂度：设块长m，共n/m块，左指针移动q·m次，右指针移动n·n/m次，m取n/sqrt(q)时，为n·sqrt(q) 莫队：12345678910111213141516int curl=1,curr=0; for(int i=1;i&lt;=qn;++i)&#123; while(curl&lt;b[i].l)&#123; remove(curl);++curl; &#125; while(curl&gt;b[i].l)&#123; --curl;add(curl); &#125; while(curr&lt;b[i].r)&#123; ++curr;add(curr); &#125; while(curr&gt;b[i].r)&#123; remove(curr);--curr; &#125; solve(i);&#125; 把块大小blk设成定值不易出错，方便调块大小卡常。 luogu4396 [AHOI2013]作业莫队+分块：在区间上莫队，在值域上分块。莫队的转移是O(1)。每个询问求答案是用分块，复杂度根号，查询的总复杂度为q根号n。总复杂度是O(n·sqrt(q)+q·sqrt(n))123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,"r",stdin);#define fileout(s) freopen(s,"w",stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=100000+8,QN=1000000+8,NB=350;const int blk=300;int n,qn;int a[N];struct ques&#123; int l,r,a,b,id;&#125;b[QN];int bl[N],nb,lblk[NB],rblk[NB];//值域也是1到n，共用一个bl IL bool cmp(const ques &amp;a,const ques &amp;b)&#123; if(bl[a.l]!=bl[b.l]) return bl[a.l]&lt;bl[b.l]; return a.r&lt;b.r;&#125; int cnt[N],num1[NB],num2[NB];IL void add(int x)&#123; ++cnt[a[x]]; ++num1[bl[a[x]]]; if(cnt[a[x]]==1) ++num2[bl[a[x]]];&#125;IL void remove(int x)&#123; --cnt[a[x]]; --num1[bl[a[x]]]; if(cnt[a[x]]==0) --num2[bl[a[x]]];&#125;int ans1[QN],ans2[QN];IL void solve(int x)&#123; int ans1=0,ans2=0; int l=b[x].a,r=b[x].b; if(bl[l]==bl[r])&#123; for(int i=l;i&lt;=r;++i)&#123; ans1+=cnt[i];ans2+=(cnt[i]&gt;0); &#125; &#125; else&#123; for(int i=bl[l]+1;i&lt;=bl[r]-1;++i)&#123; ans1+=num1[i];ans2+=num2[i]; &#125; for(int i=l;i&lt;=rblk[bl[l]];++i)&#123; ans1+=cnt[i];ans2+=(cnt[i]&gt;0); &#125; for(int i=lblk[bl[r]];i&lt;=r;++i)&#123; ans1+=cnt[i];ans2+=(cnt[i]&gt;0); &#125; &#125; ::ans1[b[x].id]=ans1; ::ans2[b[x].id]=ans2;&#125;IL void MAIN()&#123; int curl=1,curr=0; for(int i=1;i&lt;=qn;++i)&#123; while(curl&lt;b[i].l)&#123; remove(curl);++curl; &#125; while(curl&gt;b[i].l)&#123; --curl;add(curl); &#125; while(curr&lt;b[i].r)&#123; ++curr;add(curr); &#125; while(curr&gt;b[i].r)&#123; remove(curr);--curr; &#125; solve(i); &#125; for(int i=1;i&lt;=qn;++i)&#123; printf("%d %d\n",ans1[i],ans2[i]); &#125;&#125;int main()&#123; n=io;qn=io; for(int i=1;i&lt;=n;++i)&#123; a[i]=io; &#125; for(int i=1;i&lt;=qn;++i)&#123; b[i].l=io;b[i].r=io;b[i].a=io;b[i].b=io; b[i].id=i; &#125; for(int i=1;i&lt;=n;++i)&#123; bl[i]=(i-1)/blk+1; &#125; nb=bl[n]; for(int i=1;i&lt;=nb;++i)&#123; lblk[i]=(i-1)*blk+1; rblk[i]=i*blk; &#125; rblk[nb]=n; sort(b+1,b+qn+1,cmp); MAIN(); return 0;&#125; luogu1903 [国家集训队]数颜色/维护队列带修改莫队：多了一个时间轴。排序第一关键字是左端点所在块编号，第二关键字是右端点所在块编号，第三关键字是时间。左指针移动的复杂度为q·n，右指针的复杂度为n/m·n，时间轴的指针的复杂度为n/m·n/m·q，n和q同阶的时候，m取n^(2/3)时最优。比较需要调块大小。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,&quot;r&quot;,stdin);#define fileout(s) freopen(s,&quot;w&quot;,stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=133333+8,QN=133333+8,VAL=1000000+8;const int blk=6000;int n,qn,qn1,qn2;int a[N],c[N];int bl[N];struct ques1&#123; int l,r,id,cur;&#125;b1[QN];struct ques2&#123; int pos,a,b;&#125;b2[QN];IL bool cmp(const ques1 &amp;a,const ques1 &amp;b)&#123; if(bl[a.l]!=bl[b.l]) return a.l&lt;b.l; if(bl[a.r]!=bl[b.r]) return a.r&lt;b.r; return a.cur&lt;b.cur;&#125;int curl=1,curr=0,cur=0;int tot=0,cnt[VAL];IL void add(int x)&#123; ++cnt[x]; if(cnt[x]==1) ++tot;&#125;IL void remove(int x)&#123; --cnt[x]; if(cnt[x]==0) --tot;&#125; IL void change(int pos,int x)&#123; if(curl&lt;=pos&amp;&amp;pos&lt;=curr)&#123; remove(a[pos]); add(x); &#125; a[pos]=x;&#125;int ans[QN];IL void MAIN()&#123; for(int i=1;i&lt;=qn1;++i)&#123; while(cur&lt;b1[i].cur)&#123; ++cur; change(b2[cur].pos,b2[cur].b); &#125; while(cur&gt;b1[i].cur)&#123; change(b2[cur].pos,b2[cur].a); --cur; &#125; while(curl&lt;b1[i].l)&#123; remove(a[curl]);++curl; &#125; while(curl&gt;b1[i].l)&#123; --curl;add(a[curl]); &#125; while(curr&lt;b1[i].r)&#123; ++curr;add(a[curr]); &#125; while(curr&gt;b1[i].r)&#123; remove(a[curr]);--curr; &#125; ans[b1[i].id]=tot; &#125; for(int i=1;i&lt;=qn1;++i)&#123; printf(&quot;%d\n&quot;,ans[i]); &#125;&#125;int main()&#123; n=io;qn=io; for(int i=1;i&lt;=n;++i)&#123; a[i]=c[i]=io; bl[i]=(i-1)/blk+1; &#125; for(int i=1;i&lt;=qn;++i)&#123; char ch; scanf(&quot;%c&quot;,&amp;ch); if(ch==&apos;Q&apos;)&#123; ++qn1; b1[qn1].l=io;b1[qn1].r=io; b1[qn1].id=qn1;b1[qn1].cur=qn2; &#125; else&#123; ++qn2; b2[qn2].pos=io; b2[qn2].a=c[b2[qn2].pos]; c[b2[qn2].pos]=b2[qn2].b=io; &#125; &#125; sort(b1+1,b1+qn1+1,cmp); MAIN(); return 0;&#125; atcoder1219 歴史の研究回滚莫队：用来处理不适合添加或者删除的情况。对于处于同一块的左指针，每次移动之前将左指针放在下一个块的第一个位置，移动之后再把左指针放到下一个块的第一个位置。这样可以使得问题只有添加没有删除（或者删除变的可以处理）。复杂度同普通莫队。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,&quot;r&quot;,stdin);#define fileout(s) freopen(s,&quot;w&quot;,stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=100000+8,QN=100000+8,NB=350;const int blk=300;int n,qn;int tot,ori[N],a[N];struct ques&#123; int l,r,id;&#125;b[QN];int nb,bl[N],lblk[NB],rblk[NB];IL bool cmp(const ques &amp;a,const ques &amp;b)&#123; if(bl[a.l]!=bl[b.l]) return bl[a.l]&lt;bl[b.l]; return a.r&lt;b.r; &#125;int cnt[N];LL ans[QN];IL void MAIN()&#123; int curl=0,curr=0; LL ans=0,tmp=0; for(int i=1;i&lt;=qn;++i)&#123; int l=b[i].l,r=b[i].r; if(bl[l]!=bl[b[i-1].l])&#123; curl=rblk[bl[l]]+1; curr=rblk[bl[l]]; tmp=0; memset(cnt,0,sizeof(cnt)); &#125; if(bl[l]==bl[r])&#123; ans=0; for(int i=l;i&lt;=r;++i)&#123; ++cnt[a[i]]; ans=max(ans,1ll*cnt[a[i]]*ori[a[i]]); &#125; for(int i=l;i&lt;=r;++i)&#123; --cnt[a[i]]; &#125; ::ans[b[i].id]=ans; continue; &#125; while(curr&lt;r)&#123; ++curr;++cnt[a[curr]]; tmp=max(tmp,1ll*cnt[a[curr]]*ori[a[curr]]); &#125; ans=tmp; while(curl&gt;l)&#123; --curl;++cnt[a[curl]]; ans=max(ans,1ll*cnt[a[curl]]*ori[a[curl]]); &#125; while(curl&lt;rblk[bl[l]]+1)&#123; --cnt[a[curl]];++curl; &#125; ::ans[b[i].id]=ans; &#125; for(int i=1;i&lt;=qn;++i)&#123; printf(&quot;%lld\n&quot;,::ans[i]); &#125;&#125;int main()&#123; n=io;qn=io; for(int i=1;i&lt;=n;++i)&#123; ori[i]=a[i]=io; &#125; sort(ori+1,ori+n+1); tot=unique(ori+1,ori+n+1)-ori-1; for(int i=1;i&lt;=n;++i)&#123; a[i]=lower_bound(ori+1,ori+tot+1,a[i])-ori; &#125; for(int i=1;i&lt;=qn;++i)&#123; b[i].l=io;b[i].r=io; b[i].id=i; &#125; for(int i=1;i&lt;=n;++i)&#123; bl[i]=(i-1)/blk+1; &#125; nb=bl[n]; for(int i=1;i&lt;=nb;++i)&#123; lblk[i]=(i-1)*blk+1; rblk[i]=i*blk; &#125; rblk[nb]=n; sort(b+1,b+qn+1,cmp); MAIN(); return 0;&#125; 区间众数离线：回滚莫队 时间n·sqrt(q) 空间n在线：分块 时间n·sqrt(q) 空间n luogu5048 [Ynoi2019模拟赛]Yuno loves sqrt technology III区间众数 众数的次数 在线先离散化数据，将每个数据都放到对应的桶里(vector)，并记下排名。再预处理一个f[i][j]表示第i个块到第j个块中的众数是多少，同时也可以记下众数是什么。对于每一个[l,r]，ans开始是f[bl[l]+1][bl[r]-1]为中间块的众数。对于左边的数字，在其对应的vector中找从他开始往后ans个数的位置是否&lt;=r(首先要保证有后ans个数)，如果有则++ans对于右边的数字，在其对应的vector中找从他开始往前ans个数的位置是否&gt;=l(首先要保证有前ans个数)，如果有则++ans复杂度：ans自增最多blk次，因为每次更新的数的位置要跨越[bl[l]+1][bl[r]-1]，这样就是两边区间的数的个数。预处理复杂度为n·n/m，每次查询复杂度为m，总复杂度n·n/m+q·m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inlineusing namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=500000+8,NB=750;const int blk=700;int n,qn,nb;int ori[N],tot,a[N];int bl[N],lblk[N],rblk[N];int f[NB][NB];int pos[N];vector&lt;int&gt; set_pos[N];int cnt[N];int l,r,lstans;IL void MAIN()&#123; int ans=0; while(qn--)&#123; l=io^lstans;r=io^lstans; if(bl[l]+1&lt;=bl[r]-1) ans=f[bl[l]+1][bl[r]-1]; else ans=0; if(bl[l]==bl[r])&#123; for(int i=l;i&lt;=r;++i)&#123; while(pos[i]+ans&lt;set_pos[a[i]].size()&amp;&amp;set_pos[a[i]][pos[i]+ans]&lt;=r)&#123; ++ans; &#125; &#125; &#125; else&#123; for(int i=l;i&lt;=rblk[bl[l]];++i)&#123; while(pos[i]+ans&lt;set_pos[a[i]].size()&amp;&amp;set_pos[a[i]][pos[i]+ans]&lt;=r)&#123; ++ans; &#125; &#125; for(int i=lblk[bl[r]];i&lt;=r;++i)&#123; while(pos[i]-ans&gt;=0&amp;&amp;set_pos[a[i]][pos[i]-ans]&gt;=l)&#123; ++ans; &#125; &#125; &#125; printf("%d\n",ans); lstans=ans; &#125; &#125;int main()&#123; n=io;qn=io; for(int i=1;i&lt;=n;++i)&#123; a[i]=ori[i]=io; &#125; sort(ori+1,ori+n+1); tot=unique(ori+1,ori+n+1)-ori-1; for(int i=1;i&lt;=n;++i)&#123; a[i]=lower_bound(ori+1,ori+tot+1,a[i])-ori; pos[i]=set_pos[a[i]].size(); set_pos[a[i]].pb(i); &#125; for(int i=1;i&lt;=n;++i)&#123; bl[i]=(i-1)/blk+1; &#125; nb=bl[n]; for(int i=1;i&lt;=nb;++i)&#123; lblk[i]=blk*(i-1)+1; rblk[i]=blk*i; &#125; rblk[nb]=n; for(int i=1;i&lt;=n;i+=blk)&#123; memset(cnt,0,sizeof(cnt)); int t=0; for(int j=i;j&lt;=n;++j)&#123; ++cnt[a[j]]; if(cnt[a[j]]&gt;t) t=cnt[a[j]]; if(rblk[bl[j]]==j)&#123; f[bl[i]][bl[j]]=t; &#125; &#125; &#125; MAIN(); return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板&复习]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%A8%A1%E6%9D%BF%26%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[基础把编辑器/编译器调到舒服的状态（见考试安排）学会用批处理和写对拍（见批处理）学会随机化生成（见随机化）学会离散化（这种最方便）12345678for(int i=1;i&lt;=n;++i)&#123; a[i]=ori[i]=io;&#125;sort(ori+1,ori+n+1);tot=unique(ori+1,ori+n+1)-ori-1;for(int i=1;i&lt;=n;++i)&#123; a[i]=lower_bound(ori+1,ori+tot+1,a[i])-ori;&#125; 掌握c风格输入输出123456789101112131415161718192021scanf：int -&gt; %dlong long -&gt; %lldunsigned int -&gt; %uunsigned long long -&gt; %llufloat -&gt; %fdouble -&gt; %lflong double -&gt; %Lfchar -&gt; %cchar a[] -&gt; %sprintf：int -&gt; %dlong long -&gt; %lldunsigned int -&gt; %uunsigned long long -&gt; %llufloat -&gt; %fdouble -&gt; %f （和scanf不一样！）long double -&gt; %Lfchar -&gt; %cchar a[] -&gt; %s 稳固代码风格：123456789++i只有函数的大括号换行，其他不换行用c风格输入输出无论什么系统，使用快读尽量用局部变量规定范围的常量用对应变量的大写命名主体在MAIN()中处理，在main()中做预处理，较长的函数要分段部分分写在namespace里所有函数加IL(inline) 附个模板：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,"r",stdin);#define fileout(s) freopen(s,"w",stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()int main()&#123; return 0;&#125; 分块&amp;莫队分块、莫队：暴力的加强版，思维难度小，代码量小，复杂度未必最优。（适合康复第一阶段训练）（具体题目&amp;代码见【学习笔记】分块&amp;莫队） 图论存图方式：1、邻接矩阵2、邻接表nume=1为了方便找反向边，=-1则head要设为-1（小于0即可）12345678910111213int nume=1,head[N];struct edge&#123; int to,nxt,f;&#125;e[M&lt;&lt;1];IL void add_edge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;for(int i=head[x];i;i=e[i].nxt)&#123; int to=e[i].to; ...&#125; 单元最短路径（spfa它死了）dijkstra：要求边权都是非负数1、稠密图（m和n^2同级别），复杂度n^22、稀疏图，堆优化，复杂度(m+n)logm（注意到logm和logn同级别）3、边权较小，桶优化，时间复杂度(m+n·最大边权），空间复杂度（n·最大边权+m）对于不同的条件，使用不同的方法找最小边权。 dijk基于贪心，只要一个点被选中标记之后，任何其他路径不会使它更优即可使用。spfa则是使图中的每条边都满足三角形不等式（不满足则存在不合题意的环），即对于边(x,y,z)，cal(dp[x],z)&gt;dp[y]，其中cal代表某种运算。 堆优化dijk123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,"r",stdin);#define fileout(s) freopen(s,"w",stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=100000+8,M=200000+8;int n,m,s;int x,y,z;int nume=1,head[N];struct edge&#123; int to,nxt,f;&#125;e[M&lt;&lt;1];IL void add_edge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[N];bool vis[N];priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt;pq;IL void dijk()&#123; memset(dis,0x3f,sizeof(dis)); //memset(vis,0,sizeof(vis)); dis[s]=0; pq.push(mp(0,s)); while(!pq.empty())&#123; int x=pq.top().se; pq.pop(); if(vis[x]) continue; vis[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; int to=e[i].to; if(dis[to]&gt;dis[x]+e[i].f)&#123; dis[to]=dis[x]+e[i].f; pq.push(mp(dis[to],to)); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; printf("%d ",dis[i]); &#125;&#125;int main()&#123; n=io;m=io;s=io; for(int i=1;i&lt;=m;++i)&#123; x=io;y=io;z=io; add_edge(x,y,z); //add_edge(y,x,z); &#125; dijk(); return 0;&#125; 01bfs：边权为0或1的图求单源最短路通过双端队列bfs，边权为0则从队头入队，边权为1从队尾入队。任意时刻保持队列的“两段性”和“单调性”一个点最多入队两次，可以用vis判断（不用也是正确的）。复杂度n+m luogu1948 [USACO08JAN]电话线Telephone Lines二分答案后转化成01bfs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#include&lt;deque&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,"r",stdin);#define fileout(s) freopen(s,"w",stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=1000+8,P=10000+8;int n,p,k;int ori[P],tot;int x,y,z;int nume=1,head[N];struct edge&#123; int to,nxt,f;&#125;e[P&lt;&lt;1];IL void add_edge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;deque&lt;int&gt; q;int dis[N];//bool vis[N];IL bool ok(int mid)&#123; q.clear(); memset(dis,0x3f,sizeof(dis)); //memset(vis,0,sizeof(vis)); dis[1]=0; q.pb(1); while(!q.empty())&#123;//每个值最多入队两次，+1和+0各入队一次 int x=q.front(); q.pop_front(); //if(vis[x]) continue; //vis[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; int to=e[i].to; if(dis[to]&gt;dis[x]+(e[i].f&gt;mid))&#123; dis[to]=dis[x]+(e[i].f&gt;mid); if(e[i].f&lt;=mid)&#123; q.push_front(to); &#125; else&#123; q.pb(to); &#125; &#125; &#125; &#125; return dis[n]&lt;=k;&#125;IL void MAIN()&#123; int l=0,r=tot,mid=0,ans=tot+1; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(ok(mid))&#123; ans=mid; r=mid-1; &#125; else&#123; l=mid+1; &#125; &#125; if(ans&lt;=tot) printf("%d",ori[ans]); else printf("-1");&#125;int main()&#123; n=io;p=io;k=io; for(int i=1;i&lt;=p;++i)&#123; x=io;y=io;z=io; ori[i]=z; add_edge(x,y,z); add_edge(y,x,z); &#125; sort(ori+1,ori+p+1); tot=unique(ori+1,ori+p+1)-ori-1; for(int i=2;i&lt;=nume;++i)&#123; e[i].f=lower_bound(ori+1,ori+tot+1,e[i].f)-ori; &#125; MAIN(); return 0;&#125; bzoj3073. [Pa2011]Journeys线段树建图后转化成01bfs 线段树建图的步骤：（from lvzelong2014）1、A树每个节点向父亲连边，B树每个节点向儿子连边。边权为零。2、每个B树的叶子节点向对应的A树的叶子节点连边。3、对于a~b连向c~d，在A树上找到a~b对应的区间u1,u2……un，将其连向虚拟节点p1，边权为04、虚拟节点p1到虚拟节点p2连上边权为1的边5、在B树上找到c~d对应的区间v1,v2……vn从p2连到这些区间，边权为0 3-5的连边为(a,b)-&gt;(c,d)，(c,d)-&gt;(a,b)要再连一次。也可以将p1,p2合并成一个点，然后将3或者5中边权改为1。点或边的数组开小了 就和线段树开小了一样常见的错误123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,"r",stdin);#define fileout(s) freopen(s,"w",stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=500000+8,M=100000+8;int n,m,p;int a,b,c,d;int numn;int nume,head[N*8+M*2];struct edge&#123; int to,nxt,f;&#125;e[N*9+M*4*25];IL void add_edge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;#define ls (t&lt;&lt;1)#define rs (t&lt;&lt;1|1)int tr1[N*4],tr2[N*4];IL void add1(int t,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; add_edge(tr1[t],numn,1); return; &#125; int mid=(l+r)&gt;&gt;1; if(ll&lt;=mid) add1(ls,l,mid,ll,rr); if(mid&lt;rr) add1(rs,mid+1,r,ll,rr);&#125; IL void add2(int t,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; add_edge(numn,tr2[t],0); return; &#125; int mid=(l+r)&gt;&gt;1; if(ll&lt;=mid) add2(ls,l,mid,ll,rr); if(mid&lt;rr) add2(rs,mid+1,r,ll,rr);&#125;IL void add()&#123; ++numn; add1(1,1,n,a,b); add2(1,1,n,c,d); ++numn; add1(1,1,n,c,d); add2(1,1,n,a,b);&#125;int be[N],en[N];IL void build1(int t,int l,int r)&#123; tr1[t]=++numn; if(l==r)&#123; be[l]=numn; return; &#125; int mid=(l+r)&gt;&gt;1; build1(ls,l,mid); build1(rs,mid+1,r); add_edge(tr1[ls],tr1[t],0); add_edge(tr1[rs],tr1[t],0);&#125;IL void build2(int t,int l,int r)&#123; tr2[t]=++numn; if(l==r)&#123; en[l]=numn; return; &#125; int mid=(l+r)&gt;&gt;1; build2(ls,l,mid); build2(rs,mid+1,r); add_edge(tr2[t],tr2[ls],0); add_edge(tr2[t],tr2[rs],0);&#125;IL void init()&#123; build1(1,1,n); build2(1,1,n); for(int i=1;i&lt;=n;++i)&#123; add_edge(en[i],be[i],0);// &#125;&#125;int dis[N*8+M*2];deque&lt;int&gt; q;IL void bfs01()&#123; memset(dis,0x3f,sizeof(dis)); dis[be[p]]=0; q.pb(be[p]); while(!q.empty())&#123; int x=q.front(); q.pop_front(); for(int i=head[x];i;i=e[i].nxt)&#123; int to=e[i].to; if(dis[to]&gt;dis[x]+e[i].f)&#123; dis[to]=dis[x]+e[i].f; if(e[i].f) q.pb(to); else q.push_front(to); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; //if(i!=p) printf("%d\n",dis[en[i]]); //else printf("0\n"); printf("%d\n",dis[be[i]]); &#125;&#125;int main()&#123; n=io;m=io;p=io; init(); for(int i=1;i&lt;=m;++i)&#123; a=io;b=io;c=io;d=io; add(); &#125; bfs01(); return 0;&#125; 手写队列：1、普通队列 he=1,ta=0;q[++ta]=x;while(he&lt;=ta){…}2、循环队列 he=1,ta=1;q[ta++]=x;while(he!=ta){…} luogu3008 [USACO11JAN]道路和飞机Roads and Planes缩点+拓扑+dijk123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,"r",stdin);#define fileout(s) freopen(s,"w",stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=25000+8,M=50000+8;int n,r,p,s;int x,y,z;int nume=1,head[N];struct edge&#123; int to,nxt,f;&#125;e[M*3];IL void add_edge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int num,bl[N];vector&lt;int&gt; v[N];IL void dfs(int x)&#123; bl[x]=num; v[num].pb(x); for(int i=head[x];i;i=e[i].nxt)&#123; int to=e[i].to; if(!bl[to])&#123; dfs(to); &#125; &#125;&#125;int ind[N];int q[N],he,ta;int dis[N];bool vis[N];priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; pq; IL void solve(int t)&#123; while(!pq.empty()) pq.pop(); for(int i=0;i&lt;v[t].size();++i)&#123; pq.push(mp(dis[v[t][i]],v[t][i])); &#125; while(!pq.empty())&#123; int x=pq.top().second; pq.pop(); if(vis[x]) continue; vis[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; int to=e[i].to; if(dis[to]&gt;dis[x]+e[i].f)&#123; dis[to]=dis[x]+e[i].f; if(bl[to]==bl[x])&#123; pq.push(mp(dis[to],to)); &#125; &#125; if(bl[to]!=bl[x])&#123; --ind[bl[to]]; if(!ind[bl[to]]) q[++ta]=bl[to]; &#125; &#125; &#125;&#125;IL void MAIN()&#123; he=1;ta=0; if(ind[bl[s]]) q[++ta]=bl[s]; for(int i=1;i&lt;=num;++i)&#123; if(!ind[i]) q[++ta]=i; &#125; memset(dis,0x3f,sizeof(dis)); dis[s]=0; while(he&lt;=ta)&#123; int x=q[he]; ++he; solve(x); &#125; for(int i=1;i&lt;=n;++i)&#123; if(dis[i]&gt;5e8) printf("NO PATH\n");//不能用if(dis[i]==0x3f3f3f3f)，因为存在负边权 else printf("%d\n",dis[i]); &#125;&#125;int main()&#123; n=io;r=io;p=io;s=io; for(int i=1;i&lt;=r;++i)&#123; x=io;y=io;z=io; add_edge(x,y,z); add_edge(y,x,z); &#125; for(int i=1;i&lt;=n;++i)&#123; if(!bl[i])&#123; ++num; dfs(i); &#125; &#125; for(int i=1;i&lt;=p;++i)&#123; x=io;y=io;z=io; ++ind[bl[y]]; add_edge(x,y,z); &#125; MAIN(); return 0;&#125; 任意两点间最短路dijk n^3或nmlogmfloyd n^3（还可以用于解决传递闭包） 最大流dinic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,"r",stdin);#define fileout(s) freopen(s,"w",stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=10000+8,M=100000+8;int n,m,s,t;int x,y,z;int nume=1,head[N];struct edge&#123; int to,nxt,f;&#125;e[M*2];IL void add_edge_2(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(edge)&#123;x,head[y],0&#125;;head[y]=nume;&#125;int cur[N];int dis[N];int q[N],he,ta;IL int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp=0; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; int to=e[i].to; if(dis[to]==dis[x]+1&amp;&amp;(tmp=dfs(to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;IL bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=0; q[++ta]=s; dis[s]=1; while(he&lt;=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; int to=e[i].to; if(!dis[to]&amp;&amp;e[i].f)&#123; dis[to]=dis[x]+1; q[++ta]=to; if(to==t) return 1; &#125; &#125; &#125; return 0;&#125;IL void dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=1;i&lt;=n;++i) cur[i]=head[i]; maxflow+=dfs(s,INT_MAX); &#125; printf("%d",maxflow);&#125;int main()&#123; n=io;m=io;s=io;t=io; for(int i=1;i&lt;=m;++i)&#123; x=io;y=io;z=io; add_edge_2(x,y,z); &#125; dinic(); return 0;&#125; 数论线性筛123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,"r",stdin);#define fileout(s) freopen(s,"w",stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=10000000+8;int n,qn;int min_p[N],pri[N],num;int main()&#123; n=io;qn=io; for(int i=2;i&lt;=n;++i)&#123; if(!min_p[i])&#123; min_p[i]=i; pri[++num]=i; &#125; for(int j=1;j&lt;=num&amp;&amp;pri[j]&lt;=min_p[i]&amp;&amp;pri[j]&lt;=n/i;++j)&#123; min_p[pri[j]*i]=pri[j]; &#125; &#125; while(qn--)&#123; int x=io; printf(min_p[x]==x?"Yes\n":"No\n"); &#125; return 0;&#125; 快速幂1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,"r",stdin);#define fileout(s) freopen(s,"w",stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()LL a,b,mod;IL LL ksm(LL a,LL b)&#123; LL tmp=1%mod; while(b)&#123; if(b&amp;1) tmp=tmp*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return tmp;&#125;int main()&#123; a=io;b=io;mod=io; printf("%lld^%lld mod %lld=%lld",a,b,mod,ksm(a,b)); return 0;&#125; luogu2568 GCD所求为sum{prime}sum(2*sum(phi[i])(i=1 to n/prime)-1)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,"r",stdin);#define fileout(s) freopen(s,"w",stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=10000000+8;int n;int phi[N],min_p[N],pri[N],num;LL sum[N],ans;int main()&#123; n=io; phi[1]=1; sum[1]=1; for(int i=2;i&lt;=n;++i)&#123; if(!min_p[i])&#123; min_p[i]=i; pri[++num]=i; phi[i]=i-1; &#125; for(int j=1;j&lt;=num&amp;&amp;pri[j]&lt;=min_p[i]&amp;&amp;pri[j]&lt;=n/i;++j)&#123; min_p[i*pri[j]]=pri[j]; phi[i*pri[j]]=phi[i]*(i%pri[j]?pri[j]-1:pri[j]); &#125; sum[i]=sum[i-1]+phi[i]; &#125; for(int i=1;i&lt;=num;++i)&#123; ans+=sum[n/pri[i]]*2-1; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>分块</tag>
        <tag>二分</tag>
        <tag>莫队</tag>
        <tag>基础</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F07%2Ffy%E7%9A%84%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[from 23forever 数据结构并查集:1234567891011121314151617181920212223struct Ufs &#123; int n, fa[MAXN + 5], rk[MAXN + 5]; void operator() (const int _n) &#123; n = _n; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; rk[i] = 1; &#125; &#125; int find(int x) &#123; return fa[x] == x ? fa[x] : fa[x] = find(fa[x]); &#125; void unionSet(int x, int y) &#123; int p = find(x), q = find(y); if (p == q) return; if (rk[p] &lt; rk[q]) &#123; fa[p] = q; &#125; else &#123; if (rk[p] == rk[q]) ++rk[q]; fa[q] = p; &#125; &#125;&#125;DSU; 字符串hash:123456ULL getHsh(char *s) &#123; int len = strlen(s); ULL ret = 0; for (int i = 0; i &lt; len; ++i) ret = ret * P + s[i]; return ret;&#125; 树状数组123456789101112131415161718struct BinaryIndexTree &#123; int n, c[MAXN + 5]; void operator() (int _n) &#123; n = _n; memset(c, 0, sizeof(c)); &#125; int lowbit(int x) &#123; return x &amp; (-x); &#125; void modify(int x, int v) &#123; for (; x &lt;= n; x += lowbit(x)) c[x] += v; &#125; int getSum(int x) &#123; int ret = 0; for (; x; x -= lowbit(x)) ret += c[x]; return ret; &#125;&#125; Bit; ST表：1234567891011121314151617void init() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= n; ++i) st[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; int a = st[i][j - 1], b = st[i + (1 &lt;&lt; (j - 1))][j - 1]; st[i][j] = max(a, b); &#125; &#125;&#125;inline int query(int x, int y) &#123; int k = log2(y - x + 1); int a = st[x][k], b = st[y - (1 &lt;&lt; k) + 1][k]; return max(a, b);&#125; KMP：1234567891011121314151617void getFail() &#123; fail[0] = 0; fail[1] = 0; for (int i = 1; i &lt;= m; ++i) &#123; int j = fail[i]; while (j &amp;&amp; p[i] != p[j]) j = fail[j]; fail[i + 1] = p[i] == p[j] ? j + 1 : 0; &#125;&#125;void calc() &#123; int j = 0; for (int i = 0; i &lt;= n; ++i) &#123; while (j &amp;&amp; t[i] != p[j]) j = fail[j]; if (t[i] == p[j]) ++j; if (j == m) printf(&quot;%d\n&quot;, i - m + 2); &#125;&#125; manacher：12345678910111213141516171819int manacher() &#123; int ret = 0; s[n++] = &apos;$&apos;; s[n++] = &apos;#&apos;; for (int i = 0; i &lt; len; ++i) &#123; s[n++] = a[i]; s[n++] = &apos;#&apos;; &#125; for (int i = 0; i &lt; n; ++i) &#123; f[i] = i &lt; mx ? min(f[2 * id - i], mx - i) : 1; while (s[i + f[i]] == s[i - f[i]]) ++f[i]; if (f[i] + i &gt; mx) &#123; mx = f[i] + i; id = i; &#125; ret = max(ret, f[i]); &#125; return --ret;&#125; 线段树：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374struct SegmentTree &#123; struct Node &#123; LL delta, mul, sum; &#125;s[MAXN * 4 + 5]; SegmentTree() &#123;&#125; #define lson p &lt;&lt; 1 #define rson p &lt;&lt; 1 | 1 void add(int p, int len, LL v) &#123; s[p].delta = (s[p].delta + v) % mod; s[p].sum = (s[p].sum + v * len) % mod; &#125; void mul(int p, LL v) &#123; s[p].mul = s[p].mul * v % mod; s[p].delta = s[p].delta * v % mod; s[p].sum = s[p].sum * v % mod; &#125; void pd(int p, int len) &#123; if (s[p].mul != 1) &#123; mul(lson, s[p].mul); mul(rson, s[p].mul); s[p].mul = 1; &#125; if (s[p].delta) &#123; add(lson, len - len / 2, s[p].delta); add(rson, len / 2, s[p].delta); s[p].delta = 0; &#125; &#125; void upd(int p) &#123; s[p].sum = (s[lson].sum + s[rson].sum) % mod; &#125; void build(int p, int l, int r) &#123; s[p].mul = 1; if (l == r) &#123; s[p].sum = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); upd(p); &#125; void modify(int p, int l, int r, int x, int y, LL v) &#123; if (x &lt;= l &amp;&amp; y &gt;= r) &#123; add(p, r - l + 1, v); return; &#125; pd(p, r - l + 1); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) modify(lson, l, mid, x, y, v); if (y &gt; mid) modify(rson, mid + 1, r, x, y, v); upd(p); &#125; void update(int p, int l, int r, int x, int y, LL v) &#123; if (x &lt;= l &amp;&amp; y &gt;= r) &#123; mul(p, v); return; &#125; pd(p, r - l + 1); int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(lson, l, mid, x, y, v); if (y &gt; mid) update(rson, mid + 1, r, x, y, v); upd(p); &#125; LL query(int p, int l, int r, int x, int y) &#123; if (x &lt;= l &amp;&amp; y &gt;= r) return s[p].sum % mod; pd(p, r - l + 1); int mid = (l + r) &gt;&gt; 1; LL ret = 0; if (x &lt;= mid) ret = query(lson, l, mid, x, y); if (y &gt; mid) ret = (ret + query(rson, mid + 1, r, x, y)) % mod; return ret; &#125;&#125;Sgt; AC自动机：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061struct ACAutomaton &#123; int tot, trie[MAXN + 5][CS], cnt[MAXN + 5]; int fail[MAXN + 5], val[MAXN + 5]; queue&lt;int&gt; que; ACAutomaton() &#123;&#125; void init() &#123; tot = 0; memset(fail, 0, sizeof(fail)); memset(cnt, 0, sizeof(cnt)); memset(val, 0, sizeof(val)); memset(trie, 0, sizeof(trie)); &#125; void insert(char *p, int id) &#123; int m = strlen(p), now = 0; for (int i = 0; i &lt; m; ++i) &#123; int c = p[i] - &apos;a&apos;; if (!trie[now][c]) trie[now][c] = ++tot; now = trie[now][c]; &#125; val[now] = id; &#125; void getFail() &#123; for (int i = 0; i &lt; CS; ++i) &#123; int u = trie[0][i]; if (u) &#123; fail[u] = 0; que.push(u); &#125; &#125; while (!que.empty()) &#123; int cur = que.front(); que.pop(); for (int i = 0; i &lt; CS; ++i) &#123; int u = trie[cur][i]; if (u) &#123; fail[u] = trie[fail[cur]][i]; que.push(u); &#125; else &#123; trie[cur][i] = trie[fail[cur]][i]; &#125; &#125; &#125; &#125; void query(char *t) &#123; int n = strlen(t), now = 0; for (int i = 0; i &lt; n; ++i) &#123; now = trie[now][t[i] - &apos;a&apos;]; int j = now; while (j) &#123; if (val[j]) ++cnt[val[j]]; j = fail[j]; &#125; &#125; int mx = 0; for (int i = 1; i &lt;= n; ++i) mx = max(mx, cnt[i]); printf(&quot;%d\n&quot;, mx); for (int i = 1; i &lt;= n; ++i) &#123; if (cnt[i] == mx) puts(p[i]); &#125; &#125;&#125;AC; 线性基：1234567891011121314151617181920struct LinearBasis &#123; LL b[MAXL + 5]; void insert(LL x) &#123; for (int i = MAXL; ~i; --i) &#123; if (x &amp; (1LL &lt;&lt; i)) &#123; if (!b[i]) &#123; b[i] = x; return; &#125; else &#123; x ^= b[i]; &#125; &#125; &#125; &#125; LL query() &#123; LL ret = 0; for (int i = MAXL; ~i; --i) ret = max(ret, (b[i] ^ ret)); return ret; &#125;&#125;LB; 左偏树：123456789101112131415161718192021222324252627282930313233343536373839struct Heap &#123; int ls, rs, val, fa, dis;&#125;h[MAXN + 5];struct LeftistHeap &#123; #define u h[x] #define uls h[u.ls] #define urs h[u.rs] #define o h[y] LeftistHeap() &#123; h[0].val = -1; &#125; int find(int x) &#123; return u.fa ? find(u.fa) : x; &#125; int merge(int x, int y) &#123; if (!x || !y) return x + y; if (u.val &gt; o.val || (u.val == o.val &amp;&amp; x &gt; y)) swap(x, y); u.rs = merge(u.rs, y); urs.fa = x; if (uls.dis &lt; urs.dis) swap(u.ls, u.rs); u.dis = urs.dis + 1; return x; &#125; void delNode(int x) &#123; u.val = -1; uls.fa = 0; urs.fa = 0; &#125; int top(int x) &#123; return u.val; &#125; void del(int x) &#123; delNode(x); merge(u.ls, u.rs); &#125; void build(int x, int v) &#123; u.val = v; &#125;&#125;SH; 非旋treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990struct Treap &#123; int ls, rs, sz, key, val; bool rev; Treap() &#123;&#125;&#125;t[MAXN + 5];struct FhqTreap &#123; int tot; #define u t[x] #define uls t[u.ls] #define urs t[u.rs] #define o t[y] #define ols t[o.ls] #define ors t[o.rs] FhqTreap() &#123;&#125; void createNode(int x) &#123; t[++tot].val = x; t[tot].sz = 1; t[tot].key = rand(); &#125; void upd(int x) &#123; u.sz = uls.sz + urs.sz + 1; &#125; void rev(int x) &#123; u.rev ^= 1; &#125; void pd(int x) &#123; if (u.rev) &#123; if (u.ls) rev(u.ls); if (u.rs) rev(u.rs); swap(u.ls, u.rs); u.rev ^= 1; &#125; &#125; pii split(int x, int n) &#123; if (!n) return mp(0, x); pd(x); int m = uls.sz; if (n == m) &#123; int tmp = u.ls; u.ls = 0; upd(x); return mp(tmp, x); &#125; else if (n == m + 1) &#123; int tmp = u.rs; u.rs = 0; upd(x); return mp(x, tmp); &#125; else if (n &lt; m) &#123; pii tmp = split(u.ls, n); u.ls = tmp.se; upd(x); return mp(tmp.fi, x); &#125; pii tmp = split(u.rs, n - m - 1); u.rs = tmp.fi; upd(x); return mp(x, tmp.se); &#125; int merge(int x, int y) &#123; if (!x || !y) return x + y; if (u.key &lt; o.key) &#123; pd(x); u.rs = merge(u.rs, y); upd(x); return x; &#125; else &#123; pd(y); o.ls = merge(x, o.ls); upd(y); return y; &#125; &#125; void insert(int k, int x) &#123; pii tmp = split(rt, k - 1); createNode(x); rt = merge(tmp.fi, merge(tot, tmp.se)); &#125; void rever(int x, int y) &#123; pii tmp1 = split(rt, x - 1), tmp2 = split(tmp1.se, y - x + 1); t[tmp2.fi].rev ^= 1; rt = merge(merge(tmp1.fi, tmp2.fi), tmp2.se); &#125; void print(int x) &#123; if (!x) return; pd(x); print(u.ls); printf(&quot;%d &quot;, u.val); print(u.rs); &#125;&#125;T; 主席树：12345678910111213141516171819202122232425262728293031struct ChairTree &#123; struct Node &#123; int ls, rs, sz; &#125;s[MAXN * 60 + 5]; int tot; #define lson s[p].ls #define rson s[p].rs ChairTree() &#123;&#125; void insert(int &amp;p, int l, int r, int x) &#123; s[++tot] = s[p]; p = tot; ++s[p].sz; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) &#123; insert(lson, l, mid, x); &#125; else &#123; insert(rson, mid + 1, r, x); &#125; &#125; int query(int rtl, int rtr, int l, int r, int k) &#123; if (l == r) return l; int sz = s[s[rtr].ls].sz - s[s[rtl].ls].sz; int mid = (l + r) &gt;&gt; 1; if (k &lt;= sz) &#123; return query(s[rtl].ls, s[rtr].ls, l, mid, k); &#125; else &#123; return query(s[rtl].rs, s[rtr].rs, mid + 1, r, k - sz); &#125; &#125;&#125;CT; LCT：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586struct LinkCutTree &#123; struct Node &#123; int ch[2], fa; bool rev; &#125;s[MAXN + 5]; #define ls ch[0] #define rs ch[1] #define u s[x] #define uls s[u.ls] #define urs s[u.rs] #define ufa s[u.fa] #define o s[y] #define ols s[s[y].ls] #define ors s[s[y].rs] #define ofa s[s[z].fa] #define v s[z] #define vls s[s[z].ls] #define vrs s[s[z].rs] int top, st[MAXN + 5]; void pd(int x) &#123; if (u.rev) &#123; u.rev ^= 1; uls.rev ^= 1; urs.rev ^= 1; swap(u.ls, u.rs); &#125; &#125; bool isRoot(int x) &#123; return ufa.ls != x &amp;&amp; ufa.rs != x; &#125; void rotate(int x) &#123; int y = u.fa, z = o.fa, l, r; if (o.ls == x) &#123; l = 0; &#125; else &#123; l = 1; &#125; r = l ^ 1; if (!isRoot(y)) &#123; if (v.ls == y) &#123; v.ls = x; &#125; else &#123; v.rs = x; &#125; &#125; u.fa = z; o.fa = x; s[u.ch[r]].fa = y; o.ch[l] = u.ch[r]; u.ch[r] = y; &#125; void splay(int x) &#123; top = 0; st[++top] = x; for (int i = x; !isRoot(i); i = s[i].fa) &#123; st[++top] = s[i].fa; &#125; for (int i = top; i; --i) pd(st[i]); while (!isRoot(x)) &#123; int y = u.fa, z = o.fa; if (!isRoot(y)) &#123; if (v.ls == y ^ o.ls == x) &#123; rotate(x); &#125; else &#123; rotate(y); &#125; &#125; rotate(x); &#125; &#125; void access(int x) &#123; for (int last = 0; x; last = x, x = u.fa) &#123; splay(x); u.rs = last; &#125; &#125; void makeRoot(int x) &#123; access(x); splay(x); u.rev ^= 1; &#125; void link(int x, int y) &#123; makeRoot(x); u.fa = y; &#125;&#125;LCT; 后缀数组：123456789101112131415161718192021222324252627282930313233bool cmp(int i, int j, int k) &#123; return y[i] == y[j] &amp;&amp; y[i + k] == y[j + k];&#125;void getSA(int m) &#123; for (int i = 1; i &lt;= m; ++i) b[i] = 0; for (int i = 1; i &lt;= n; ++i) ++b[x[i] = r[i]]; for (int i = 1; i &lt;= m; ++i) b[i] += b[i - 1]; for (int i = n; i; --i) sa[b[x[i]]--] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for (int i = n - k + 1; i &lt;= n; ++i) y[++p] = i; for (int i = 1; i &lt;= n; ++i) if (sa[i] &gt; k) y[++p] = sa[i] - k; for (int i = 1; i &lt;= m; ++i) b[i] = 0; for (int i = 1; i &lt;= n; ++i) ++b[x[y[i]]]; for (int i = 1; i &lt;= m; ++i) b[i] += b[i - 1]; for (int i = n; i; --i) sa[b[x[y[i]]]--] = y[i]; swap(x, y); p = 1, x[sa[1]] = 1; for (int i = 2; i &lt;= n; ++i) x[sa[i]] = cmp(sa[i], sa[i - 1], k) ? p : ++p; m = p; if (m == n) break; &#125;&#125;void getHeight() &#123; int k = 0; for (int i = 1; i &lt;= n; ++i) rk[sa[i]] = i; for (int i = 1; i &lt;= n; ++i) &#123; if (k) --k; int j = sa[rk[i] - 1]; while (r[i + k] == r[j + k]) ++k; height[rk[i]] = k; &#125;&#125; 后缀自动机:1234567891011121314151617181920212223242526272829303132333435struct SuffixAutomaton &#123; int last, tot; int trans[MAXN + 5][CS], link[MAXN + 5], len[MAXN + 5], sz[MAXN + 5]; int id[MAXN + 5], pre[MAXN + 5]; SuffixAutomaton() : last(1), tot(1) &#123;&#125; void extend(int x) &#123; int c = x - &apos;a&apos;, cur = ++tot, p = last; len[cur] = len[last] + 1; while (p &amp;&amp; !trans[p][c]) &#123; trans[p][c] = cur; p = link[p]; &#125; if (!p) &#123; link[cur] = 1; &#125; else &#123; int q = trans[p][c]; if (len[p] + 1 == len[q]) &#123; link[cur] = q; &#125; else &#123; int nq = ++tot; len[nq] = len[p] + 1; memcpy(trans[nq], trans[q], sizeof(trans[q])); while (p &amp;&amp; trans[p][c] == q) &#123; trans[p][c] = nq; p = link[p]; &#125; link[nq] = link[q]; link[q] = nq; link[cur] = nq; &#125; &#125; sz[cur] = 1; last = cur; &#125;&#125;SAM; 树链剖分:123456789101112131415161718192021222324void buildTree(int u) &#123; depth[u] = depth[fa[u]] + 1; sz[u] = 1; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if (v != fa[u]) &#123; fa[v] = u; buildTree(v); sz[u] += sz[v]; if (sz[son[u]] &lt; sz[v]) son[u] = v; &#125; &#125;&#125;void buildChain(int u, int topf) &#123; top[u] = topf; id[u] = ++cnt; mp[id[u]] = u; if (!son[u]) return; buildChain(son[u], topf); for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if (v != fa[u] &amp;&amp; v != son[u]) buildChain(v, v); &#125;&#125; 图论spfa：123456789101112131415161718192021void spfa(const int s) &#123; memset(d, 0x3f, sizeof(d)); que.push(s); d[s] = 0; in_que[s] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(); in_que[u] = false; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to, w = edge[i].w; if (d[u] + w &lt; d[v]) &#123; d[v] = d[u] + w; if (!in_que[v]) &#123; in_que[v] = true; que.push(v); &#125; &#125; &#125; &#125;&#125; dijkstra：123456789101112131415161718void dijkstra(const int s) &#123; memset(d, 0x3f, sizeof(d)); Q.push(Node(s, 0)); d[s] = 0; while (!Q.empty()) &#123; int u = Q.top().u; Q.pop(); if (vis[u]) continue; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to, w = edge[i].w; if (d[u] + w &lt; d[v]) &#123; d[v] = d[u] + w; if (!vis[v]) Q.push(Node(v, d[v])); &#125; &#125; vis[u] = true; &#125;&#125; prim：12345678910111213141516171819202122int prim(const int s) &#123; memset(d, 0x3f, sizeof(d)); Q.push(HeapNode(s, 0)); d[s] = 0; int cnt = 0, ret = 0; while (!Q.empty()) &#123; int u = Q.top().u; Q.pop(); if (vis[u]) continue; ++cnt; ret += d[u]; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to, w = edge[i].w; if (d[v] &gt; w) &#123; d[v] = w; if (!vis[v]) Q.push(HeapNode(v, w)); &#125; &#125; vis[u] = true; &#125; return cnt &lt; n ? -1 : ret;&#125; kruskal：12345678910111213int kruskal() &#123; sort(e + 1, e + 1 + m); int ret = 0, cnt = n; for (int i = 1; i &lt;= m; ++i) &#123; int u = e[i].u, v = e[i].v, w = e[i].w; if (DSU.find(u) != DSU.find(v)) &#123; DSU.unionSet(u, v); ret += w; --cnt; &#125; &#125; return cnt == 1 ? ret : -1;&#125; 倍增求LCA：123456789101112131415161718192021222324252627282930313233343536373839404142void buildTree(int u, int fa) &#123; an[u][0] = fa; depth[u] = depth[fa] + 1; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if (v == fa) continue; buildTree(v, u); &#125;&#125;int LCA(int u, int v) &#123; if (depth[u] &lt; depth[v]) swap(u, v); int k = depth[u] - depth[v]; for (int i = 0; (1 &lt;&lt; i) &lt;= k; ++i) &#123; if (k &amp; (1 &lt;&lt; i)) u = an[u][i]; &#125; if (u == v) return u; for (int i = MAXL - 1; ~i; --i) &#123; if (an[u][i] != an[v][i]) &#123; u = an[u][i]; v = an[v][i]; &#125; &#125; return an[u][0];&#125;void init() &#123; //enableFileIO(); tot = 0; memset(head, -1, sizeof(head)); n = read(); m = read(); rt = read(); for (int i = 1; i &lt; n; ++i) &#123; int u = read(), v = read(); add(u, v); &#125; buildTree(rt, 0); for (int i = 1; i &lt; MAXL; ++i) &#123; for (int u = 1; u &lt;= n; ++u) &#123; an[u][i] = an[an[u][i - 1]][i - 1]; &#125; &#125;&#125; 二分图匹配:12345678910111213bool hungary(int u) &#123; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if (!vis[v]) &#123; vis[v] = true; if (!res[v] || hungary(res[v])) &#123; res[v] = u; return true; &#125; &#125; &#125; return false;&#125; 求无向图割点：1234567891011121314151617void tarjan(int u) &#123; dfn[u] = low[u] = ++ind; int sum = 0; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); if (dfn[u] &lt;= low[v]) &#123; ++sum; if (u != rt || sum &gt; 1) is_cut[u] = true; &#125; &#125; else &#123; low[u] = min(low[u], dfn[v]); &#125; &#125;&#125; spfa判负环：1234567891011121314151617181920212223242526bool spfa(const int s) &#123; memset(d, 0x3f, sizeof(d)); memset(in_que, false, sizeof(in_que)); memset(cnt, 0, sizeof(cnt)); que.push(s); in_que[s] = true; d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); in_que[u] = false; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to, w = edge[i].w; if (d[u] + w &lt; d[v]) &#123; d[v] = d[u] + w; cnt[v] = cnt[u] + 1; if (cnt[v] &gt;= n) return false; if (!in_que[v]) &#123; que.push(v); in_que[v] = true; &#125; &#125; &#125; &#125; return true;&#125; tarjan缩点：12345678910111213141516171819202122232425void tarjan(int u) &#123; dfn[u] = low[u] = ++ind; sta.push(u); in_sta[u] = true; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (in_sta[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if (low[u] == dfn[u]) &#123; int k; sum[++scc_num] = 0; do &#123; k = sta.top(); belong[k] = scc_num; sum[scc_num] += val[k]; in_sta[k] = false; sta.pop(); &#125; while (k != u); &#125;&#125; 拓扑排序：1234567891011121314151617void topsort() &#123; for (int i = 1; i &lt;= scc_num; ++i) &#123; if (!in[i]) &#123; d[i] = sum[i]; que.push(i); &#125; &#125; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = h[u]; ~i; i = e[i].nxt) &#123; int v = e[i].to; d[v] = max(d[v], d[u] + sum[v]); if (!--in[v]) que.push(v); &#125; &#125;&#125; dinic求最大流：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct Dinic &#123; int level[MAXN + 5], cur[MAXN + 5]; queue&lt;int&gt; que; bool makeLevelGraph(const int s, const int t) &#123; memset(level, 0, sizeof(level)); while (!que.empty()) que.pop(); que.push(s); level[s] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to, cap = edge[i].cap; if (cap &amp;&amp; !level[v]) &#123; level[v] = level[u] + 1; que.push(v); &#125; &#125; if (level[t]) return true; &#125; return false; &#125; int findAugPath(int u, int t, int flow) &#123; if (u == t || !flow) return flow; int used = 0; for (int &amp;i = cur[u]; ~i &amp;&amp; used &lt; flow; i = edge[i].nxt) &#123; int v = edge[i].to, &amp;cap = edge[i].cap, &amp;rcap = edge[i ^ 1].cap; if (cap &amp;&amp; level[v] == level[u] + 1) &#123; int d = findAugPath(v, t, min(flow - used, cap)); if (d) &#123; used += d; rcap += d; cap -= d; return d; &#125; else &#123; level[v] = -INF; &#125; &#125; &#125; return 0; &#125; int operator()(const int s, const int t) &#123; int ret = 0, f; while (makeLevelGraph(s, t)) &#123; memcpy(cur, head, sizeof(head)); while (f = findAugPath(s, t, INF)) ret += f; &#125; return ret; &#125;&#125;dinic; 最小费用最大流：123456789101112131415161718192021222324252627282930313233343536373839404142434445struct Mfmc &#123; int d[MAXN + 5], pre[MAXN + 5], id[MAXN + 5]; queue&lt;int&gt; que; bool in_que[MAXN + 5]; bool spfa(const int s, const int t) &#123; memset(d, 0x3f, sizeof(d)); memset(pre, -1, sizeof(pre)); que.push(s); d[s] = 0; pre[s] = 0; in_que[s] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(); in_que[u] = false; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to, cap = edge[i].cap, cost = edge[i].cost; if (cap &amp;&amp; d[u] + cost &lt; d[v]) &#123; d[v] = d[u] + cost; pre[v] = u; id[v] = i; if (!in_que[v]) &#123; in_que[v] = true; que.push(v); &#125; &#125; &#125; &#125; return ~pre[t]; &#125; pii operator()(const int s, const int t) &#123; int min_cost = 0, max_flow = 0; while (spfa(s, t)) &#123; int f = INF; for (int u = t; u != s; u = pre[u]) f = min(f, edge[id[u]].cap); for (int u = t; u != s; u = pre[u]) &#123; edge[id[u]].cap -= f; edge[id[u] ^ 1].cap += f; &#125; max_flow += f; min_cost += f * d[t]; &#125; return mp(max_flow, min_cost); &#125;&#125;mfmc; 2-sat：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869stack&lt;int&gt; sta;bool in_sta[MAXN + 5];int dfn[MAXN + 5], low[MAXN + 5], idx, scc_num, belong[MAXN + 5];void tarjan(int u) &#123; dfn[u] = low[u] = ++idx; sta.push(u); in_sta[u] = true; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (in_sta[v]) &#123; low[u] = min(low[u], dfn[v]); &#125; &#125; if (dfn[u] == low[u]) &#123; int k; ++scc_num; do &#123; k = sta.top(); belong[k] = scc_num; in_sta[k] = false; sta.pop(); &#125; while (k != u); &#125;&#125;int n, m;void init() &#123; //enableFileIO(); tot = 0; memset(head, -1, sizeof(head)); n = read(); m = read(); for (int i = 1; i &lt;= m; ++i) &#123; int u = read(), a = read(), v = read(), b = read(); if (a &amp;&amp; b) &#123; add(u + n, v); add(v + n, u); &#125; else if (!a &amp;&amp; b) &#123; add(v + n, u + n); add(u, v); &#125; else if (a &amp;&amp; !b) &#123; add(u + n, v + n); add(v, u); &#125; else &#123; add(u, v + n); add(v, u + n); &#125; &#125;&#125;int main() &#123; init(); for (int i = 1; i &lt;= 2 * n; ++i) &#123; if (!dfn[i]) tarjan(i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (belong[i] == belong[i + n]) &#123; puts(&quot;IMPOSSIBLE&quot;); return 0; &#125; &#125; puts(&quot;POSSIBLE&quot;); for (int i = 1; i &lt;= n; ++i) &#123; printf(&quot;%d &quot;, belong[i] &lt; belong[i + n]); &#125; printf(&quot;\n&quot;); return 0;&#125; 数论快速幂：12345678910LL fastPow(LL b, LL p, LL m) &#123; LL ret = 1; b %= m; while (p) &#123; if (p &amp; 1) ret = ret % m * b % m; b = b % m * b % m; p &gt;&gt;= 1; &#125; return ret % m;&#125; 埃氏筛：123456for (int i = 2; i &lt;= n; ++i) &#123; if (c[i]) continue; for (int j = i; j &lt;= n / i; ++j) &#123; c[i * j] = true; &#125; &#125; 求1-n的phi值12345678for (int i = 2; i &lt;= n; ++i) phi[i] = i;for (int i = 2; i &lt;= n; ++i) &#123; if (phi[i] == i) &#123; for (int j = i; j &lt;= n; j += i) &#123; phi[j] = phi[j] / i * (i - 1); &#125; &#125;&#125; 求1-n的所有约数12345for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n / i; ++j) &#123; fac[i * j].push_back(i); &#125;&#125; 矩阵快速幂：1234567891011121314151617181920212223242526272829303132333435363738struct Matrix &#123; LL a[MAXN + 5][MAXN + 5]; int n, m; Matrix() &#123;&#125; Matrix(int _n, int _m) : n(_n), m(_m) &#123; memset(a, 0, sizeof(a)); &#125; void operator() (int _n, int _m) &#123; n = _n; m = _m; memset(a, 0, sizeof(a)); &#125; void init() &#123; memset(a, 0, sizeof(a)); for (int i = 1; i &lt;= n; ++i) a[i][i] = 1; &#125; Matrix operator * (const Matrix &amp;mat) &#123; Matrix ret(n, m); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; for (int k = 1; k &lt;= mat.n; ++k) &#123; ret.a[i][j] = (ret.a[i][j] + a[i][k] * mat.a[k][j]) % MOD; &#125; &#125; &#125; return ret; &#125;&#125;a;Matrix fastPow(Matrix mat, LL k) &#123; Matrix ret(mat.n, mat.m); ret.init(); while (k) &#123; if (k &amp; 1) ret = ret * mat; mat = mat * mat; k &gt;&gt;= 1; &#125; return ret;&#125; 线性求逆元：1234567int main() &#123; init(); ans[1] = 1; for (int i = 2; i &lt;= n; ++i) ans[i] = 1LL * (p - p / i) * ans[p % i] % p; for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\n&quot;, ans[i]); return 0;&#125; 快速乘：123456789LL fastMul(LL b, LL p, LL m) &#123; LL ret = 0; while (p) &#123; if (p &amp; 1) ret = (ret + b) % m; b = (b + b) % m; p &gt;&gt;= 1; &#125; return ret;&#125; 拓展欧几里得：123456789LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; LL g = exgcd(b, a % b, x, y), tmp = x; x = y, y = tmp - a / b * y; return g;&#125; 拓展中国剩余定理：12345678910111213LL excrt(LL *a, LL *m) &#123; LL ret = m[1], lcm = a[1], x, y; for (int i = 2; i &lt;= n; ++i) &#123; m[i] = (m[i] - ret % a[i] + a[i]) % a[i]; LL g = exgcd(lcm, a[i], x, y); if (m[i] % g) return -1; LL k = fastMul(x, m[i] / g, a[i]); //x * m[i] / g % a[i]; ret += k * lcm; lcm = lcm / g * a[i]; ret = (ret % lcm + lcm) % lcm; &#125; return ret;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bzoj1913 [Apio2010]signaling 信号覆盖]]></title>
    <url>%2F2019%2F04%2F05%2Fbzoj1913%20%5BApio2010%5Dsignaling%20%E4%BF%A1%E5%8F%B7%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[算任意四点的贡献① 如果这四个点构成的是凹四边形：四种圆中除了在圆上的三点之外，只有一种圆会包含剩余一个点，所以一个凹四边形对答案贡献为1。② 构成的是凸多边形：四种圆中有两种圆会包含剩余的一个点（被包含的点分别是对角和大于180°的两个点），因此一个凸四边形对答案的贡献为2。s=凹四边形个数+2*凸四边形个数，答案为$3+\frac {s}{ n\choose 3}$]]></content>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj1912 [Apio2010]patrol 巡逻]]></title>
    <url>%2F2019%2F04%2F05%2Fbzoj1912%20%5BApio2010%5Dpatrol%20%E5%B7%A1%E9%80%BB%2F</url>
    <content type="text"><![CDATA[加一条边形成一个环，环上的边可以少走一次k=1时直接找直径k=2时先找一条直径，连一条边，此时如果再要经过这个环上的边，答案要加2，所以将之前找的边置为-1再找一次直径（简单证明：1)如果答案包含一条直径：注意到第一次找直径的时候可能存在多条。假如存在一条直径与第一次选的直径没有边交集，第二次就会选择那一条；假如所有直径都与它有边交集，注意到有交集的直径都是相同的（不管是点交集还是边交集），不然存在更长的链，所以随便选的那一条没有问题。2)答案不包含直径。这是不可能的。如果选的两条都不经过直径，则将一条换成直径更优；如果选的有一条经过直径，则换成直径更优；如果两条都经过直径，可以换成一条直径加一个环，答案不会更劣。）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,k;int x,y;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void add_edge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int ans,tmp;int s1[N],s2[N],mx;inline int dfs(int x,int fa)&#123; int mx1=0,mx2=0; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa)&#123; int t=dfs(e[i].to,x)+e[i].f; if(t&gt;mx1)&#123; mx2=mx1; mx1=t; s2[x]=s1[x]; s1[x]=i; &#125; else if(t&gt;mx2)&#123; mx2=t; s2[x]=i; &#125; &#125; &#125; if(mx1+mx2&gt;tmp)&#123; tmp=mx1+mx2; mx=x; &#125; return mx1;&#125;int main()&#123; nume=1; n=read();k=read(); ans=2*(n-1); for(int i=1;i&lt;n;++i)&#123; x=read();y=read(); add_edge(x,y,1); add_edge(y,x,1); &#125; dfs(1,0); ans=ans-tmp+1; if(k==2)&#123; for(int i=s1[mx];i;i=s1[e[i].to]) e[i].f=e[i^1].f=-1; for(int i=s2[mx];i;i=s1[e[i].to]) e[i].f=e[i^1].f=-1; tmp=0; dfs(1,0); ans=ans-tmp+1; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】随机化]]></title>
    <url>%2F2019%2F02%2F11%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E9%9A%8F%E6%9C%BA%E5%8C%96%2F</url>
    <content type="text"><![CDATA[cf上用random_shuffle挂了看来随机化还是要好好了解一下 头文件从c++11起 time相关：std::time定义于头文件 std::time_t time( std::time_t* arg ); CLOCKS_PER_SEC定义于头文件 #define CLOCKS_PER_SEC /implementation defined/展开成 std::clock_t 类型表达式，值等于每秒 std::clock() 所返回的时钟计次数（不必是编译时常量）。 std::clock定义于头文件 std::clock_t clock();返回进程从关联到程序执行的实现定义时期开始，所用的粗略处理器时间。为转换结果为秒，可将它除以 CLOCKS_PER_SEC 。 ftime()定义于头文件 函数定义：void ftime(struct timeb *tp);函数说明：ftime()将目前日期由tp所指的结构体返回。123456struct timeb&#123; time_t time; /* 为1970-01-01至今的秒数*/ unsigned short millitm; /* 千分之一秒即毫秒 */ short timezone; /* 为目前时区和Greenwich相差的时间，单位为分钟 */ short dstflag; /* 为日光节约时间的修正状态，如果为非0代表启用日光节约时间修正 */&#125;; c&amp;c++03的随机化：std::srand定义于头文件 void srand( unsigned seed );注意：通常来说，应该只播种一次随机数生成器，在程序开始出，任何到 rand() 的调用前。不应重复播种，或每次冀愿生成新一批随机数时重播种。标准实践是使用以 time(0) 为种子调用的结果。然而 time() 返回 time_t 值，而不保证 time_t 是整数类型。尽管实践中，主流实现都定义 time_t 为整数类型，且此亦为 POSIX 所要求。1.srand(time(0)); //time();2.srand(tim.time*1000+tim.millitm); //ftime(); RAND_MAX（保证此值至少为 32767）win下32767，linux下2147483647 std::rand定义于头文件 int rand();返回 0 与 RAND_MAX （包含 0 与 RAND_MAX ）的随机数。推荐用 C++11 的随机数生成设施替换 rand() 。 (C++11 起) random_shuffle定义于头文件 基于rand()类似的实现： 1234567template&lt;typename T&gt; IL void random_shuffl(T first,T last)&#123; int n=last-first; for(int i=1;i&lt;n;++i)&#123; swap(*(first+i),*(first+rand()%(i+1))); &#125;&#125; 由于rand()有可能太小，移动的偏差可能很小（cf上的测试，3e6的数列，每个值平均移动2%，期望移动是1/3）自己手写random_shuffle:1234567891011IL int ra()&#123; return (rand()&lt;&lt;15)+rand(); &#125;template&lt;typename T&gt; IL void random_shuffl(T first,T last)&#123; int n=last-first; for(int i=1;i&lt;n;++i)&#123; swap(*(first+i),*(first+ra()%(i+1))); &#125;&#125; c++11起可以使用mt19937作为更优质的随机数生成器替代rand()定义于头文件 mt19937:32位梅森缠绕器mt19937_64:64位梅森缠绕器成员函数： 构造与播种： (构造函数)：构造引擎 (公开成员函数) seed：设置引擎的当前状态 (公开成员函数) 生成： operator()：令引擎状态向前并返回生成值 (公开成员函数) 特征： min[静态]：获取输出范围中的最小可能值 (公开静态成员函数) max[静态]：获取输出范围中的最大可能值 (公开静态成员函数) 例：12345mt19937 mt;mt.seed(/*随机数种子*/); // 或者在定义时mt19937 mt(/*随机数种子*/);mt.min();mt.max(); // 0 2^32-1mt(); // 返回[min(),max()]中的随机数//mt19937_64就是[0,2^64-1]的随机数生成器]]></content>
      <tags>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】数论相关]]></title>
    <url>%2F2019%2F02%2F02%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[退役了就学学数论吧退役后的第一场cf（话说已经半年没打cf了536f(1106)题是矩乘+bsgs 发现我什么都不会先贴一些基础的模块吧 求原根：一个数m有原根的充要条件是m=1,2,4,p^e,2p^e, 其中p为奇素数， e为正整数。1234567891011121314151617181920212223IL int primitive_rt(int p)//p是奇素数 &#123; int phi=p-1;//p不是素数就改成求phi vector&lt;int&gt; fact; for(int i=2;i*i&lt;=phi;++i)&#123; if(phi%i==0)&#123; fact.pb(i); while(p%i==0) phi/=i; &#125; &#125; if(phi&gt;1) fact.pb(phi); phi=p-1; for(int i=2;i&lt;p;++i)&#123; bool ok=1; for(int j=0;j&lt;fact.size();++j)&#123; if(ksm(i,phi/fact[j],p)==1)&#123; ok=0;break; &#125; &#125; if(ok) return i; &#125; return -1;&#125; 求（一个）离散对数：//求所有的把map改成map即可12345678910111213141516171819202122IL int bsgs(int a,int b,int p)//calc x which a^x=b(mod p), (a,p)=1&#123; unordered_map&lt;int,int&gt; ma; ma.clear(); int t=round(sqrt(p))+1; //多求一些x不影响答案 int tmp=b; for(int i=0;i&lt;=t;++i)&#123; ma[tmp]=i; tmp=LL(tmp)*a%p; &#125; int c=ksm(a,t,p); tmp=1; for(int i=0;i&lt;=t;++i)&#123; int j=ma.find(tmp)==ma.end()?-1:ma[tmp]; if(j&gt;=0&amp;&amp;i*t-j&gt;=0)&#123; return i*t-j; &#125; tmp=LL(tmp)*c%p; &#125; return -1;&#125; 12345678910111213141516171819202122232425262728293031IL int exbsgs(int a,int b,int p)//a和p不一定互质&#123; a%=p;b%=p; if(b==1) return 0; int v=1,d,cnt=0; while((d=gcd(a,p))&gt;1)&#123; if(b%d) return -1; b/=d;p/=d;++cnt; v=LL(v)*a/d%p; if(v==b) return cnt; //去掉也是对的 &#125; unordered_map&lt;int,int&gt; ma; ma.clear(); int t=round(sqrt(p))+1; //多求一些x不影响答案 int tmp=b; for(int i=0;i&lt;=t;++i)&#123; ma[tmp]=i; tmp=LL(tmp)*a%p; &#125; int c=ksm(a,t,p); tmp=v; for(int i=0;i&lt;=t;++i)&#123; int j=ma.find(tmp)==ma.end()?-1:ma[tmp]; if(j&gt;=0&amp;&amp;i*t-j&gt;=0)&#123; return i*t-j+cnt; &#125; tmp=LL(tmp)*c%p; &#125; return -1;&#125; 求（所有）离散底数：12345678910111213141516171819202122232425262728293031323334353637383940414243int ans[100008],ta;IL void solve(int a,int b,int p)//calc all x which x^a=b(mod p)&#123; int g=primitive_rt(p); a=ksm(g,a,p); unordered_map&lt;int,vector&lt;int&gt; &gt; ma; ma.clear(); int t=round(sqrt(p))/2+1;//调块大小过 int tmp=b; for(int i=0;i&lt;=t;++i)&#123; ma[tmp].pb(i); tmp=LL(tmp)*a%p; &#125; int c=ksm(a,t,p); tmp=1; ta=0; int up=p/t+1;//调过块大小要改up for(int i=0;i&lt;=up;++i)&#123; if(ma.find(tmp)!=ma.end())&#123; vector&lt;int&gt; v=ma[tmp]; for(int j=0;j&lt;v.size();++j)&#123; int x=i*t-v[j]; if(x&gt;=0&amp;&amp;x&lt;p-1)&#123; ans[++ta]=x; &#125; &#125; &#125; tmp=LL(tmp)*c%p; &#125; if(ta==0)&#123; puts("No Solution"); return; &#125; for(int i=1;i&lt;=ta;++i)&#123; ans[i]=ksm(g,ans[i],p); &#125; sort(ans+1,ans+ta+1); ta=unique(ans+1,ans+ta+1)-ans-1; for(int i=1;i&lt;=ta;++i)&#123; printf("%d ",ans[i]); &#125; putchar('\n');&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】可并堆]]></title>
    <url>%2F2019%2F01%2F07%2F%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8F%AF%E5%B9%B6%E5%A0%86%2F</url>
    <content type="text"><![CDATA[之前写的太丑了 可并堆插入的值和num是一直对应的如果按顺序new_node那么不管怎么修改，t[i].val=a[i]主体：123456789struct node&#123; int val,fa,ls,rs; inline node(int _val=0,int _fa=0,int _ls=0,int _rs=0) &#123; val=_val;fa=_fa;ls=_ls;rs=_rs; &#125;&#125;;node t[N];int num; 初始化清空：1234inline void clear()&#123; num=0;&#125; 加新点：123456inline int new_node(int x)&#123; ++num; t[num]=node(x); return num;&#125; 合并两个堆：123456789inline int merge(int x,int y)&#123; if(!x||!y) return x+y; if((t[x].val&gt;t[y].val)||((t[x].val==t[y].val)&amp;&amp;(x&gt;y))) swap(x,y); t[x].rs=merge(t[x].rs,y); t[t[x].rs].fa=x; swap(t[x].ls,t[x].rs); return x;&#125; 找所在的堆：12345inline int get_fa(int x)&#123; while(t[x].fa) x=t[x].fa; return x;&#125; 删除堆顶：123456inline void pop(int x)//改成int，把merge的结果return就可以知道新的根&#123; t[x].val=0; t[t[x].ls].fa=t[t[x].rs].fa=0; merge(t[x].ls,t[x].rs);&#125;]]></content>
      <tags>
        <tag>可并堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原根、阶相关]]></title>
    <url>%2F2018%2F12%2F11%2F%E5%8E%9F%E6%A0%B9%E3%80%81%E9%98%B6%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[设a,m是正整数阶：如果(a,m)=1，对于$a^n \equiv 1 (mod~{p})$的最小的n，叫做a模p的阶。（阶|ϕ(m)）原根：若a模m的阶等于ϕ(m)，则称a为模m的一个原根。 求阶：bsgs求原根：（原根都不大，一般不超过50）检查$a^{(m/pi)}=1(mod~p)$，pi是m的质因子（因为假如存在更小的阶，一定有模不为1的值）复杂度$O(原根大小lognlogn+sqrt(n)（质因数分解）)$]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杨氏矩阵&钩子公式]]></title>
    <url>%2F2018%2F11%2F26%2F%E6%9D%A8%E6%B0%8F%E7%9F%A9%E9%98%B5%26%E9%92%A9%E5%AD%90%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[杨氏矩阵是这样一个矩阵，满足条件：(1)如果格子(i,j)没有元素，则它右边和上边的相邻格子也一定没有元素。(2)如果格子(i,j)有元素a[i][j]，则它右边和上边的相邻格子要么没有元素，要么有元素且比a[i][j]大。$F[1]=1,F[2]=2,F[n]=F[n-1]+(n-1)*F[n-2] (n&gt;2)$ 钩子公式：对于给定形状，不同的杨氏矩阵的个数为：n!除以每个格子的钩子长度加1的积。其中钩子长度定义为该格子右边的格子数和它上边的格子数之和。]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考试安排]]></title>
    <url>%2F2018%2F11%2F09%2F%E8%80%83%E8%AF%95%E5%AE%89%E6%8E%92%2F</url>
    <content type="text"><![CDATA[update:dev编辑器选项中添加缩进到{}和:老是不灵，干脆关掉。。 先安装最新版本dev编译时加入以下命令：-Wall -Wl,–stack=1000000000 -std=c++11（最后改成03编译！！）-O2用于打表找规律 字体：Consolas预设：Obsidian 取消代码补全、符号匹配 开始写模板12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inline#define filein(s) freopen(s,&quot;r&quot;,stdin);#define fileout(s) freopen(s,&quot;w&quot;,stdout);using namespace std;typedef long long LL;typedef unsigned int U;typedef unsigned long long LLU;typedef pair&lt;int,int&gt; PII;typedef long double LD;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()int main()&#123; return 0;&#125; 写完加入到缺省源 然后建文件夹 然后写生成123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;timeb tim;mt19937 mt;inline int ra()&#123; return mt()&gt;&gt;1;//mt()是unsigned int &#125;inline LL rall()&#123; return (1ll*ra()&lt;&lt;30)+ra();&#125;int main()&#123; freopen(&quot;1.in&quot;,&quot;w&quot;,stdout); ftime(&amp;tim); mt.seed(tim.time*1000+tim.millitm); return 0;&#125; 然后写duipai.bat（和bf拍）和pai.bat（测极限数据的时间） duipai.bat12345678910@echo off :loopsc.exe A.exe &lt;1.in &gt;my.outbf.exe &lt;1.in &gt;1.outfc 1.out my.out if errorlevel 1 pausegoto looppause end pai.bat1234567@echo off :loopsc.exe A.exe &lt;1.in &gt;my.outgoto looppause end 最后把东西复制到各个文件夹就行了多余的时间打打ksm，add_ans,add_edge,(fx treap)]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】主席树]]></title>
    <url>%2F2018%2F11%2F08%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[主席树的时间复杂度：O(nlogn)主席树的空间复杂度：O(nlogn)（开2logn比较好）主席树的插入要用引用！ 主席树的主体：123456int rt[N],tot;struct president_tree&#123; int ls,rs,sz; LL sum; /* more */&#125;tr[N*150];//能开多大开多大 主席树是动态开点权值线段树，注意上下界的设置（注意inf的设置和0/1的设置）因为主席树是不支持修改的，所以一般都是一开始就把树建好插入：123456789101112131415inline void update(int &amp;t,int l,int r,int val)&#123; tr[++tot]=tr[t]; ++tr[tot].sz; tr[tot].sum+=val;//先产生一个新点 t=tot;//再赋值 if(l==r) return; int mid=l+(r-l)/2;//可能会爆int if(val&lt;=mid) update(tr[t].ls,l,mid,val); else update(tr[t].rs,mid+1,r,val);&#125;for(int i=1;i&lt;=n;++i)&#123; rt[i]=rt[i-1]; update(rt[i],1,inf,a[i]);&#125; 询问函数可以有返回值，也可以没有，而使用一个全局变量记录答案注意：查询的时候要用ls或者rs的差！！询问：12345678910111213141516171819LL tmp;inline void query(int t1,int t2,int l,int r,int num)&#123; if(!num) return; if(tr[t2].sz-tr[t1].sz&lt;=num)&#123; tmp+=tr[t2].sum-tr[t1].sum; return; &#125; if(l==r)&#123; tmp+=1ll*num*l; return; &#125; int mid=l+(r-l)/2,t=tr[tr[t2].rs].sz-tr[tr[t1].rs].sz; if(num&lt;=t) query(tr[t1].rs,tr[t2].rs,mid+1,r,num); else&#123; tmp+=tr[tr[t2].rs].sum-tr[tr[t1].rs].sum; query(tr[t1].ls,tr[t2].ls,l,mid,num-t); &#125;&#125; 清空主席树：12tot=0;//rt[]和tr[]里的东西都会重新加]]></content>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】fx treap]]></title>
    <url>%2F2018%2F11%2F08%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91fx%20treap%2F</url>
    <content type="text"><![CDATA[treap有点难写啊fx treap好！（没有引用！）那么常数大也没什么办法。。 fx treap的主体：1234int rt,tot;struct node&#123; int ls,rs,val,pri,sz;&#125;fx[N]; （假如要写多颗平衡树，把这个东西封装一下就好了）rt：这颗树的根的编号tot：总点数（删除的点不会消失，只是它的编号不再被使用了）ls：左孩子rs：右孩子val：关键码（平衡树存的值）pri：随机的优先级比较值sz：点数（相同的值并没有合并到一起） 加入一个新的点：123456789101112131415int seed=233;inline int ra()//可以不重复的生成1~INT_MAX-1的每一个数&#123; seed=48271ll*seed%INT_MAX; return seed;&#125;inline int new_node(int x)&#123; ++tot; fx[tot].sz=1; fx[tot].val=x; fx[tot].pri=ra(); fx[tot].ls=fx[tot].rs=0; return tot;&#125; 更新节点的信息：（更改了树的结构的时候需要更新，fx treap需要在merge和split的时候更新）12345inline void pushup(int x)&#123; fx[x].sz=fx[fx[x].ls].sz+fx[fx[x].rs].sz+1; /* more */&#125; 合并(merge)两颗fx，要求左边的fx的每个点的关键码小于右边的fx的每个点的关键码1234567891011121314inline int merge(int x,int y)&#123; if(!x||!y) return x+y; if(fx[x].pri&lt;fx[y].pri)&#123; fx[x].rs=merge(fx[x].rs,y); pushup(x); return x; &#125; else&#123; fx[y].ls=merge(x,fx[y].ls); pushup(y); return y; &#125;&#125; 分裂(split)一颗fx，可以按值分裂，也可以按排名分裂，这里将键值&lt;=x的分成左树，其余分成右树split操作会得到两个值，rt_l表示左树的根的编号，rt_r表示右树的根的编号（这样写没有返回值，注意这两个值的变化，要即时的把值存下来，每次split之后他们的值就变了）12345678910111213141516171819int rt_l,rt_r;inline void split(int rt,int x)&#123; if(!rt)&#123; rt_l=rt_r=0; return; &#125; if(fx[rt].val&gt;x)&#123; split(fx[rt].ls,x); fx[rt].ls=rt_r; rt_r=rt; &#125; else&#123; split(fx[rt].rs,x); fx[rt].rs=rt_l; rt_l=rt; &#125; pushup(rt);&#125; 拥有了merge和split的fx treap，仍然拥有treap的一切性质，仍然可以使用treap的一切函数fx treap独特之处在于，它抛弃了旋转操作，那么treap的insert和delete就不适用于fx treap了（只有这两个操作是需要zag和zig的）插入：12345inline void inser(int x)&#123; split(rt,x); rt=merge(merge(rt_l,new_node(x)),rt_r);&#125; 删除：1234567inline void delet(int x)&#123; split(rt,x); int tmp=rt_r; split(rt_l,x-1); rt=merge(merge(rt_l,merge(fx[rt_r].ls,fx[rt_r].rs)),tmp);&#125; 短小精悍，那么其他操作也可以考虑用fx特有的merge和split来完成（常数大）求键值为x的最小排名（相同的不算）：1234567inline int rank(int x)//rank在c++11中是关键字&#123; split(rt,x-1); int ans=fx[rt_l].sz+1; rt=merge(rt_l,rt_r); return ans; &#125; 求排名第k的键值：//并不能优化这个过程。。1234567891011121314inline int kth(int rt,int k)&#123; if(k&gt;fx[rt].sz) return -1; while(1)&#123; if(k==fx[fx[rt].ls].sz+1) return rt; if(k&lt;=fx[fx[rt].ls].sz)&#123; rt=fx[rt].ls; &#125; else&#123; k-=fx[fx[rt].ls].sz+1; rt=fx[rt].rs; &#125; &#125;&#125; 求前驱后继：1234567891011121314151617181920212223242526inline int get_pre(int x)&#123; int ans; split(rt,x-1); if(!rt_l)&#123; ans=-INT_MAX; &#125; else&#123; ans=fx[kth(rt_l,fx[rt_l].sz)].val; &#125; rt=merge(rt_l,rt_r); return ans;&#125;inline int get_nxt(int x)&#123; int ans; split(rt,x); if(!rt_r)&#123; ans=INT_MAX; &#125; else&#123; ans=fx[kth(rt_r,1)].val; &#125; rt=merge(rt_l,rt_r); return ans;&#125; 清空：1rt=tot=0;]]></content>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F23%2F18-10-23%E5%AD%A6%E6%A0%A1%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[18-10-23学校模拟赛orz djq第一题101是4位循环的因为9999是101的倍数10000=1(mod 101)满足gcd(x,10)=1的数都有这样的循环因为10^phi(x)=1(mod x)最小的循环要枚举phi(x)的因数求phi(x)是根号的（直接暴力从2到sqrt，每个地方都不停的除即可 本题dp[i][j][p][q]表示区间[i,j]内模101为p位数模4为q的子序列个数注意初始情况，长度为1和有两个相同的为1转移要小小的容斥一下dp[i][j][p][q]+=dp[i+1][j][p][q]+dp[i][j-1][p][q]-dp[i+1][j-1][p][q]还是有点弱啊（初始情况和转移容斥） 第二题不考虑是x的多少倍只考虑它是x的倍数那就按模x的值来搞连边变成01bfs 01bfs暑假zr讲了啊（可是我没听啊连0的边就加到队头连1的边就加到队尾队列时刻都不会超过2种值（x和x+1或者只有x）每个点最多入队两次（先1再0的情况）且永远是用最小值先来更新可以不用记录出现最小值的vis数组（类似dijk的vis） 第三题维护树上并查集不知道为什么80.。LL写成int把变量改成LL以后要查全文！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[图论]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%9B%BE%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[求割边求错了QWQ写一篇跟tarjan有关的总结 有向图：求强连通分量：重边、自环都不影响求解，记录fa，要写栈求割边：未定义割边，要根据题目转化成无向图做（可能吧）求割点：未定义割点，要根据题目转化成无向图做（可能吧） 无向图：求割边：自环无影响，重边有影响，要记录是从哪条边来的，而不是记录fa，不要写栈dfn[x]&lt;low[x]，所以不能用fa更新求割点：自环、重边无影响，不用记录fa，不要写栈。注意根节点。dfn[x]&lt;=low[x]，所以可以用fa更新]]></content>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树上背包]]></title>
    <url>%2F2018%2F09%2F26%2F%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[在树上找k条点不相交的路径使得权值和最大（一个点算一条退化的路径）不能只用0/1表示（0表示不能往上，1表示能往上），有坑，合并的时候不知道上面的0有没有算一条路径！！ 用0/1/2写，将0/1/2的max存到0中，这是错的，调用0的时候会挂（数据弱拿了50/60）中途瞎改改对了。。（把t[1][0]赋初值-inf而不是0，选一个单点的情况认为向孩子连了2条边）（但是并没有迅速调对是因为前面把0/1/2全部取max并到0了，题解误导啊！）$f[x][j][0/1/2]$表示在x及其子树中选了j条路径，x向它的孩子连出0/1/2条边，e[i].f是边权y是x的一个孩子，$t[j][0/1/2]$表示当前合并的子树$f[][][]=-inf,f[x][0][0]=f[x][1][1]=f[x][1][2]=0$$t[][]=-inf,t[0][0]=t[1][1]=t[1][2]=0$$t[j][0]=max(t[j][0],f[x][j-p][0]+max(f[y][p][0],f[y][p][1],f[y][p][2]))$$t[j][1]=max(t[j][1],f[x][j-p][1]+max(f[y][p][0],f[y][p][1],f[y][p][2]),f[x][j-p][0]+f[y][p][1]+e[i].f)$$t[j][2]=max(t[j][2],f[x][j-p][2]+max(f[y][p][0],f[y][p][1],f[y][p][2]),f[x][j-p][1]+f[y][p][1]+e[i].f)$ 嘤嘤嘤嘤这题不太一样不要求路径个数所以只需要0/1表示跟有没有选可以通过sum巧妙的转移到1而确定路径数量的就不好这么做（不能控制sum选了多少，可能还需要一个背包）]]></content>
      <tags>
        <tag>树上背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-9-18学校模拟赛]]></title>
    <url>%2F2018%2F09%2F19%2F18-9-18%E5%AD%A6%E6%A0%A1%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[该文被密码保护第一题：博弈(tc srm 664a)【问题描述】𝐴𝑐𝑒𝑠𝑟𝑐的好朋友𝑔𝑖𝑠𝑝𝑧𝑗𝑧最近迷上了一个游戏！作为𝑔𝑖𝑠𝑝𝑧𝑗𝑧的知心好友，𝐴𝑐𝑒𝑠𝑟𝑐决定和𝑔𝑖𝑠𝑝𝑧𝑗𝑧 打打游戏，沟通沟通感情。初始𝐴𝑐𝑒𝑠𝑟𝑐和𝑔𝑖𝑠𝑝𝑧𝑗𝑧各自有一个数a,b，这个游戏将进行k轮，每一轮游戏会有下面的事情发生：假设a ≤ b，我们令b = b − a,a = a + a；如果b &lt; a，则a = a − b,b = b + b。现在𝑔𝑖𝑠𝑝𝑧𝑗𝑧想知道，k轮游戏后，min(a,b)是多少。【输入格式】从文件game.in中读入数据。第一行三个数，表示a,b,k。【输出格式】输出到文件game.out中。一共一行，包含一个整数，表示答案。【样例输入1】2 3 5【样例输出1】1【样例输入2】955 812 828145516【样例输出2】167【样例输入3】955253431 806956091 857954【样例输出3】553642420【数据规模】对于20% 的数据，a,b ≤ 1000。对于40% 的数据，a,b ≤ 106。对于60% 的数据，a,b ≤ 108。对于另20% 的数据，k ≤ 107。对于100% 的数据，1 ≤ a,b,k ≤ 109。 显然a+b是定值，令n=a+b若a&lt;=b，a’=2a若a&gt;b，a’=a-b=2a-(a+b)=2a-n所以就是在模n意义下乘2的k次方。 思维好题。我发现了a+b是定值，然后开始考虑周期。。所以说对称性很重要！！（还有单调性之类的。） 第二题：(cf 446B)给一个𝑁×𝑀的矩阵，共𝐾次操作，每次挑选一行或者一列，将其中的元素全都加到答案中，并且每个元素的值−𝑃。问答案最大是多少。 显然行列独立（取多少行也不会影响该怎么取列）预处理取k行的最大值，取k列的最大值然后枚举行取多少，更新答案即可O(klogn)行列一起考虑随便反例 第三题：给定𝑁个区间[𝑙𝑖, 𝑟𝑖]，你可以选出其中若干个区间，设为𝑡𝑜𝑡个；令𝑥为这𝑡𝑜𝑡个区间的交。求min(𝑥, 𝑡𝑜𝑡)的最大值。范围：𝑁 ≤ 300000，1 ≤ 𝑙𝑖 ≤ 𝑟𝑖 ≤ 𝑁。 显然区间的交是连续的注意到区间越长，个数越少想到二分区间长度枚举左端点每次均摊O(1)的插入区间（考试时来不及就写O(n)判。。） 或者枚举左端点，注意到随着右端点的右移，区间长度变大，个数变小。那就二分呗，发现还要算覆盖它的区间个数感觉还要一个log在线段树上求这个值诶？线段树上求值，所以线段树二分 发现这题不管是按长度还是按位置都有单调性说明这题的性质很强啊发现two pointers也能做所以说单调性很重要！！（还有对称性之类的。）]]></content>
      <tags>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】可并堆]]></title>
    <url>%2F2018%2F09%2F17%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8F%AF%E5%B9%B6%E5%A0%86%2F</url>
    <content type="text"><![CDATA[好久没写笔记了可并堆是个简单好用（好写）的数据结构做了几道水题luogu2713 罗马游戏luogu3377 【模板】左偏树（可并堆）luogu3066 [Usaco2012 Dec]Running Away From the Barn 可并堆的核心就是保持深度（要肤浅！）最无脑的斜堆就是每次将左右孩子交换，但这是均摊log的（不会证啊）也可以随机交换（rand()&amp;1）优秀（可持久化）的做法是维护一个dist，表示这个点向右能走的距离要求满足dist_left&gt;=dist_right,dist=dist_right+1容易证明是log的，这就是左偏树（因为向左偏，斜堆也是向左偏的。。） 实测感觉斜堆跑得最快（数据不够优秀？) 几个错误：不能merge两个处于同一个堆里的东西！（会翻倍诶）swap(x,y)而不是swap(t[x],t[y])，因为要保证编号和值对应！ luogu2475 [SCOI2008]斜堆（关于斜堆的一些性质，了解一下）转自MATO IS NO.1考虑斜堆中最后插入的那个结点，容易发现：（1）它一定是一个极左结点（就是从根往它的路上一直都是沿着左链走），因为插入的时候每次都是插入到左子树中；（2）它一定木有右子树，因为插入的时候每次都是把原来的某棵子树作为新结点的左子树； 满足（1）（2）的结点可能有多个，但紧接着可以发现，这个斜堆中的每个结点如果木有左子结点，那么也木有右子结点（或者说，每个非叶结点都有左子树），而在插入一个结点之前，其所有的祖先都被交换了左右子树，所以，若新结点的祖先中有满足（1）（2）的，且新结点不是叶结点，那么在新结点插入之前，这个满足（1）（2）的祖先必然是只有右子树而木有左子树的，这与上面的那个性质矛盾，所以，可以得出：最后插入的那个结点一定是满足（1）（2）的结点中，深度最小的那个（设为X），除非X的左子结点是叶结点，此时为了满足字典序最小，应该取X的左子结点为最后插入的。找到这个最后插入的结点以后，只需要把它删掉，并把它的所有祖先交换左右子树，就是插入该结点以前的状态了。这样可以找到字典序最小的插入顺序。]]></content>
      <tags>
        <tag>可并堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zr模拟赛]]></title>
    <url>%2F2018%2F09%2F04%2Fzr%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[考试的首要目标：得高分！不写对拍的话，一半概率会炸。 提高r1第一题找规律，40min完成第二题基环内向树，写了挺久，建了反向边dfs。其实拓扑或者tarjan都行。1.5h才写完第三题没什么思路，打了暴力。期望100+100+50=250实际100+100+40=240第三题应该是n&gt;20是特判，结果写成n&gt;100，有10分t了。 t3正解：应该想到区间dp，但是很难想到维护什么因为很杂乱首先要枚举出是哪个字符串p，复杂度 $\sum_{len|n}(n-len+1)$ dp[i][j]表示 若j-i+1是len的倍数，则dp[i][j]=[能否消完] 若j-i+1不是len的倍数，则dp[i][j]=[是否能消成p的前缀]，注意到这个前缀是固定的，可以通过长度算转移： 考虑往区间后面加一个字符，$dp[i][j]=dp[i][j-1]&amp;s[j]==prefix((j-i)%len+1)$ 考虑往区间前面加一段字符，$dp[i][j]=dp[i][j-klen]&amp;dp[j-klen+1][j]$ 这样就可以考虑到所有的情况，向后加一段可以通过一个一个加得到，向前加一个可以通过改变i得到。注意初始化：dp[i][i-1]=1，其他为0 提高r5 18-9-22找规律真有趣 提高r7 18-10-13第一题相当于01覆盖问题然而这个问题并不可做但是n&gt;=m^2且数据随机所以可以认为图是连通的。。卡了2h。。 第二题树上随机游走+树上最长路最可做的一题吧考完试1minac 第三题数学+推式子不是很擅长啊看完题解觉得挺简单的暴力写炸了心态爆炸加写炸对1和2的状态写错了（小状态一定要写对啊，那大状态的程序跑一下也行啊。。）还有tarjan写的丑st和ins什么的最好都清空！！数组不要只开大1！！（sta[ta+1]!=x，这样爆了！！） 提高r8 18-10-20心态不能崩，暴力不能挂‘打好暴力就rk10了！！ 第一题暴力挂+第二题暴力挂艹 第一题a[i]写成i 第二题递归的变量和全局变量重了 wtf!这种错误静态查错应该能查出来的！！以后模拟赛不管怎样都要静态查错，包括暴力！！ 提高r9 18-10-27第一题还是逻辑不够严谨证明的东西还是要写下来才严谨啊在cpp开头写倒是不错 第二题容斥（我容斥好差啊 第三题毒瘤题好好读题，不要被长题面吓到了 普转提r1 18-9-9第一题二分加滑动窗口被精度卡到死对拍了好久不停的调eps实际上什么都没卡。。 第二题贪心dp随便dp：记录每个左端点最近的右端点，f[r[i]]=max(f[r[i]],f[i]+1),f[i+1]=max(f[i+1],f[i])贪心： 遇到一个右端点，假如这个区间还有效，++ans，将目前遇到的所有区间置为无效 遇到一个左端点，使这个区间有效 第四题心中有边的时候（就是你知道应该访问哪些点的时候）可以不建边，节约时间空间把这题暴力*掉。 正解是优化建图（你胡思乱想哪些倍增有甚么用）把每个点的高度再作为1维变成n^3的点数和边数，上dijk就行 普转提r2 18-9-16第一题注意到交换两个数之和左右两边就分开了按区间考虑一旦区间的左右位置确定了，区间中有哪些数就确定了这样就可以dp[l][r]表示将[l,r]排成递增的顺序有多少种方法枚举中间的转移点就可以了记忆化搜索判断转移合法的方式（也就是[l,i]中恰好含有[l,i]）：用cnt[i]记录从l到i有多少个数在[l,i]合法&lt;=&gt;cnt[i]==i-1&amp;&amp;((cnt[i+1]==i&amp;&amp;a[i]!=l+i)||(cnt[i+1]==i+1&amp;&amp;a[i]==l+i))O(n^3) 第二题有2^(R+C)的贡献相当于每个子集有1的贡献相当于求每个集合被多少个集合包含先枚举包含的行列数，令$t=im+jn-i*j$相当于长度为n的格子，往里面填m个数，再选择k个数，使得前t个格子被选中 $ans=\sum{i=0}^{n}\sum{j=0}^{m}C_n^iC_m^jF$其中F表示满足i行j列的概率$$F=\frac{Am^{n^2}*C{m-k}^{k-t}}{Am^{n^2}*C{m}^{k}}$$分母表示总方案数分子表示满足条件的方案数总体考虑分子（而不是对某种选完k个数的方案进行考虑）对某个排列，它可以对应的方案数是$C_{m-k}^{k-t}$或者暴力的算先钦定选数和t个数，再算上排列$$Cm^t*C{m-k}^{k-t}t!A_{m-t}^{n^2-t}=Am^{n^2}*C{m-k}^{k-t}$$ 第三题相当于中序遍历的序列单调上升最小化修改次数相当于最大化不修改数（重要的思想：补集！！）注意到lis但是两个数中间不一定能放下这么多数如果是求单调不降的序列就比较简单，直接求原序列的单调不降的序列但是单调不降和单调上升还是很容易转化的让a[i]-=i即可（其实也可以理解为在严格单增问题中能拓展的条件为$a[i]-a[k]\geq i-k$那么也就是$a[i]-i\geq a[k]-k$） 第四题显然ak是区间的最小值且其他数都是它的倍数找l，r即可 普转提r3 18-9-23第一题思维题好好观察题目性质 第二题发现桥的板子是写假了。不能记fa，因为有重边！！其实建图也假了要正反各跑一遍dijk 第三题数位的题目要以二进制的眼光看数加一个数就是在每位加0或1fi,j表示处理到第i位（从右往左的第i位以左已经处理完），第i-1位有j个数进位了考虑第i位加的是0还是1，O1转移 第四题n^2logn应该要想到然后要注意到可以拿当前值先判一下，这个剪枝很强，可以直接a掉某奇怪性质： 随机序列的lis的长度的期望是2sqrt(n)的（有论文） 长度为n2+1的排列至少有一个长为n+1的上升子序列或下降子序列（证明：dp是说以每个数结尾的最长上升子序列长度和最长下降子序列长度 对于两个数而言两者不能都一样 所以要是都在1-n就最多有n2个数 from ytl） 长度为n的排列，设它的最长上升子序列长度为a，最长下降子序列长度为b，则ab&gt;=n（证明：这n个位置的dp值都不一样，在二维坐标系下表示这些点，ab最小的时候一定是这些点围成一个矩形，矩形的长乘宽就是ab，所以ab&gt;=b） 随机序列的不同前缀最大值个数是（调和级数）ln(n)的（证明：因为第i个数有1/i概率比之前的都大 所以根据期望的线性性加起来就是ln） 将顺序随机一下，只有log个位置需要进去二分，其他位置只要判掉就行复杂度O(n^2+nlognlogn) 普转提r4 18-9-30第一题数学线性筛因数个数（暴力卡时过。。） 第二题分类讨论knight’s tour：nn中，n&gt;=5存在哈密尔顿路径，n&gt;=6且n为偶数存在哈密尔顿回路（证明见wiki）nm中，只要min(n,m)&gt;=5则存在哈密尔顿路径，无证明（搜索证明。。 第三题暴力加最优性剪枝暴艹正解正解二分+扫描线+set 第四题暴力r和m打错。。常用变量名还是不要乱动。。转对偶图+并查集 普及r3 18-9-29你oi比赛当然要好好检查啊 from fizzydavid 第一题sb题sb题也要仔细做！！想清楚再写！！ 第二题人眼查错不是用眼睛查错是用脑子查错！！ 这才是优秀的写法123456789101112double Calc(int x) &#123; if (x == 4) return s[x]; if (f[x] &lt;= 2) &#123; if (f[x] == 1) s[x + 1] *= s[x]; if (f[x] == 2) s[x + 1] = s[x] / s[x + 1]; return Calc(x + 1); &#125; else &#123; if (f[x] == 3) return s[x] + Calc(x + 1); if (f[x] == 4) return s[x] - Calc(x + 1); &#125;&#125; round：取离自己最近的整数（四舍五入），0.5的话取远离0的值trunc：舍弃小数floor：小于等于的最大整数ceil：大于等于的最小整数int()和LL()这种强制类型转换等同于trunc判断x是否是整数：fabs(x-round(x))]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2120 [ZJOI2007]仓库建设]]></title>
    <url>%2F2018%2F08%2F17%2Fluogu2120%20%5BZJOI2007%5D%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[做特别行动队的时候发现这题的题解还没写这才是第一道斜率优化啊当时懵懵懂懂对着题解写的现在明白了 想想全tm是套路12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1000008;int n;int x[N],c[N];LL s[N],t[N],f[N];int q[N],he,ta;inline double rate(int x,int y)&#123; return (f[y]+t[y]-f[x]-t[x])*1.0/(s[y]-s[x]);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; x[i]=read();s[i]=read();c[i]=read(); t[i]=t[i-1]+s[i]*x[i]; s[i]+=s[i-1]; &#125; he=1;ta=1;q[1]=0; for(int i=1;i&lt;=n;++i)&#123; while(he+1&lt;=ta&amp;&amp;x[i]&gt;rate(q[he],q[he+1])) ++he; f[i]=f[q[he]]+c[i]+(s[i]-s[q[he]])*x[i]-t[i]+t[q[he]]; while(he+1&lt;=ta&amp;&amp;rate(q[ta],i)&lt;rate(q[ta-1],q[ta])) --ta; q[++ta]=i; &#125; printf("%lld",f[n]); return 0;&#125;]]></content>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3628 [APIO2010]特别行动队]]></title>
    <url>%2F2018%2F08%2F17%2Fluogu3628%20%5BAPIO2010%5D%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F%2F</url>
    <content type="text"><![CDATA[斜率优化真是套路 $f[i]=min(a[i]*b[j]+c[j]+d[i])$ 看到这种带当前i和转移j的二次项的，就是斜率优化了d[i]最后加可以不管，去掉min，然后整理成y=kx+b的形式 $c[j]=-a[i]*b[j]+f[i]$ k为-a[i]，b为f[i]，(x,y)为(b[j],c[j])要最大化f[i]，就是维护上凸壳要最小化f[i]，就是维护下凸壳注意起点在哪个位置（一般是(0,0) 还可以考虑比较法考虑1&lt;=k&lt;j&lt;i假如j的转移更优要满足的条件然后推一波式子发现和上面的是一样的 然后是重点（敲黑板如果b[i]随i有单调性（单调递增最好，如果是单调递减可以提负号好理解 a[i]有单调性，分成两种单调性，一种随着凸壳往后而往后，一种只会停在第一个点（这种情况几乎不会有吧复杂度是O(n) a[i]没有单调性，那么要二分，复杂度O(nlogn)。以下引用：二分做法：假设你要在上凸包上二分找斜率为k的切线。取中间的mid号点，如果mid+1存在且与mid点的斜率小于k，则l=mid+1；如果mid−1存在且与mid点的斜率大于k，则r=mid−1；如果上面两条都不满足，则mid就是切点。一个很好的斜率优化讲解bzoj2726 如果b[i]没有单调性（糟糕要动态维护凸包）那么考虑set/手写平衡树/cdq分治，复杂度O(nlogn) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1000008;int n;int a,b,c;int sum[N];int q[N],he,ta;LL xl; LL dp[N];inline LL calc(int x)&#123; return dp[x]+1ll*a*sum[x]*sum[x]-1ll*b*sum[x];&#125;inline double rate(int x,int y)&#123; return (calc(x)-calc(y))/(sum[x]-sum[y]);&#125;int main()&#123; n=read(); a=read();b=read();c=read(); for(int i=1;i&lt;=n;++i)&#123; sum[i]=sum[i-1]+read(); &#125; he=ta=1; q[1]=0; xl=2ll*a; for(int i=1;i&lt;=n;++i)&#123; while(he+1&lt;=ta&amp;&amp;xl*sum[i]&lt;rate(q[he+1],q[he])) ++he; dp[i]=calc(q[he])-xl*sum[i]*sum[q[he]]+1ll*a*sum[i]*sum[i]+1ll*b*sum[i]+c; while(he+1&lt;=ta&amp;&amp;rate(q[ta],q[ta-1])&lt;rate(i,q[ta])) --ta; q[++ta]=i; &#125; printf("%lld",dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2819 Nim]]></title>
    <url>%2F2018%2F08%2F16%2Fbzoj2819%20Nim%2F</url>
    <content type="text"><![CDATA[裸树剖+线段树码码码挂了查了好久发现dfs2挂了伤心欲绝以为我一直以来的板子都是错的开始吐槽过去a掉的题目数据水然后发现只有套线段树才会挂因为没有先dfs重孩子（原来我写的都是求lca吗。 正解是在dfs序上搞发现答案是两点到根的异或和再异或lca一个点只对子树有贡献然后我跑去写手写栈其实是第一次写入栈的时候处理一个点的信息全部处理完出栈出栈时处理对父亲的贡献123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008;int n,qn;int a[N];int x,y;vector&lt;int&gt; e[N];int sz[N],dep[N],fa[N],hvson[N],tf[N],id[N],w[N],num;inline void dfs1(int x)&#123; sz[x]=1; for(int i=0;i&lt;e[x].size();++i)&#123; if(e[x][i]!=fa[x])&#123; fa[e[x][i]]=x; dep[e[x][i]]=dep[x]+1; dfs1(e[x][i]); sz[x]+=sz[e[x][i]]; if(sz[hvson[x]]&lt;sz[e[x][i]]) hvson[x]=e[x][i]; &#125; &#125;&#125;inline void dfs2(int x)&#123; id[x]=++num; w[num]=a[x]; //要先dfs重孩子！！ /*tf[x]=(hvson[fa[x]]==x?tf[fa[x]]:x); for(int i=0;i&lt;e[x].size();++i)&#123; if(e[x][i]!=fa[x]) dfs2(e[x][i]); &#125;*/ /*tf[x]=ances; if(!hvson[x]) return; dfs2(hvson[x],ances); for(int i=0;i&lt;e[x].size();++i)&#123; if(e[x][i]!=fa[x]&amp;&amp;e[x][i]!=hvson[x]) dfs2(e[x][i],e[x][i]); &#125;*/ tf[x]=(hvson[fa[x]]==x?tf[fa[x]]:x); if(!hvson[x]) return; dfs2(hvson[x]); for(int i=0;i&lt;e[x].size();++i)&#123; if(e[x][i]!=fa[x]&amp;&amp;e[x][i]!=hvson[x]) dfs2(e[x][i]); &#125;&#125;int tr[N&lt;&lt;2];inline void pushup(int t)&#123; tr[t]=tr[t&lt;&lt;1]^tr[t&lt;&lt;1|1];&#125;inline void build_segment_tree(int t,int l,int r)&#123; if(l==r)&#123; tr[t]=w[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build_segment_tree(t&lt;&lt;1,l,mid); build_segment_tree(t&lt;&lt;1|1,mid+1,r); pushup(t);&#125;inline void update(int t,int l,int r,int pos,int val)&#123; if(l==r)&#123; tr[t]=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(t&lt;&lt;1,l,mid,pos,val); else update(t&lt;&lt;1|1,mid+1,r,pos,val); pushup(t);&#125;inline int query(int t,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; return tr[t]; &#125; int mid=(l+r)&gt;&gt;1; if(rr&lt;=mid) return query(t&lt;&lt;1,l,mid,ll,rr); if(ll&gt;mid) return query(t&lt;&lt;1|1,mid+1,r,ll,rr); return query(t&lt;&lt;1,l,mid,ll,rr)^query(t&lt;&lt;1|1,mid+1,r,ll,rr);&#125;inline void solve(int x,int y)&#123; int ans=0; while(tf[x]!=tf[y])&#123; if(dep[tf[x]]&gt;dep[tf[y]])&#123; ans^=query(1,1,n,id[tf[x]],id[x]); x=fa[tf[x]]; &#125; else&#123; ans^=query(1,1,n,id[tf[y]],id[y]); y=fa[tf[y]]; &#125; &#125; if(dep[x]&lt;dep[y])&#123; ans^=query(1,1,n,id[x],id[y]); &#125; else&#123; ans^=query(1,1,n,id[y],id[x]); &#125; //下面是假做法，lca没有被考虑到 /* while(x&gt;0)&#123; ans^=query(1,1,n,id[tf[x]],id[x]); x=fa[tf[x]]; &#125; while(y&gt;0)&#123; ans^=query(1,1,n,id[tf[y]],id[y]); y=fa[tf[y]]; &#125;*/ if(ans)&#123; puts("Yes"); &#125; else&#123; puts("No"); &#125;&#125;char op;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;n;++i)&#123; x=read();y=read(); e[x].pb(y); e[y].pb(x); &#125; dfs1(1); dfs2(1); build_segment_tree(1,1,n); qn=read(); while(qn--)&#123; op=getchar(); while(op!='Q'&amp;&amp;op!='C') op=getchar(); if(op=='Q')&#123; x=read();y=read(); solve(x,y); &#125; else&#123; x=read();y=read(); update(1,1,n,id[x],y); &#125; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008;int n,qn;int a[N];int x,y,z;vector&lt;int&gt; e[N];int sta[N],ta;int sz[N],fa[N],dep[N],hvson[N],tf[N];int cur[N];inline void dfs1()&#123; memset(cur,0,sizeof(cur)); ta=0; sta[++ta]=1; sz[1]=1; while(ta&gt;0)&#123; int x=sta[ta]; int &amp;i=cur[x]; if(e[x][i]==fa[x]) ++i; if(i&gt;=e[x].size())&#123; --ta; if(fa[x])&#123; sz[fa[x]]+=sz[x]; if(sz[hvson[fa[x]]]&lt;sz[x]) hvson[fa[x]]=x; &#125; continue; &#125; fa[e[x][i]]=x; dep[e[x][i]]=dep[x]+1; sta[++ta]=e[x][i]; sz[e[x][i]]=1; ++i; &#125;&#125;bool vis[N];int in[N],out[N],num;inline void dfs2()&#123; memset(cur,0,sizeof(cur)); ta=0; sta[++ta]=1; in[1]=++num; tf[1]=1; while(ta&gt;0)&#123; int x=sta[ta]; if(!hvson[x])&#123; out[x]=num; --ta; continue; &#125; if(!vis[x])&#123; vis[x]=1; sta[++ta]=hvson[x]; in[hvson[x]]=++num; tf[hvson[x]]=tf[x]; continue; &#125; int &amp;i=cur[x]; while(i&lt;e[x].size()&amp;&amp;(e[x][i]==fa[x]||e[x][i]==hvson[x])) ++i; if(i&gt;=e[x].size())&#123; out[x]=num; --ta; continue; &#125; sta[++ta]=e[x][i]; in[e[x][i]]=++num; tf[e[x][i]]=e[x][i]; ++i; &#125;&#125;char op;int bit[N];inline void add(int pos,int x)&#123; if(!pos) return; for(int i=pos;i&lt;=n;i+=i&amp;-i)&#123; bit[i]^=x; &#125;&#125;inline int query(int pos)&#123; int tmp=0; for(int i=pos;i&gt;0;i-=i&amp;-i)&#123; tmp^=bit[i]; &#125; return tmp;&#125;inline int lca(int x,int y)&#123; while(tf[x]!=tf[y])&#123; dep[tf[x]]&gt;dep[tf[y]]?x=fa[tf[x]]:y=fa[tf[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;n;++i)&#123; x=read();y=read(); e[x].pb(y); e[y].pb(x); &#125; dfs1(); dfs2(); for(int i=1;i&lt;=n;++i)&#123; add(in[i],a[i]); add(out[i]+1,a[i]); &#125; qn=read(); while(qn--)&#123; op=getchar(); while(op!='Q'&amp;&amp;op!='C') op=getchar(); if(op=='Q')&#123; x=read();y=read(); puts((query(in[x])^query(in[y])^a[lca(x,y)])?"Yes":"No"); &#125; else&#123; x=read();y=read(); add(in[x],a[x]); add(out[x]+1,a[x]); a[x]=y; add(in[x],a[x]); add(out[x]+1,a[x]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2046 [NOI2010]海拔]]></title>
    <url>%2F2018%2F08%2F16%2Fluogu2046%20%5BNOI2010%5D%E6%B5%B7%E6%8B%94%2F</url>
    <content type="text"><![CDATA[一眼——要么0要么1最小割！码码码90分（dinic滚去写正解还好就是建图有点烦挂了一次是写成大根堆（这tm能过样例。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=508;int n,x;int s,t;int nume,head[N*N];struct edge&#123; int to,nxt,f;&#125;e[N*N*4];inline void add_edge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; pq;int dis[N*N];bool vis[N*N];inline void dijk()&#123; memset(dis,0x3f,sizeof(dis)); dis[s]=0; pq.push(mp(0,s)); while(!pq.empty())&#123; int x=pq.top().second; pq.pop(); if(vis[x]) continue; vis[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; pq.push(mp(dis[e[i].to],e[i].to)); &#125; &#125; &#125; printf("%d",dis[t]);&#125;int main()&#123; n=read(); s=0;t=n*n+1; for(int i=1;i&lt;=n+1;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; x=read(); if(i==1)&#123; add_edge(s,j,x); &#125; else if(i==n+1)&#123; add_edge(n*(n-1)+j,t,x); &#125; else&#123; add_edge(n*(i-2)+j,n*(i-1)+j,x); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n+1;++j)&#123; x=read(); if(j==1)&#123; add_edge(n*(i-1)+1,t,x); &#125; else if(j==n+1)&#123; add_edge(s,n*i,x); &#125; else&#123; add_edge(n*(i-1)+j,n*(i-1)+j-1,x); &#125; &#125; &#125; for(int i=1;i&lt;=n+1;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; x=read(); if(i==1)&#123; add_edge(j,s,x); &#125; else if(i==n+1)&#123; add_edge(t,n*(n-1)+j,x); &#125; else&#123; add_edge(n*(i-1)+j,n*(i-2)+j,x); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n+1;++j)&#123; x=read(); if(j==1)&#123; add_edge(t,n*(i-1)+1,x); &#125; else if(j==n+1)&#123; add_edge(n*i,s,x); &#125; else&#123; add_edge(n*(i-1)+j-1,n*(i-1)+j,x); &#125; &#125; &#125; dijk(); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最短路</tag>
        <tag>对偶图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2115 [Wc2011] Xor]]></title>
    <url>%2F2018%2F08%2F16%2Fbzoj2115%20%5BWc2011%5D%20Xor%2F</url>
    <content type="text"><![CDATA[线性基最基本的题目了吧边有权值图中任意的环都可以走出来（先到环上一点，绕一圈，再回去）先随便找一条1到n的路径把环做线性基错了一次在于某个地方的LL写成int123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=50008,M=100008;int n,m;int x,y;LL z;vector&lt;pair&lt;int,LL&gt; &gt; e[N];bool vis[N];LL w[N];LL xhj[64];LL ans;inline void inser(LL x)&#123; for(int i=62;i&gt;=0;--i)&#123; if(!(x&gt;&gt;i)) continue; if(!xhj[i])&#123; xhj[i]=x; return; &#125; else&#123; x^=xhj[i]; &#125; &#125;&#125;inline void dfs(int x,int fa)&#123; vis[x]=1; for(int i=0;i&lt;e[x].size();++i)&#123; if(e[x][i].first!=fa)&#123; if(vis[e[x][i].first])&#123; inser(e[x][i].second^w[x]^w[e[x][i].first]); &#125; else&#123; w[e[x][i].first]=w[x]^e[x][i].second; dfs(e[x][i].first,x); &#125; &#125; &#125; &#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; x=read();y=read();z=read(); e[x].pb(mp(y,z)); e[y].pb(mp(x,z)); &#125; dfs(1,0); ans=w[n]; for(int i=62;i&gt;=0;--i)&#123; ans=max(ans,ans^xhj[i]); &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2568 GCD]]></title>
    <url>%2F2018%2F08%2F16%2Fluogu2568%20GCD%2F</url>
    <content type="text"><![CDATA[简单题考虑枚举gcd，剩下的两个东西互质想到线性筛欧拉函数没有注意内存开了1e7的LL+2·1e7的int+1e7的bool居然没有mle注意最小的质数是2欧拉函数只需要到1e7/2即可这样就不会mle12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1e7+8;int n;bool not_pri[N];int pri[N],phi[N/2],num;LL sum[N/2],ans;int main()&#123; n=read(); //phi[1]=sum[1]=1; for(int i=2;i&lt;=n;++i)&#123; if(!not_pri[i])&#123; pri[++num]=i; if(i&lt;=n/2) phi[i]=i-1; &#125; if(i&lt;=n/2) sum[i]=sum[i-1]+phi[i]; int j; for(j=1;j&lt;=num&amp;&amp;pri[j]&lt;=n/i;++j)&#123; not_pri[pri[j]*i]=1; if(i%pri[j])&#123; if(pri[j]&lt;=n/2/i) phi[pri[j]*i]=phi[i]*(pri[j]-1); &#125; else&#123; if(pri[j]&lt;=n/2/i) phi[pri[j]*i]=phi[i]*pri[j]; break; &#125; &#125; &#125; for(int i=1;i&lt;=num;++i)&#123; ans+=sum[n/pri[i]]; &#125; printf("%lld",ans*2+num); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2964 Boss单挑战]]></title>
    <url>%2F2018%2F08%2F16%2Fbzoj2964%20Boss%E5%8D%95%E6%8C%91%E6%88%98%2F</url>
    <content type="text"><![CDATA[相当繁琐的背包dp_mp[i][j]表示用i回合还剩j点mp能打出的max伤害f_mp[i]表示i回合用mp能打出的max伤害转移比较简单，按题目说的做即可sp同理然后求出最小需要mini回合能打死bossdp_hp[i][j]表示第i轮我执行完还剩j血能空出的max回合数如果存在i，使得dp_hp[i][j]&gt;=mini则yes否则如果dp_hp[n+1][j]合法，表明我活过前n轮，tie再否则no 错了一次是因为边界，f应该从0开始，可以不使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008,NN=18;int T;int n,m,hp,mp,sp,dhp,dmp,dsp,x; int a[N];int n1,n2,b[NN],c[NN],y[NN],z[NN];int dp_mp[N][N],dp_sp[N][N],f_mp[N],f_sp[N],dp_hp[N][N]; inline void init()&#123; n=read();m=read();hp=read();mp=read();sp=read();dhp=read();dmp=read();dsp=read();x=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; n1=read(); for(int i=1;i&lt;=n1;++i)&#123; b[i]=read();y[i]=read(); &#125; n2=read(); for(int i=1;i&lt;=n2;++i)&#123; c[i]=read();z[i]=read(); &#125;&#125; inline void up(int &amp;x,int y)&#123; if(y&gt;x) x=y;&#125;int mini,t;inline void solve()&#123; memset(dp_mp,-1,sizeof(dp_mp)); memset(dp_sp,-1,sizeof(dp_sp)); memset(f_mp,0,sizeof(f_mp)); memset(f_sp,0,sizeof(f_sp)); dp_mp[0][mp]=0; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;=mp;++j)&#123; if(~dp_mp[i][j])&#123; up(dp_mp[i+1][min(j+dmp,mp)],dp_mp[i][j]); for(int k=1;k&lt;=n1;++k)&#123; if(j&gt;=b[k]) up(dp_mp[i+1][j-b[k]],dp_mp[i][j]+y[k]); &#125; &#125; &#125; &#125; for(int i=0;i&lt;=n;++i)&#123; for(int j=0;j&lt;=mp;++j) up(f_mp[i],dp_mp[i][j]); &#125; dp_sp[0][sp]=0; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;=sp;++j)&#123; if(~dp_sp[i][j])&#123; up(dp_sp[i+1][min(j+dsp,sp)],dp_sp[i][j]+x); for(int k=1;k&lt;=n2;++k)&#123; if(j&gt;=c[k]) up(dp_sp[i+1][j-c[k]],dp_sp[i][j]+z[k]); &#125; &#125; &#125; &#125; for(int i=0;i&lt;=n;++i)&#123; for(int j=0;j&lt;=sp;++j) up(f_sp[i],dp_sp[i][j]); &#125; mini=INT_MAX; t=n; for(int i=0;i&lt;=n;++i)&#123; while(t&gt;0&amp;&amp;f_mp[i]+f_sp[t-1]&gt;=m) --t; if(f_mp[i]+f_sp[t]&gt;=m) mini=min(mini,i+t); &#125; memset(dp_hp,0,sizeof(dp_hp)); dp_hp[1][hp]=1; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=hp;++j)&#123; if(dp_hp[i][j]&gt;=mini)&#123; printf("Yes %d\n",i); return; &#125; &#125; for(int j=a[i]+1;j&lt;=hp;++j)&#123; if(dp_hp[i][j])&#123; up(dp_hp[i+1][j-a[i]],dp_hp[i][j]+1); up(dp_hp[i+1][min(j-a[i]+dhp,hp)],dp_hp[i][j]); &#125; &#125; &#125; for(int i=1;i&lt;=hp;++i)&#123; if(dp_hp[n+1][i]&gt;0)&#123; puts("Tie"); return; &#125; &#125; puts("No");&#125;int main()&#123; T=read(); while(T--)&#123; init(); solve(); &#125; printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1129 [ZJOI2007]矩阵游戏]]></title>
    <url>%2F2018%2F08%2F14%2Fluogu1129%20%5BZJOI2007%5D%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[行变换和列变换不会使同一行或者同一列的东西分开题目要求最后存在n个两两行列都不同的东西那么一开始也要有n个两两行列都不同的东西然后开始套路左边n个点表示行右边n个点表示列(i,j)为1则 左i -&gt; 右j跑二分图匹配，为n则可以123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N=408,M=100008;int nume,head[N],from[M],to[M],f[M],nxt[M];int d[N],gap[N],cur[N],p[N],num[N];bool vis[N];int t,n,k,en;inline void addedge(int x,int y)&#123; ++nume;to[nume]=y;nxt[nume]=head[x];head[x]=nume;f[nume]=1; ++nume;to[nume]=x;nxt[nume]=head[y];head[y]=nume;f[nume]=0;&#125;void bfs()&#123; queue&lt;int&gt; q; q.push(en); d[0]=en+1; vis[en]=1; while(!q.empty())&#123; int top=q.front();q.pop(); for(int i=head[top];i;i=nxt[i])&#123; if(!vis[to[i]])&#123; vis[to[i]]=1; d[to[i]]=d[top]+1; q.push(to[i]); &#125; &#125; &#125;&#125;int augment()&#123; int x=en; while(x!=0)&#123; f[p[x]]--; f[p[x]^1]++; x=to[p[x]^1]; &#125; return 1;&#125;int maxflow()&#123; bfs(); int ans=0; for(int i=0;i&lt;=en;i++) num[d[i]]++; int x=0; for(int i=0;i&lt;=en;i++)&#123; cur[i]=head[i]; &#125; while(d[0]&lt;=en)&#123; if(x==en)&#123; ans+=augment(); x=0; &#125; bool ok=0; for(int i=cur[x];i;i=nxt[i])&#123; if(f[i]&amp;&amp;d[x]==d[to[i]]+1)&#123; ok=1; p[to[i]]=i; cur[x]=i;//cur[x]=i+1; x=to[i]; break; &#125; &#125; if(!ok)&#123; int m=en; for(int i=head[x];i;i=nxt[i])&#123; if(f[i]) m=min(m,d[to[i]]); &#125; num[d[x]]--; if(!num[d[x]]) break; d[x]=m+1; num[d[x]]++; cur[x]=head[x]; if(x!=0) x=to[p[x]^1]; &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); //cin.tie(0); cin&gt;&gt;t; while(t--)&#123; nume=1; memset(head,0,sizeof(head)); memset(vis,0,sizeof(vis)); memset(gap,0,sizeof(gap)); cin&gt;&gt;n; en=(n&lt;&lt;1)+1; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;k; if(k) addedge(i,j+n); &#125; &#125; for(int i=1;i&lt;=n;i++) addedge(0,i); for(int i=n+1;i&lt;en;i++) addedge(i,en); if(maxflow()==n) cout&lt;&lt;"Yes"&lt;&lt;'\n'; else cout&lt;&lt;"No"&lt;&lt;'\n'; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu4113 [HEOI2012]采花]]></title>
    <url>%2F2018%2F08%2F14%2Fluogu4113%20%5BHEOI2012%5D%E9%87%87%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[颓废好久开始newtrain之后每道题都要写题解！！区间限制数量是经典问题，向前连边即可此题是求区间出现次数大于1的数的个数两种求法：1.对pre+1处-1,1处+1，query为左端点及其左的和，相当于对区间+1，要撤回操作。2.对pre处+1，pre[pre]处-1，query为右端点-（左端点-1），相当于统计每个点对区间的贡献。犯了一个小错误:把n和qn弄错了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=2000008;int n,c,qn;int a[N];struct que&#123; int l,r,id;&#125;q[N];inline bool cmp(const que &amp;a,const que &amp;b)&#123; return a.r&lt;b.r;&#125;int pre[N],pos[N];int t;int bit[N],ans[N];inline void add(int pos,int x)&#123; for(int i=pos;i&lt;=n;i+=i&amp;-i)&#123; bit[i]+=x; &#125;&#125;inline int query(int pos)&#123; int tmp=0; for(int i=pos;i&gt;0;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125;inline void solve(int pos,int type)&#123; if(pre[pos]&gt;0)&#123; add(pre[pos]+1,-1*type); add(1,1*type); &#125;&#125;int main()&#123; n=read();c=read();qn=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;=n;++i)&#123; pre[i]=pos[a[i]]; pos[a[i]]=i; &#125; for(int i=1;i&lt;=qn;++i)&#123; q[i].l=read(); q[i].r=read(); q[i].id=i; &#125; sort(q+1,q+qn+1,cmp); t=1; for(int i=1;i&lt;=n;++i)&#123; /*while(t&lt;q[i].r)&#123; ++t; solve(t,1); solve(pre[t],-1); &#125; ans[q[i].id]=query(q[i].l); */ if(pre[i]&gt;0)&#123; add(pre[i],1); if(pre[pre[i]]&gt;0) add(pre[pre[i]],-1); &#125; while(q[t].r==i&amp;&amp;t&lt;=qn)&#123; ans[q[t].id]=query(q[t].r)-query(q[t].l-1); ++t; &#125; &#125; for(int i=1;i&lt;=qn;++i)&#123; printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>newtrain1</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F13%2F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.点双的缩点 点双中的边全部去掉，连向一个新点2.有向图至少加几条边变成强连通图 （易证明，无环的有向图至少存在一个入度为0/出度为0的点）先缩点，ans=max(入度为0的点数，出度为0的点数)（只有一个点说明已经是强连通图，要特判掉） 注意一个点的时候，是否算作强连通，要看题目！！ 有向图至少加几条边使得每条边都在某个强连通分量内：和上面的问题一样，不过要把单点去掉。3.无向图至少加几条边变成边双 先缩点，ans=ceiling(度数为1的点的数量/2)+度数为0的点的数量（特判只有一个点） 证明（简略）：一条边可以干掉两个叶子 叶子干光了就是双联通 一个点可以插入到一条边里去 无向图至少加几条边变成点双？4.设f[u][i]为在节点u的子树内，费用限制为i的条件下能取到的最大价值5.树上莫队6.//return dcmp(cross(a-p,b-p))==0&amp;&amp;dcmp(dot(a-p,b-p))&lt;0;//ac return dcmp(length(a-p)+length(b-p)-length(a-b))==0&amp;&amp;!(p==a)&amp;&amp;!(p==b);//wa，误差巨大7.double在g++中的输入是%lf,输出时%f。什么时候用什么？ g++中abs一定要有cstdlib，c++不用。8.printf(“%.3f”,0);有错？9.线和凸包是否有交、凸包和凸包是否有交 线和凸包：找线上一个远一些的点，找到两条切线，判断线是否在切线之间 凸包是否有交：？10.点和凸包的切线 凸包外的点p向凸包上一点连线，有的是入凸包，有的是出凸包。则cross(a[i]-p,a[i+1]-a[i])的方向是不同的。找到最后一个入凸包的点，那么下一个点就是切点。左右切线找的时候只需要把方向判断反一下即可。 判断一个点在凸包内：找不到切线，即找不到入凸包的点。11.二维区间和 树套树？12.函数内新建pq？在函数结束时会自动清空吗 会吧13.dp of dp14.异或hash？ 冲突概率1/个数15.并查集 撤销？拆并查集？不能拆16.判断两个点在一个点的不同子树中？17.矩阵转移？18.决策单调性的写法19.prufer编码20.指针和迭代器21.O(n)找第k大22.遍历set是O(n)23.long double怎么用啊24.int128怎么用25.float128怎么用26.01覆盖问题是npc吗 反正不可做27.保留x位小数变成-0.00000?]]></content>
  </entry>
  <entry>
    <title><![CDATA[luogu3084 [USACO13OPEN]照片Photo]]></title>
    <url>%2F2018%2F06%2F25%2Fluogu3084%20%5BUSACO13OPEN%5D%E7%85%A7%E7%89%87Photo%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536区间中有多少个数的题目和pku的夏令营题目挺像的这种题目好像都可以用差分约束做不过卡时这题spfa只能过6个点d[i]表示从1到i的个数d[i]和d[i+1]的关系为d[i]=d[i+1]或d[i]+1=d[i+1]拆成不等式为d[i]=d[i+1] =&gt; d[i]&lt;=d[i+1] d[i]&gt;=d[i+1]d[i]+1=d[i+1] =&gt; d[i]&lt;=d[i+1]-1 d[i]+1&gt;=d[i+1]合并为下面两个（若a&lt;=b，则要让b尽量大）d[i]&lt;=d[i+1]d[i]+1&gt;=d[i+1]初始情况为d[0]=0，其他无穷大（松弛大于n次就有负环一点都不靠谱，随便构造出反例入队大于n次才是正确的，因为假如没有负环，bfs一层就能至少确定一个点的dis所以最多做n(其实n-1，但是要考虑1个点)轮，&gt;n就无解(其实&gt;=n)每个点在每一层最多入队1次(可能被松弛很多次)所以入队次数大于n就无解）正解dpf[i]表示前i个已经满足条件，第i个放了的最大个数f[i]=max(f[j])+1j的范围是关键设i对应的j满足l[i]&lt;=j&lt;=r[i]有且只有1个这个条件拆成至少1个和至多1个l[i]为区间右端点在i左边的左端点的最大值（因为至少1个）r[i]为i所在的区间的左端点的最小值-1（因为至多1个）注意到l[i]和r[i]都是单调不降的所以转移可以用单调队列优化求l[i]和r[i]也可以利用单调性的特点做到O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=200008,M=100008;int n,m;struct node&#123; int l,r;&#125;a[M];int l[N],r[N];int q[N],he,ta,t;int f[N];int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n+1;++i)&#123; r[i]=i-1; &#125; for(int i=1;i&lt;=m;++i)&#123; a[i].l=read();a[i].r=read(); l[a[i].r+1]=max(l[a[i].r+1],a[i].l); r[a[i].r]=min(r[a[i].r],a[i].l-1); &#125; for(int i=1;i&lt;=n;++i) l[i+1]=max(l[i+1],l[i]); for(int i=n;i;--i) r[i]=min(r[i],r[i+1]); he=ta=1;//f[0]=0,q[1]=0; t=1; for(int i=1;i&lt;=n+1;++i)&#123; while(he&lt;=ta&amp;&amp;q[he]&lt;l[i]) ++he; if(t&lt;l[i]) t=l[i]; while(t&lt;=r[i])&#123; if(f[t]!=-1)&#123; while(he&lt;=ta&amp;&amp;f[t]&gt;=f[q[ta]]) --ta; q[++ta]=t; &#125; ++t; &#125; if(he&lt;=ta)&#123; f[i]=f[q[he]]+1; &#125; else&#123; f[i]=-1; &#125; &#125; if(f[n+1]==-1) puts("-1"); else printf("%d",f[n+1]-1); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=200008,M=100008;int n,m;int l,r;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N*2+M*2];inline void add_edge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[N];bool inq[N];int q[N],he,ta;int tim[N]; inline void spfa()&#123; memset(dis,0x3f,sizeof(dis)); dis[0]=0; he=1;ta=2; q[1]=0; inq[0]=1; tim[0]=1; int maxi=min(n,1000); while(he!=ta)&#123; int x=q[he]; ++he; if(he==200005) he=1; inq[x]=0; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; tim[e[i].to]=tim[x]+1; if(tim[e[i].to]&gt;maxi)&#123; puts("-1"); return; &#125; if(!inq[e[i].to])&#123; q[ta]=e[i].to; ++ta; if(ta==200005) ta=1; inq[e[i].to]=1; &#125; &#125; &#125; &#125; printf("%d",dis[n]); return;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; l=read();r=read(); add_edge(l-1,r,1); add_edge(r,l-1,-1); &#125; for(int i=0;i&lt;n;++i)&#123; add_edge(i,i+1,1); add_edge(i+1,i,0); &#125; spfa(); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2157 [SDOI2009]学校食堂]]></title>
    <url>%2F2018%2F06%2F21%2Fluogu2157%20%5BSDOI2009%5D%E5%AD%A6%E6%A0%A1%E9%A3%9F%E5%A0%82%2F</url>
    <content type="text"><![CDATA[1好题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int T;int n;int t[N],b[N];int f[N][1&lt;&lt;8][18];int ans;inline bool ok(int x,int y,int t)&#123; for(int i=x;i&lt;y;++i)&#123; if(((t&gt;&gt;(i-x))&amp;1)==0&amp;&amp;i+b[i]&lt;y) return 0;//注意判不包含的 &#125; return 1;&#125;int main()&#123; T=read(); while(T--)&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; t[i]=read();b[i]=read(); &#125; memset(f,0x3f,sizeof(f)); f[1][0][7]=0; for(int i=1;i&lt;=n;++i)&#123; for(int j=0;j&lt;256;++j)&#123;/////// //for(int j=0;j&lt;(1&lt;&lt;(b[i]+1));++j)&#123; for(int k=0;k&lt;=15;++k)&#123; if(f[i][j][k]&lt;0x3f3f3f3f)&#123; if((j&amp;1))&#123; f[i+1][j&gt;&gt;1][k-1]=min(f[i+1][j&gt;&gt;1][k-1],f[i][j][k]); &#125; else&#123; int tmp=0x3f3f3f3f; for(int p=i;p&lt;=n;++p)&#123; if((j&amp;(1&lt;&lt;(p-i)))==0)&#123; //if(!ok(i,p,j)) break; if(p&gt;tmp) break; tmp=min(tmp,p+b[p]); if(i==1&amp;&amp;j==0) f[i][j|(1&lt;&lt;(p-i))][p-i+8]=0; else f[i][j|(1&lt;&lt;(p-i))][p-i+8]=min(f[i][j|(1&lt;&lt;(p-i))][p-i+8],f[i][j][k]+(t[i+k-8]^t[p])); &#125; &#125; &#125; &#125; &#125; &#125; &#125; ans=0x3f3f3f3f; for(int k=0;k&lt;=7;++k)&#123; ans=min(ans,f[n+1][0][k]); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2331 [SCOI2005]最大子矩阵]]></title>
    <url>%2F2018%2F06%2F20%2Fluogu2331%20%5BSCOI2005%5D%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[123简单的dp对于已经走过的区域，不管有没有选择，都不会管了对于当前的i和j，一定是考虑选这个i或j，而不是之前的（因为之前的在之前被考虑） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108;int n,m,k;int a[N],b[N],sum1[N],sum2[N];int f[N][11],f2[N][N][11];int ans;int main()&#123; n=read();m=read();k=read(); if(m==1)&#123; for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); sum1[i]=sum1[i-1]+a[i]; &#125; for(int i=0;i&lt;=n;++i)&#123; for(int j=1;j&lt;=k;++j)&#123; f[i][j]=-0x3f3f3f3f;//INT_MIN不行，INT_MIN再减东西变成正的了。。 &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=k;++j)&#123; f[i][j]=max(f[i][j],f[i-1][j]); for(int p=0;p&lt;i;++p)&#123; f[i][j]=max(f[i][j],f[p][j-1]+sum1[i]-sum1[p]); &#125; &#125; &#125; for(int j=0;j&lt;=k;++j)&#123; ans=max(ans,f[n][j]); &#125; printf("%d",ans); &#125; else&#123; for(int i=1;i&lt;=n;++i)&#123; a[i]=read();b[i]=read(); sum1[i]=sum1[i-1]+a[i];sum2[i]=sum2[i-1]+b[i]; &#125; for(int i=0;i&lt;=n;++i)&#123; for(int j=0;j&lt;=n;++j)&#123; for(int p=1;p&lt;=k;++p)&#123; f2[i][j][p]=-0x3f3f3f3f; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; for(int p=1;p&lt;=k;++p)&#123; f2[i][j][p]=max(f2[i][j][p],f2[i-1][j][p]); f2[i][j][p]=max(f2[i][j][p],f2[i][j-1][p]); for(int q=0;q&lt;i;++q)&#123; f2[i][j][p]=max(f2[i][j][p],f2[q][j][p-1]+sum1[i]-sum1[q]); &#125; for(int q=0;q&lt;j;++q)&#123; f2[i][j][p]=max(f2[i][j][p],f2[i][q][p-1]+sum2[j]-sum2[q]); &#125; if(i==j)&#123; for(int q=0;q&lt;i;++q)&#123; f2[i][j][p]=max(f2[i][j][p],f2[q][q][p-1]+sum1[i]-sum1[q]+sum2[j]-sum2[q]); &#125; &#125; &#125; &#125; &#125; for(int p=0;p&lt;=k;++p)&#123; ans=max(ans,f2[n][n][p]); &#125; printf("%d",ans); &#125; return 0;&#125;/*10 1 41 2 -3 4 -1 6 -8 7 -9 10*/]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2216 [HAOI2007]理想的正方形]]></title>
    <url>%2F2018%2F06%2F20%2Fluogu2216%20%5BHAOI2007%5D%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[1裸题 st有两种讲得很清楚的博客O(nmlogm) - O(n)O(nmlognlogm) - O(1)这题是求正方形，可以O(nmlogt) - O(1)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int n,m,t;int a[N][N],maxi[N][N][8],mini[N][N][8];int len,ans=INT_MAX;int main()&#123; n=read();m=read();t=read(); memset(mini,0x3f,sizeof(maxi)); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; maxi[i][j][0]=mini[i][j][0]=a[i][j]=read(); &#125; &#125; for(int k=1;(1&lt;&lt;k)&lt;=t;++k)&#123; for(int i=1;i+(1&lt;&lt;k)-1&lt;=n;++i)&#123; for(int j=1;j+(1&lt;&lt;k)-1&lt;=m;++j)&#123; maxi[i][j][k]=max(max(maxi[i][j][k-1],maxi[i+(1&lt;&lt;(k-1))][j][k-1]), max(maxi[i][j+(1&lt;&lt;(k-1))][k-1],maxi[i+(1&lt;&lt;(k-1))][j+(1&lt;&lt;(k-1))][k-1])); mini[i][j][k]=min(min(mini[i][j][k-1],mini[i+(1&lt;&lt;(k-1))][j][k-1]), min(mini[i][j+(1&lt;&lt;(k-1))][k-1],mini[i+(1&lt;&lt;(k-1))][j+(1&lt;&lt;(k-1))][k-1])); &#125; &#125; &#125; //len=0; //while((1&lt;&lt;(len+1))&lt;t) ++len; len=log2(t); for(int i=1;i+t-1&lt;=n;++i)&#123; for(int j=1;j+t-1&lt;=m;++j)&#123; ans=min(ans,max(max(maxi[i][j][len],maxi[i+t-(1&lt;&lt;len)][j][len]),max(maxi[i][j+t-(1&lt;&lt;len)][len],maxi[i+t-(1&lt;&lt;len)][j+t-(1&lt;&lt;len)][len])) -min(min(mini[i][j][len],mini[i+t-(1&lt;&lt;len)][j][len]),min(mini[i][j+t-(1&lt;&lt;len)][len],mini[i+t-(1&lt;&lt;len)][j+t-(1&lt;&lt;len)][len]))); &#125; &#125; printf("%d",ans); return 0;&#125; O(nm)的单调队列写错是因为变量名打错！！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int n,m,t;int a[N][N],maxi[N][N],mini[N][N];int q[N],pos[N],he,ta; int main()&#123; n=read();m=read();t=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; a[i][j]=read(); &#125; &#125; //---------------- for(int i=1;i&lt;=n;++i)&#123; he=1;ta=0; for(int j=1;j&lt;t;++j)&#123; while(he&lt;=ta&amp;&amp;a[i][j]&gt;=q[ta]) --ta; q[++ta]=a[i][j]; pos[ta]=j; &#125; for(int j=t;j&lt;=m;++j)&#123; while(he&lt;=ta&amp;&amp;pos[he]&lt;=j-t) ++he; while(he&lt;=ta&amp;&amp;a[i][j]&gt;=q[ta]) --ta; q[++ta]=a[i][j]; pos[ta]=j; maxi[i][j]=q[he]; &#125; &#125;/* for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; cout&lt;&lt;maxi[i][j]&lt;&lt;' '; &#125;cout&lt;&lt;'\n'; &#125; puts("");*/ for(int j=t;j&lt;=m;++j)&#123; he=1;ta=0; for(int i=1;i&lt;t;++i)&#123; while(he&lt;=ta&amp;&amp;maxi[i][j]&gt;=q[ta]) --ta; q[++ta]=maxi[i][j]; pos[ta]=i; &#125; for(int i=t;i&lt;=n;++i)&#123; while(he&lt;=ta&amp;&amp;pos[he]&lt;=i-t) ++he; while(he&lt;=ta&amp;&amp;maxi[i][j]&gt;=q[ta]) --ta; q[++ta]=maxi[i][j]; pos[ta]=i; maxi[i][j]=q[he]; &#125; &#125;/* for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; cout&lt;&lt;maxi[i][j]&lt;&lt;' '; &#125;cout&lt;&lt;'\n'; &#125; puts("");*/ //-------------------------- for(int i=1;i&lt;=n;++i)&#123; he=1;ta=0; for(int j=1;j&lt;t;++j)&#123; while(he&lt;=ta&amp;&amp;a[i][j]&lt;=q[ta]) --ta; q[++ta]=a[i][j]; pos[ta]=j; &#125; for(int j=t;j&lt;=m;++j)&#123; while(he&lt;=ta&amp;&amp;pos[he]&lt;=j-t) ++he; while(he&lt;=ta&amp;&amp;a[i][j]&lt;=q[ta]) --ta; q[++ta]=a[i][j]; pos[ta]=j; mini[i][j]=q[he]; &#125; &#125;/* for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; cout&lt;&lt;mini[i][j]&lt;&lt;' '; &#125;cout&lt;&lt;'\n'; &#125; puts("");*/ for(int j=t;j&lt;=m;++j)&#123; he=1;ta=0; for(int i=1;i&lt;t;++i)&#123; while(he&lt;=ta&amp;&amp;mini[i][j]&lt;=q[ta]) --ta; q[++ta]=mini[i][j]; pos[ta]=i; &#125; for(int i=t;i&lt;=n;++i)&#123; while(he&lt;=ta&amp;&amp;pos[he]&lt;=i-t) ++he; while(he&lt;=ta&amp;&amp;mini[i][j]&lt;=q[ta]) --ta; q[++ta]=mini[i][j]; pos[ta]=i; mini[i][j]=q[he]; &#125; &#125; /*for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; cout&lt;&lt;mini[i][j]&lt;&lt;' '; &#125;cout&lt;&lt;'\n'; &#125; puts("");*/ int ans=INT_MAX; for(int i=t;i&lt;=n;++i)&#123; for(int j=t;j&lt;=m;++j)&#123; ans=min(ans,maxi[i][j]-mini[i][j]); &#125; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>单调队列</tag>
        <tag>st</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dp专题]]></title>
    <url>%2F2018%2F06%2F20%2Fdp%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我的dp实在太差了（不忍直视写一个总结和提醒一样的东西（不定时更新 dp的几个重要的东西状态（纬度，空间时间，哪些状态合法）转移（转移条件，转移范围，转移顺序，所有合法状态要被考虑）初始状态（边界）最终状态（目标）确定的顺序应该是从上到下 把做得不顺的题记下来 luogu2157 [SDOI2009]学校食堂(状压)调了好久错误在于两个细节一是for(int j=0;j&gt;(i-x))&amp;1)==0&amp;&amp;i+b[i]&lt;y) return 0;前一个判断不能少 单调性[USACO13OPEN]照片Photo等于可以拆成两句话，大于等于和小于等于有单调性的话很多都可以O(n)做了]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客 贝壳找房与送水员]]></title>
    <url>%2F2018%2F06%2F18%2F%E8%AE%A1%E8%92%9C%E5%AE%A2%20%E8%B4%9D%E5%A3%B3%E6%89%BE%E6%88%BF%E4%B8%8E%E9%80%81%E6%B0%B4%E5%91%98%2F</url>
    <content type="text"><![CDATA[1234567891011121314好题发现了两个v的做法但是没发现一个v的按照之前的思路死活做不出来，这时候要跳出之前的思维模式（重点！重点！重点！）不再是按照对位的边形成的树上找了而是考虑有没有环题解：1个v：现在题意变成了要求多组单向可达关系加最少有向边的问题。考虑每个弱联通子图，如果是个dag的话最少需要v-1个魔法（构造方法：用链将拓扑序串起来），否则的话至少需要v个魔法（一个大环）。然后加起来就好了。发现不会找弱连通子图哇哇哇dfs3+dfs2，再开两个vis数组丑的不行的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008,shiwan=100000;int n;char s[20];int cnt;int a[N],b[N];bool vis[N],ins[N];vector&lt;int&gt; v;int nume,head[N];int nume_2,head_2[N];struct edge&#123; int to,nxt;&#125;e[N&lt;&lt;1],e_2[N&lt;&lt;1];inline void add_edge(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;inline void add_edge_2(int x,int y)&#123; e_2[++nume_2]=(edge)&#123;y,head_2[x]&#125;;head_2[x]=nume_2;&#125;int ans;inline void dfs(int x)&#123; vis[x]=0; for(int i=head[x];i;i=e[i].nxt)&#123; if(vis[e[i].to])&#123; dfs(e[i].to); &#125; &#125;&#125;bool flag;inline void dfs2(int x)&#123; vis[x]=0; ins[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(vis[e[i].to])&#123; dfs2(e[i].to); &#125; else if(ins[e[i].to])&#123; flag=1; &#125; &#125; ins[x]=0;&#125;bool vis2[N];inline void dfs3(int x)&#123; if(vis[x])&#123; dfs2(x); &#125; vis2[x]=1; for(int i=head_2[x];i;i=e_2[i].nxt)&#123; if(!vis2[e_2[i].to])&#123; dfs3(e_2[i].to); &#125; &#125;&#125;inline void solve()&#123; if(cnt==0)&#123; for(int i=1;i&lt;=n;++i)&#123; if(a[i]!=b[i])&#123; puts("-1"); return; &#125; &#125; puts("0"); return; &#125; if(cnt==1)&#123; for(int i=1;i&lt;=n;++i)&#123; if(a[i]!=b[i])&#123; add_edge(a[i],b[i]); add_edge_2(a[i],b[i]); add_edge_2(b[i],a[i]); if(!vis[a[i]])&#123; v.pb(a[i]); vis[a[i]]=1; &#125; if(!vis[b[i]])&#123; v.pb(b[i]); vis[b[i]]=1; &#125; &#125; &#125; ans=v.size(); for(int i=0;i&lt;v.size();++i)&#123; if(vis[v[i]])&#123; flag=0; dfs3(v[i]); if(!flag) --ans; &#125; &#125; printf("%d",ans); return; &#125; if(cnt==2)&#123; for(int i=1;i&lt;=n;++i)&#123; if(a[i]!=b[i])&#123; add_edge(a[i],b[i]); add_edge(b[i],a[i]); if(!vis[a[i]])&#123; v.pb(a[i]); vis[a[i]]=1; &#125; if(!vis[b[i]])&#123; v.pb(b[i]); vis[b[i]]=1; &#125; &#125; &#125; ans=v.size(); for(int i=0;i&lt;v.size();++i)&#123; if(vis[v[i]])&#123; dfs(v[i]); --ans; &#125; &#125; printf("%d",ans); return; &#125;&#125;int main()&#123; //freopen("D.in","r",stdin); n=read(); scanf("%s",s+1); if(s[1]=='V') ++cnt; for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; scanf("%s",s+1); if(s[1]=='V') ++cnt; for(int i=1;i&lt;=n;++i)&#123; b[i]=read(); &#125; solve(); return 0;&#125;]]></content>
      <tags>
        <tag>观察</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待填的坑]]></title>
    <url>%2F2018%2F06%2F16%2F%E5%BE%85%E5%A1%AB%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[1.块状数组/块状链表2.上下界网络流3.fft/ntt4.dp斜率优化/四边形不等式/决策单调性5.数论（反演/筛，置换）6.图论（tarjan，仙人掌（圆方树））7.数据结构（线段树合并和分裂，主席树，点分治，平衡树，二叉堆，cdq分治，整体二分，lct，k-d tree）8.容斥9.高精度除法]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[989D A Shade of Moonlight]]></title>
    <url>%2F2018%2F06%2F12%2F989D%20A%20Shade%20of%20Moonlight%2F</url>
    <content type="text"><![CDATA[1234567风吹云走其实云是不动的是月亮在走这就是第一步然后将时间作为第二轴画出来A picture is worth a thousand words. 然后就是拼命推公式（干了好久。。）vector a中存向右的$x_u$vector b中存向左的$xv$$$\frac{1}{w{max}}&lt;\frac{x_v-x_u+l}{|x_u+x_v+l|}$$拆绝对值1.$x_u+x_v+l&gt;=0$,$$x_v&gt;\frac{x_u(w+1)}{w-1}-l$$2.$x_u+x_v+l\frac{x_u(w-1)}{w+1}-l$$注意$x_u&gt;=0$时只会在1.中产生贡献,且1.中不等式成立的话条件就成立$x_u]]></content>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hiho1412 Rikka with Subsequence]]></title>
    <url>%2F2018%2F06%2F11%2Fhiho1412%20Rikka%20with%20Subsequence%2F</url>
    <content type="text"><![CDATA[123456序列自动机本质上就是dp所以这题考虑dpf[i]表示到以i结尾的子序列的合法的概率数c[i][ch]表示到第i位为止没有用到的ch全被删除的子序列的合法的概率数发现c的第一维无意义可以省去dp的含义要搞清楚 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008,mod=998244353;int ni=828542813; int n;char s[N];int a[N];int f[N],c[28],ans;inline LL ksm(LL x,int y)&#123; LL tmp=1; while(y)&#123; if(y&amp;1) tmp=tmp*x%mod; x=x*x%mod; y&gt;&gt;=1; &#125; return tmp;&#125;int main()&#123; n=read(); scanf("%s",s+1); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=0;i&lt;26;++i)&#123; c[i]=1; &#125; f[0]=1; for(int i=1;i&lt;=n;++i)&#123; f[i]=1ll*c[s[i]-'a']*(100-a[i])%mod*ni%mod; for(int j=0;j&lt;26;++j)&#123; if(s[i]-'a'==j)&#123; c[j]=(1ll*c[j]*a[i]%mod*ni%mod+f[i])%mod; &#125; else&#123; c[j]=(c[j]+f[i])%mod; &#125; &#125; &#125; for(int i=0;i&lt;=n;++i)&#123; ans=(ans+f[i])%mod; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3989 [SHOI2013]阶乘字符串（序列自动机）]]></title>
    <url>%2F2018%2F06%2F07%2Fluogu3989%20%5BSHOI2013%5D%E9%98%B6%E4%B9%98%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[12345序列自动机就是dp。。记录next[i][26]，O(26n)的预处理，从n到1，每次a[26]记录最后出现的位置，然后复制给next就可以了（next是dag）状压加手算优化（大于21就无解我也不会证）可以看第一道魔改题构造出n^2-2n+4的数列（所以可以卡22） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=28,L=458;int T;int n,len;char s[L];int next[L][N];inline void get_next()&#123; for(int i=0;i&lt;n;++i)&#123; next[len][i]=next[len+1][i]=len+1; &#125; for(int i=len;i;--i)&#123; for(int j=0;j&lt;n;++j)&#123; next[i-1][j]=next[i][j]; &#125; next[i-1][s[i]-'a']=i; &#125;&#125;int f[1&lt;&lt;21];inline bool dp()&#123; for(int i=1;i&lt;(1&lt;&lt;n);++i)&#123; f[i]=0; //for(int j=0;j&lt;n;++j)&#123; // if((i&gt;&gt;j)&amp;1)&#123; // f[i]=max(f[i],next[f[i^(1&lt;&lt;j)]][j]); // &#125; //&#125; for(int j=i;j;j^=j&amp;-j)&#123; f[i]=max(f[i],next[f[i^(j&amp;-j)]][__builtin_ctz(j)]); &#125; if(f[i]&gt;len) return 0; &#125; return 1;&#125;int main()&#123; T=read(); while(T--)&#123; n=read(); scanf("%s",s+1); if(n&gt;21)&#123; puts("NO"); continue; &#125; len=strlen(s+1); get_next(); if(dp()) puts("YES"); else puts("NO"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>状压</tag>
        <tag>序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】后缀数组]]></title>
    <url>%2F2018%2F06%2F07%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[后缀数组吼啊（据说sam更好啊等我肝完后缀数组就去看sam之前学了一遍倍增又忘了论文中的变量名简直不让人学会把下标和含义说清楚的博客所以我的板子一定要给数组含义rk_[i]=j表示后缀i的排名rk1[]中会有相同的排名，但是sa[]的下标（也就是排名）是没有相同的sa[i]=j表示排名i的后缀对后缀i，lcp[i]&gt;=lcp[i-1]+1 多次求sa的话记得先把cnt清空12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;char s[N]; int sa[N],rk[N],a[N],b[N],cnt[N];inline void get_sa()&#123; int m=128; int *rk_1=a,*sa_2=b,*tmp; //for i = 1 to m cnt[i]=0 for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;int lcp[N];inline void get_lcp()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[i]&gt;1)&#123; if(k) --k; int j=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k])&#123; ++k; &#125; lcp[rk[i]]=k; &#125; &#125;&#125;int main()&#123; scanf("%s",s+1); n=strlen(s+1); get_sa(); get_lcp(); for(int i=1;i&lt;=n;++i)&#123; printf("%d ",sa[i]); &#125; puts(""); for(int i=2;i&lt;=n;++i)&#123; printf("%d ",lcp[i]); &#125; return 0;&#125; 新板子hgt[i]表示排名i和排名i-1的后缀的lcp 倍增的排序用的是基数排序基数排序的第一关键字用计数排序。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_back#define fi first#define se second#define IL inlineusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;IL LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;#define io read()const int N=100008;int n;char s[N];int sa[N],rk[N],sa2[N],cnt[N];IL void get_sa()&#123; int *sa2=::sa2,*rk=::rk; int m=128; for(int i=1;i&lt;=n;++i) ++cnt[rk[i]=s[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=1;i&lt;=n;++i) sa[++cnt[rk[i]-1]]=i;//sa[cnt[rk2[i]]--]=i; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa2[++p]=sa[i]-k; for(int i=0;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i&gt;0;--i) sa[cnt[rk[sa2[i]]]--]=sa2[i]; //for(int i=1;i&lt;=n;++i) sa[++cnt[rk2[sa2[i]]-1]]=sa2[i]; swap(sa2,rk); rk[sa[1]]=p=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;sa2[sa[i]]==sa2[sa[i-1]]&amp;&amp;sa2[sa[i]+k]==sa2[sa[i-1]+k])&#123; rk[sa[i]]=p; &#125; else&#123; rk[sa[i]]=++p; &#125; &#125; if(p==n) break;//!! &#125;&#125;int hgt[N];IL void get_hgt()&#123; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i; for(int i=1,k=0;i&lt;=n;++i)&#123; if(rk[i]&gt;1)&#123; if(k&gt;0) --k; int j=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k])&#123; ++k; &#125; hgt[rk[i]]=k; &#125; &#125;&#125;int main()&#123; scanf("%s",s+1); n=strlen(s+1); get_sa(); get_hgt(); for(int i=1;i&lt;=n;++i)&#123; printf("%d ",sa[i]); &#125; putchar('\n'); for(int i=2;i&lt;=n;++i)&#123; printf("%d ",hgt[i]); &#125; return 0;&#125;int lg2[N],st[20][N];for(int i=2;i&lt;=n;++i)&#123;//在n输入之前的话要预处理到N lg2[i]=lg2[i&gt;&gt;1]+1;&#125;IL void get_lcp()&#123; for(int i=2;i&lt;=n;++i) st[0][i]=hgt[i]; for(int i=1;(1&lt;&lt;i)&lt;n;++i)&#123; for(int j=2;j+(1&lt;&lt;i)-1&lt;=n;++j)&#123; st[i][j]=min(st[i-1][j],st[i-1][j+(1&lt;&lt;(i-1))]); &#125; &#125;&#125;IL int get_lcp(int x,int y)&#123; if(x==y) return n-sa[x]+1;//求同一个后缀的lcp就是自身的长度 if(x&gt;y) swap(x,y);++x; int t=lg2[y-x+1]; return min(st[t][x],st[t][y-(1&lt;&lt;t)+1]);&#125; hihocoder上有四道后缀数组经典应用题hiho1403 后缀数组一·重复旋律 最长可重叠重复K次子串（单调队列）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=20008;int n,k;int s[N];int sa[N],rk[N],lcp[N],a[N],b[N],cnt[N];inline void get_sa()&#123; int m=100; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;inline void get_lcp()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[i]&gt;1)&#123; if(k) --k; int j=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k])&#123; ++k; &#125; lcp[rk[i]]=k; &#125; &#125;&#125;int q[N],he,ta;int ans;int main()&#123; n=read();k=read(); for(int i=1;i&lt;=n;++i)&#123; s[i]=read(); &#125; if(k==1)&#123; printf("%d",n); return 0; &#125; get_sa(); get_lcp(); --k; he=1;ta=0; for(int i=2;i&lt;2+k;++i)&#123; while(he&lt;=ta&amp;&amp;lcp[i]&lt;=lcp[q[ta]])&#123; --ta; &#125; q[++ta]=i; &#125; for(int i=2+k;i&lt;=n;++i)&#123; while(he&lt;=ta&amp;&amp;lcp[i]&lt;=lcp[q[ta]])&#123; --ta; &#125; q[++ta]=i; if(i-q[he]&gt;=k) ++he; ans=max(ans,lcp[q[he]]); &#125; printf("%d",ans); return 0;&#125; hiho1407 后缀数组二·重复旋律2 最长不可重叠重复子串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;int s[N];int sa[N],rk[N],lcp[N],a[N],b[N],cnt[N];inline void get_sa()&#123; int m=1000; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;inline void get_lcp()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[i]&gt;1)&#123; if(k) --k; int j=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k])&#123; ++k; &#125; lcp[rk[i]]=k; &#125; &#125;&#125;int l,r,mid,ans;int mini,maxi;inline bool ok()&#123; mini=sa[1]; maxi=sa[1]; for(int i=2;i&lt;=n;++i)&#123; if(lcp[i]&lt;mid)&#123; mini=sa[i]; maxi=sa[i]; &#125; else&#123; mini=min(mini,sa[i]); maxi=max(maxi,sa[i]); if(maxi-mini&gt;=mid) return 1; &#125; &#125; return 0;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; s[i]=read(); &#125; get_sa(); get_lcp(); l=0;r=n-1; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(ok())&#123; ans=mid; l=mid+1; &#125; else&#123; r=mid-1; &#125; &#125; printf("%d",ans); return 0;&#125; hiho1415 后缀数组三·重复旋律3 最长公共子串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=200008;int n1,n;char s[N];int sa[N],rk[N],lcp[N],a[N],b[N],cnt[N];inline void get_sa()&#123; int m=128; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;inline void get_lcp()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[i]&gt;1)&#123; if(k) --k; int j=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) ++k; lcp[rk[i]]=k; &#125; &#125;&#125;int ans;int main()&#123; scanf("%s",s+1); n1=strlen(s+1); s[n1+1]='#'; scanf("%s",s+n1+2); n=strlen(s+1); get_sa(); get_lcp(); for(int i=2;i&lt;=n;++i)&#123; if((sa[i-1]&lt;=n1)^(sa[i]&lt;=n1))&#123; ans=max(ans,lcp[i]); &#125; &#125; printf("%d",ans); return 0;&#125; hiho1419 后缀数组四·重复旋律4 重复次数最多的连续字串错了好多次就是st_rev和st打错了重写了一遍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;char s[N],s_rev[N];int sa[N],rk[N],lcp[N],a[N],b[N],cnt[N];inline void get_sa()&#123; int m=128; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;inline void get_lcp()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[i]&gt;1)&#123; if(k) --k; int j=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) ++k; lcp[rk[i]]=k; &#125; &#125;&#125;inline void get_sa_rev()&#123; int m=128; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s_rev[i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;int rk_rev[N],lcp_rev[N];inline void get_lcp_rev()&#123; int k=0; for(int i=1;i&lt;=n;++i) rk_rev[sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk_rev[i]&gt;1)&#123; if(k) --k; int j=sa[rk_rev[i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s_rev[i+k]==s_rev[j+k]) ++k; lcp_rev[rk_rev[i]]=k; &#125; &#125;&#125;int st[20][N],st_rev[20][N];inline void get_st()&#123; for(int i=2;i&lt;=n;++i)&#123; st[0][i]=lcp[i]; &#125; for(int i=1;(1&lt;&lt;i)&lt;n;++i)&#123; for(int j=2;j+(1&lt;&lt;i)-1&lt;=n;++j)&#123; st[i][j]=min(st[i-1][j],st[i-1][j+(1&lt;&lt;(i-1))]); &#125; &#125;&#125;inline void get_st_rev()&#123; for(int i=2;i&lt;=n;++i)&#123; st_rev[0][i]=lcp_rev[i]; &#125; for(int i=1;(1&lt;&lt;i)&lt;n;++i)&#123; for(int j=2;j+(1&lt;&lt;i)-1&lt;=n;++j)&#123; st_rev[i][j]=min(st_rev[i-1][j],st_rev[i-1][j+(1&lt;&lt;(i-1))]); &#125; &#125;&#125;inline int rmq(int x,int y)&#123; if(x&gt;y) swap(x,y); int t=log2(y-x); return min(st[t][x+1],st[t][y-(1&lt;&lt;t)+1]);&#125;inline int rmq_rev(int x,int y)&#123; if(x&gt;y) swap(x,y); int t=log2(y-x); return min(st_rev[t][x+1],st_rev[t][y-(1&lt;&lt;t)+1]);&#125;int x,y,ans;int main()&#123; scanf("%s",s+1); n=strlen(s+1); get_sa(); get_lcp(); get_st(); for(int i=1;i&lt;=n;++i)&#123; s_rev[i]=s[n-i+1]; &#125; get_sa_rev(); get_lcp_rev(); get_st_rev(); ans=1; for(int l=1;l&lt;=n/2;++l)&#123; y=l; for(int i=1;i&lt;n/l;++i)&#123; x=y; y+=l; ans=max(ans,(rmq(rk[x],rk[y])+rmq_rev(rk_rev[n-x+1],rk_rev[n-y+1])-1)/l+1); &#125; &#125; printf("%d\n",ans); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;char s[2][N];int sa[N],rk[2][N],lcp[2][N],a[N],b[N],cnt[N];inline void get_sa(int id)&#123; int m=128; int *rk_1=a,*sa_2=b,*tmp; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[i]=s[id][i]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[i]]]=i,--cnt[rk_1[i]]; for(int k=1,p;k&lt;=n;k&lt;&lt;=1,m=p)&#123; p=0; for(int i=n-k+1;i&lt;=n;++i) sa_2[++p]=i; for(int i=1;i&lt;=n;++i) if(sa[i]&gt;k) sa_2[++p]=sa[i]-k; for(int i=1;i&lt;=m;++i) cnt[i]=0; for(int i=1;i&lt;=n;++i) ++cnt[rk_1[sa_2[i]]]; for(int i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for(int i=n;i;--i) sa[cnt[rk_1[sa_2[i]]]]=sa_2[i],--cnt[rk_1[sa_2[i]]]; tmp=sa_2; p=1; tmp[sa[1]]=1; for(int i=2;i&lt;=n;++i)&#123; if(sa[i]+k&lt;=n&amp;&amp;sa[i-1]+k&lt;=n&amp;&amp;rk_1[sa[i]]==rk_1[sa[i-1]]&amp;&amp;rk_1[sa[i]+k]==rk_1[sa[i-1]+k])&#123; tmp[sa[i]]=p; &#125; else&#123; tmp[sa[i]]=++p; &#125; &#125; if(p==n) break; swap(rk_1,sa_2); &#125;&#125;inline void get_lcp(int id)&#123; int k=0; for(int i=1;i&lt;=n;++i) rk[id][sa[i]]=i; for(int i=1;i&lt;=n;++i)&#123; if(rk[id][i])&#123; if(k) --k; int j=sa[rk[id][i]-1]; while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[id][i+k]==s[id][j+k]) ++k; lcp[id][rk[id][i]]=k; &#125; &#125;&#125;int st[2][20][N];inline void get_st(int id)&#123; for(int i=2;i&lt;=n;++i)&#123; st[id][0][i]=lcp[id][i]; &#125; for(int i=1;(1&lt;&lt;i)&lt;n;++i)&#123; for(int j=2;j+(1&lt;&lt;i)-1&lt;=n;++j)&#123; st[id][i][j]=min(st[id][i-1][j],st[id][i-1][j+(1&lt;&lt;(i-1))]); &#125; &#125;&#125;inline int rmq(int id,int x,int y)&#123; if(x&gt;y) swap(x,y); int t=log2(y-x); return min(st[id][t][x+1],st[id][t][y-(1&lt;&lt;t)+1]);&#125;int x,y;int ans;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); scanf("%s",s[0]+1); n=strlen(s[0]+1); for(int i=1;i&lt;=n;++i)&#123; s[1][i]=s[0][n-i+1]; &#125; get_sa(0); get_lcp(0); get_st(0); get_sa(1); get_lcp(1); get_st(1); ans=1; for(int l=1;l&lt;=n/2;++l)&#123; y=l; for(int i=1;i&lt;n/l;++i)&#123; x=y; y+=l; ans=max(ans,(rmq(0,rk[0][x],rk[0][y])+rmq(1,rk[1][n-x+1],rk[1][n-y+1])-1)/l+1); &#125; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔改题]]></title>
    <url>%2F2018%2F06%2F07%2F%E9%AD%94%E6%94%B9%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.求子序列包含1到n的全排列的数列的长度的最小值https://ipsc.ksp.sk/2013/problems D和Rhttps://ipsc.ksp.sk/2013/real/solutions/booklet.pdf是open question有一种构造n^2-2n+4n=1,ans=1,a[1]=1;n=2,ans=3,a[1]=1,a[2]=2,a[3]=1;n=3,ans=7,a[]=1,2,1,3,1,2,1;n=4,ans=12,a[]=1,2,3,4,1,2,3,1,4,2,1,3;n=5,ans=19,a[]=1,5,2,3,4,5,1,2,3,5,4,1,2,5,3,4,1,5,2;]]></content>
      <tags>
        <tag>题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%9D%82%2F</url>
    <content type="text"><![CDATA[6.6不要在学校里面打印啊啊啊0.8元一张超贵的在家打一份到学校复印0.15元一张 6.14发现问题才是最困难的啊懵懵懂懂连问题都问不出来说明是真的没理解发现问题起码说明思路是清晰的（可能不对？）]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu4503 [CTSC2014]企鹅QQ]]></title>
    <url>%2F2018%2F06%2F05%2Fluogu4503%20%5BCTSC2014%5D%E4%BC%81%E9%B9%85QQ%2F</url>
    <content type="text"><![CDATA[123456789单hash被卡我也很无奈（明明很正常好吗）但是rk1居然是单hash。。233无敌啊不过我233就a不了挺简单的就是要双hashhzw的做法也挺强的前后各一边hash，每次底数不一样反正不要让删掉的那一位有贡献就行怎么做你开心就好 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=30008,L=208,base=521,base2=1999;int n,l;char s[N][L];int len[N];LL hash[N],mi[L],hash2[N],mi2[L];struct node&#123; int x,y;&#125;tmp[N];int cnt,ans;inline bool cmp(const node &amp;a,const node &amp;b)&#123; if(a.x!=b.x) return a.x&lt;b.x; return a.y&lt;b.y;&#125;int main()&#123; n=read();l=read();cnt=read(); mi[0]=mi2[0]=1; for(int i=1;i&lt;L;++i)&#123; mi[i]=mi[i-1]*base; mi2[i]=mi2[i-1]*base2; &#125; for(int i=1;i&lt;=n;++i)&#123; scanf("%s",s[i]+1); for(int j=1;j&lt;=l;++j)&#123; hash[i]=hash[i]*base+s[i][j]; hash2[i]=hash2[i]*base2+s[i][j]; &#125; &#125; for(int i=1;i&lt;=l;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; tmp[j].x=hash[j]-s[j][i]*mi[l-i]; tmp[j].y=hash2[j]-s[j][i]*mi2[l-i]; &#125; sort(tmp+1,tmp+n+1,cmp); cnt=1; for(int j=2;j&lt;=n;++j)&#123; if(tmp[j].x==tmp[j-1].x&amp;&amp;tmp[j].y==tmp[j-1].y)&#123; ans+=cnt; ++cnt; &#125; else&#123; cnt=1; &#125; &#125; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3502 [POI2010]Hamsters]]></title>
    <url>%2F2018%2F06%2F05%2Fluogu3502%20%5BPOI2010%5DHamsters%2F</url>
    <content type="text"><![CDATA[1234567891011121314因为单词数比较少不要一个字符一个字符考虑考虑一个单词到一个单词的转移求出i到j的转移（用hash，复杂度是O(sum(len)*n))题目变成求出在n个点的图上走k步最少的边权和k小的话可以O(nk)dpk大的话考虑dp优化，矩阵+倍增，预处理出走2的幂步的最小边权和犯了一堆错：i/j打错mi[0]没有初始化少break，break后不执行++i!数组开小了hash和mi要求同类型 ``` #include #define mp make_pair #define pb push_backusing namespace std;typedef long long LL;typedef pair PII;inline LL read(){ LL x=0,f=1;char ch=getchar(); while(ch&lt;’0’||ch&gt;’9’){if(ch==’-‘)f=-1;ch=getchar();} while(ch&gt;=’0’&amp;&amp;ch&lt;=’9’){x=(x&lt;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>倍增</tag>
        <tag>hash</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3538 [POI2012]A Horrible Poem]]></title>
    <url>%2F2018%2F06%2F04%2Fluogu3538%20%5BPOI2012%5DA%20Horrible%20Poem%2F</url>
    <content type="text"><![CDATA[1234567891011hash1.自然溢出，ll或ull都可以，不需要模数，快，可能会被卡2.取模，注意永远不要变成负值，值域控制在[0,p)，因为变成负值相当于一种取模3.双hash：hash1+hash2，可能会被卡常判断一个字符串的循环节：枚举len（len整除|s|)然后判断前|s|-len和后|s|-len个的hash值是否相同对每个询问，不断除以长度的质因数并判断总复杂度是O(n+qlogn)先线性筛求出每个数的最小质因数，然后可以在O(总因数个数)内求出1到n的因数个数 自然溢出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008,base=233;int n,qn;char s[N];int l,r;int hash[N],mi[N];bool vis[N];int pri[N],li_pri[N],num;vector&lt;int&gt; factor[N];inline void shai()&#123; for(int i=2;i&lt;=n;++i)&#123; if(!vis[i])&#123; pri[++num]=i; li_pri[i]=i; factor[i].pb(i); &#125; else&#123; factor[i].pb(li_pri[i]); int tmp=i; tmp/=li_pri[i]; for(int j=0;j&lt;factor[tmp].size();++j)&#123; if(factor[i][factor[i].size()-1]!=factor[tmp][j]) factor[i].pb(factor[tmp][j]); &#125; &#125; for(int j=1;j&lt;=n&amp;&amp;pri[j]*i&lt;=n;++j)&#123; vis[pri[j]*i]=1; li_pri[pri[j]*i]=pri[j]; if(i%pri[j]==0) break; &#125; &#125;&#125;inline int get_hash(int l,int r)&#123; return hash[r]-hash[l-1]*mi[r-l+1];&#125;int main()&#123; n=read(); //scanf(&quot;%s&quot;,s+1); gets(s+1); mi[0]=1; for(int i=1;i&lt;=n;++i)&#123; hash[i]=hash[i-1]*base+s[i]; mi[i]=mi[i-1]*base; &#125; shai(); qn=read(); while(qn--)&#123; l=read();r=read(); if(l==r)&#123; puts(&quot;1&quot;); continue; &#125; int tmp=r-l+1,ans=tmp; for(int i=0;i&lt;factor[tmp].size();++i)&#123; while(ans%factor[tmp][i]==0&amp;&amp;get_hash(l,r-ans/factor[tmp][i])==get_hash(l+ans/factor[tmp][i],r))&#123; ans/=factor[tmp][i]; &#125; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 单hash12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008,base=233,mod=998244353;int n,qn;char s[N];int l,r;int hash[N],mi[N];bool vis[N];int pri[N],li_pri[N],num;vector&lt;int&gt; factor[N];inline void shai()&#123; for(int i=2;i&lt;=n;++i)&#123; if(!vis[i])&#123; pri[++num]=i; li_pri[i]=i; factor[i].pb(i); &#125; else&#123; factor[i].pb(li_pri[i]); int tmp=i; tmp/=li_pri[i]; for(int j=0;j&lt;factor[tmp].size();++j)&#123; if(factor[i][factor[i].size()-1]!=factor[tmp][j]) factor[i].pb(factor[tmp][j]); &#125; &#125; for(int j=1;j&lt;=n&amp;&amp;pri[j]*i&lt;=n;++j)&#123; vis[pri[j]*i]=1; li_pri[pri[j]*i]=pri[j]; if(i%pri[j]==0) break; &#125; &#125;&#125;inline int get_hash(int l,int r)&#123; return (hash[r]-1ll*hash[l-1]*mi[r-l+1]%mod+mod)%mod;&#125;int main()&#123; n=read(); //scanf(&quot;%s&quot;,s+1); gets(s+1); mi[0]=1; for(int i=1;i&lt;=n;++i)&#123; hash[i]=(1ll*hash[i-1]*base%mod+s[i])%mod; mi[i]=1ll*mi[i-1]*base%mod; &#125; shai(); qn=read(); while(qn--)&#123; l=read();r=read(); if(l==r)&#123; puts(&quot;1&quot;); continue; &#125; int tmp=r-l+1,ans=tmp; for(int i=0;i&lt;factor[tmp].size();++i)&#123; while(ans%factor[tmp][i]==0&amp;&amp;get_hash(l,r-ans/factor[tmp][i])==get_hash(l+ans/factor[tmp][i],r))&#123; ans/=factor[tmp][i]; &#125; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 双hash12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008,base=233,mod=998244353;int n,qn;char s[N];int l,r;int hash1[N],mi1[N],hash2[N],mi2[N];bool vis[N];int pri[N],li_pri[N],num;vector&lt;int&gt; factor[N];inline void shai()&#123; for(int i=2;i&lt;=n;++i)&#123; if(!vis[i])&#123; pri[++num]=i; li_pri[i]=i; factor[i].pb(i); &#125; else&#123; factor[i].pb(li_pri[i]); int tmp=i; tmp/=li_pri[i]; for(int j=0;j&lt;factor[tmp].size();++j)&#123; if(factor[i][factor[i].size()-1]!=factor[tmp][j]) factor[i].pb(factor[tmp][j]); &#125; &#125; for(int j=1;j&lt;=n&amp;&amp;pri[j]*i&lt;=n;++j)&#123; vis[pri[j]*i]=1; li_pri[pri[j]*i]=pri[j]; if(i%pri[j]==0) break; &#125; &#125;&#125;inline int get_hash1(int l,int r)&#123; return hash1[r]-hash1[l-1]*mi1[r-l+1];&#125; inline int get_hash2(int l,int r)&#123; return (hash2[r]-1ll*hash2[l-1]*mi2[r-l+1]%mod+mod)%mod;&#125;int main()&#123; n=read(); //scanf(&quot;%s&quot;,s+1); gets(s+1); mi1[0]=mi2[0]=1; for(int i=1;i&lt;=n;++i)&#123; hash1[i]=hash1[i-1]*base+s[i]; mi1[i]=mi1[i-1]*base; hash2[i]=(1ll*hash2[i-1]*base%mod+s[i])%mod; mi2[i]=1ll*mi2[i-1]*base%mod; &#125; shai(); qn=read(); while(qn--)&#123; l=read();r=read(); if(l==r)&#123; puts(&quot;1&quot;); continue; &#125; int tmp=r-l+1,ans=tmp; for(int i=0;i&lt;factor[tmp].size();++i)&#123; while(ans%factor[tmp][i]==0&amp;&amp;get_hash1(l,r-ans/factor[tmp][i])==get_hash1(l+ans/factor[tmp][i],r)&amp;&amp;get_hash2(l,r-ans/factor[tmp][i])==get_hash2(l+ans/factor[tmp][i],r))&#123; ans/=factor[tmp][i]; &#125; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj3691 DNA repair]]></title>
    <url>%2F2018%2F06%2F01%2Fpoj3691%20DNA%20repair%2F</url>
    <content type="text"><![CDATA[123456在ac自动机上dpf[i][j]表示匹配串到第i位，在ac自动机上跑到j位置的最小修改次数ac自动机上每个点要或上fail树上的每一个祖先可以在求fail指针之后求出多测注意情况数组和变量（变量变量变量）sz没清空然后re好久 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int n,cas,mapping[128];char s[N];struct node&#123; int ch[5],fail; bool num;&#125;t[N];int sz;inline void inser()&#123; int u=0,c,n=strlen(s+1); for(int i=1;i&lt;=n;++i)&#123; c=mapping[s[i]]; if(!t[u].ch[c]) t[u].ch[c]=++sz; u=t[u].ch[c]; &#125; t[u].num=1;&#125;int q[N];inline void get_ac()&#123; int he=1,ta=1; for(int i=1;i&lt;=4;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; &#125; while(he!=ta)&#123; int x=q[he]; ++he; t[x].num|=t[t[x].fail].num; for(int i=1;i&lt;=4;++i)&#123; if(!t[x].ch[i])&#123; t[x].ch[i]=t[t[x].fail].ch[i]; &#125; else&#123; t[t[x].ch[i]].fail=t[t[x].fail].ch[i]; q[ta]=t[x].ch[i]; ++ta; &#125; &#125; &#125;&#125;int f[N][N],ans;inline void solve()&#123; memset(f,0x3f,sizeof(f)); int n=strlen(s+1); f[0][0]=0; for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;=sz;++j)&#123; if(f[i][j]&lt;0x3f3f3f3f)&#123; int tmp=t[j].ch[mapping[s[i+1]]]; if(!t[tmp].num)&#123; f[i+1][tmp]=min(f[i+1][tmp],f[i][j]); &#125; for(int k=1;k&lt;=4;++k)&#123; if(!t[t[j].ch[k]].num) f[i+1][t[j].ch[k]]=min(f[i+1][t[j].ch[k]],f[i][j]+1); &#125; &#125; &#125; &#125; ans=0x3f3f3f3f; for(int i=0;i&lt;=sz;++i)&#123; ans=min(ans,f[n][i]); &#125; printf(&quot;Case %d: &quot;,++cas); if(ans==0x3f3f3f3f) puts(&quot;-1&quot;); else printf(&quot;%d\n&quot;,ans);&#125;int main()&#123; mapping[&apos;A&apos;]=1;mapping[&apos;G&apos;]=2;mapping[&apos;C&apos;]=3;mapping[&apos;T&apos;]=4; while((n=read()))&#123; memset(t,0,sizeof(t)); sz=0;//// for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s+1); inser(); &#125; scanf(&quot;%s&quot;,s+1); get_ac(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2336 [SCOI2012]喵星球上的点名]]></title>
    <url>%2F2018%2F05%2F31%2Fluogu2336%20%5BSCOI2012%5D%E5%96%B5%E6%98%9F%E7%90%83%E4%B8%8A%E7%9A%84%E7%82%B9%E5%90%8D%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617也是神题了字符串综合题各种做法ac自动机暴力过不了？假的zyz的暴力跑得飞快而且很难卡（我想了半天也构造不出来）一个有复杂度保证的做法Q1就是fail树中一个点的子树中有多少个不同的标记对于同一个名字将它在fail树中所有的点按dfn排序，在dfs序上打标记每个点自身+1，和前一个点的lca处-1，这样可以保证每个名字在一颗子树中只产生1的贡献Q2就是问一个点到根有多少点名串在in的地方+1，out+1的地方-1，这样可以保证每个名字只会考虑在它的根的路径上的点还是要减掉lca 有复杂度保证的做法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int len,x;vector&lt;int&gt; a[N];map&lt;int,int&gt; t[N];int sz,fail[N];int nume,head[N];struct edge&#123; int to,nxt;&#125;e[N];inline void addedge(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;int pos[N];inline void inser(int id)&#123; int u=0; len=read(); for(int i=1;i&lt;=len;++i)&#123; x=read(); if(!t[u][x])&#123; t[u][x]=++sz; &#125; u=t[u][x]; &#125; pos[id]=u;&#125;int q[N],he,ta;map&lt;int,int&gt;::iterator it;inline void getfail()&#123; he=1;ta=2; q[1]=0; while(he!=ta)&#123; int x=q[he]; ++he; for(it=t[x].begin();it!=t[x].end();++it)&#123; int t1=it-&gt;first,t2=it-&gt;second; if(x==0)&#123; fail[t2]=0; addedge(0,t2); &#125; else&#123; int k=fail[x]; while(k!=0&amp;&amp;t[k].find(t1)==t[k].end())&#123; k=fail[k]; &#125; int tmp=t[k][t1]; fail[t2]=tmp; addedge(tmp,t2); &#125; q[ta]=t2; ++ta; &#125; &#125;&#125;int in[N],out[N],dfc,fa[N][20],dep[N];inline void dfs(int x)&#123; in[x]=++dfc; for(int i=1;i&lt;=18;++i)&#123; if(dep[x]&gt;=(1&lt;&lt;i))&#123; fa[x][i]=fa[fa[x][i-1]][i-1]; &#125; &#125; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x][0])&#123; fa[e[i].to][0]=x; dep[e[i].to]=dep[x]+1; dfs(e[i].to); &#125; &#125; out[x]=dfc;&#125;inline int lca(int x,int y)&#123; if(x==y) return x; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=18;i&gt;=0;--i)&#123; if(dep[x]&gt;=dep[y]+(1&lt;&lt;i))&#123; x=fa[x][i]; &#125; &#125; if(x==y) return x; for(int i=18;i&gt;=0;--i)&#123; if(fa[x][i]!=fa[y][i])&#123; x=fa[x][i]; y=fa[y][i]; &#125; &#125; return fa[x][0];&#125;int bit1[N],bit2[N];inline void add(int *bit,int x,int pos)&#123; for(int i=pos;i&lt;=dfc;i+=i&amp;-i)&#123; bit[i]+=x; &#125;&#125;inline int query(int *bit,int pos)&#123; int tmp=0; for(int i=pos;i;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125; int b[N],vis[N],ans[N];inline bool cmp(const int &amp;a,const int &amp;b)&#123; return in[a]&lt;in[b];&#125;inline void solve(int id)&#123; int u=0,len=0; for(int i=0;i&lt;a[id].size();++i)&#123; while(u&amp;&amp;t[u].find(a[id][i])==t[u].end())&#123; u=fail[u]; &#125; if(t[u].find(a[id][i])!=t[u].end())&#123; u=t[u][a[id][i]]; &#125; if(vis[u]!=id) b[++len]=u; vis[u]=id; &#125; sort(b+1,b+len+1,cmp); ans[id]+=query(bit1,in[b[1]]); add(bit2,1,in[b[1]]); for(int i=2;i&lt;=len;++i)&#123; ans[id]+=query(bit1,in[b[i]]); ans[id]-=query(bit1,in[lca(b[i],b[i-1])]); add(bit2,1,in[b[i]]); add(bit2,-1,in[lca(b[i],b[i-1])]); &#125;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; len=read(); while(len--)&#123; x=read(); a[i].pb(x); &#125; a[i].pb(-1); len=read(); while(len--)&#123; x=read(); a[i].pb(x); &#125; &#125; for(int i=1;i&lt;=m;++i)&#123; inser(i); &#125; getfail(); dfs(0); for(int i=1;i&lt;=m;++i)&#123; add(bit1,1,in[pos[i]]); add(bit1,-1,out[pos[i]]+1); &#125; for(int i=1;i&lt;=n;++i)&#123; solve(i); &#125; for(int i=1;i&lt;=m;++i)&#123; printf(&quot;%d\n&quot;,query(bit2,out[pos[i]])-query(bit2,in[pos[i]]-1)); &#125; for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%d &quot;,ans[i]); &#125; return 0;&#125; 暴力。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int ans1[N],ans2[N];vector&lt;int&gt; a[N],V;int num[N],pos[N],q[N];map&lt;int,int&gt; to[N];bool vis[N];int sz;struct data&#123; int fail[N]; inline void insert(int id)&#123; int L=read(),x; int u=0; for(int i=1;i&lt;=L;i++) &#123; x=read(); if(!to[u][x])to[u][x]=++sz; u=to[u][x]; &#125; ++num[u]; pos[id]=u; &#125; inline void buildfail()&#123; int head=0,tail=0; for(map&lt;int,int&gt;::iterator i=to[0].begin();i!=to[0].end();++i)&#123; q[tail++]=i-&gt;second; &#125; while(head!=tail) &#123; int x=q[head];head++; for(map&lt;int,int&gt;::iterator i=to[x].begin();i!=to[x].end();++i) &#123; int t=i-&gt;first,k=fail[x]; while(k&amp;&amp;to[k].find(t)==to[k].end())&#123; k=fail[k]; &#125; if(to[k].find(t)!=to[k].end()) fail[i-&gt;second]=to[k][t]; q[tail++]=i-&gt;second; &#125; &#125; &#125; inline void get(int id,int x)&#123; for(int i=x;i;i=fail[i]) if(!vis[i]) &#123; vis[i]=1;V.push_back(i); ++ans1[i]; ans2[id]+=num[i]; &#125; else return; &#125; inline void solve(int x)&#123; int u=0; for(int i=0;i&lt;a[x].size();i++) &#123; int t=a[x][i]; while(u&amp;&amp;to[u].find(t)==to[u].end()) u=fail[u]; if(to[u].find(t)!=to[u].end()) u=to[u][t]; get(x,u); &#125; for(int i=0;i&lt;V.size();i++)vis[V[i]]=0; V.clear(); &#125;&#125;trie;int main()&#123; n=read();m=read(); int L,x; for(int i=1;i&lt;=n;i++) &#123; L=read(); while(L--)x=read(),a[i].push_back(x); a[i].push_back(-1); L=read(); while(L--)x=read(),a[i].push_back(x); &#125; for(int i=1;i&lt;=m;i++) trie.insert(i); trie.buildfail(); for(int i=1;i&lt;=n;i++) trie.solve(i); for(int i=1;i&lt;=m;i++)printf(&quot;%d\n&quot;,ans1[pos[i]]); for(int i=1;i&lt;=n;i++) &#123; printf(&quot;%d&quot;,ans2[i]); if(i!=n)printf(&quot; &quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>ac自动机</tag>
        <tag>fail树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noi模拟赛 狮鹫旅行]]></title>
    <url>%2F2018%2F05%2F30%2Fnoi%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E7%8B%AE%E9%B9%AB%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[GriffinDescription狮鹫是联盟的主要交通工具，在艾泽拉斯的土地上散布着n个狮鹫站点，有m条有向的飞行线路，也就是构成了一张n个点m条边的有向图。这m条线路被分成了c种等级，对于其中的第i种等级，只有声望达到了wi才能乘坐狮鹫飞过这条线路。小C现在在暴风城（1号点），他要赶到暗月马戏团（n号点）参加他学长的电音表演。作为一个喜欢藏锋的健美先生，初始时他声望为0。但他实在是太健美了，以至于他每乘坐一次狮鹫（即经过一条边）就能使他的声望 +1 。为了更好地藏锋，小C不会通过其他方法来提升声望。 小C不喜欢步行，也不会开传送门，所以他不会通过除乘坐狮鹫以外的其他方法来到达另一个站点。现在他想知道是否能到达，如果能，他还想知道他最少要经过多少条边才能到达。 Input从文件griffin.in中读入数据.第一行三个整数n, m, c.接下来m行，每行三个整数u, v, lv，表示有一条u到v的线路，等级为lv.接下来一行c个整数，第i个表示wi. Output输出到文件griffin.out中.若不能到达输出Impossible。否则输出一个整数表示他最少要经过的边数。 Sample1 Input3 2 21 2 12 3 20 2 OutputImpossibleSample2 Input3 3 21 2 12 1 12 3 20 2 Output4 12345678910111213%dy对矩阵和图的关系的理解又加深了这张图一开始所有边都是上锁的当你每达到一定等级就能解锁转移矩阵会逐渐扩大过程大概是：先走val[i]-val[i-1]步转移到当前可用的点(state)（一个一维向量）若state为空，说明无解否则就可以解锁了，扩展一下转移矩阵(omat)解锁当前等级后判断一下能不能到达n，用bfs用bitset优化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=188,M=40008,C=58;int n,m,cn;int val[C];struct data&#123; int u,v,w; inline bool operator &lt;(const data &amp;b) const&#123; return w&lt;b.w; &#125;&#125;arr[M];bitset&lt;N&gt; state[N],omat[N],mat[N],tmp[N];//state就是一个1维向量 int cur,ans;int q[N],dis[N];inline void update(bitset&lt;N&gt; *a,bitset&lt;N&gt; *b)&#123; for(int i=1;i&lt;=n;++i)&#123; tmp[i].reset(); &#125; for(int i=1;i&lt;=n;++i)&#123; for(int k=1;k&lt;=n;++k)&#123; if(a[i][k])&#123; tmp[i]|=b[k]; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]=tmp[i]; &#125;&#125; inline int bfs()&#123; int he=1,ta=1; memset(dis,0x3f,sizeof(dis)); for(int i=1;i&lt;=n;++i)&#123; if(state[1][i])&#123; q[ta]=i; ++ta; dis[i]=0; &#125; &#125; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=1;i&lt;=n;++i)&#123; if(omat[x][i]&amp;&amp;dis[i]&gt;dis[x]+1)&#123; dis[i]=dis[x]+1; q[ta]=i; ++ta; &#125; &#125; &#125; return dis[n];&#125;int main()&#123; n=read();m=read();cn=read(); for(int i=1;i&lt;=m;++i)&#123; arr[i].u=read(); arr[i].v=read(); arr[i].w=read(); &#125; sort(arr+1,arr+m+1); for(int i=1;i&lt;=cn;++i)&#123; val[i]=read(); &#125; state[1][1]=1; cur=1; ans=0x3f3f3f3f; for(int i=1;i&lt;=cn;++i)&#123; int x=val[i]-val[i-1]; for(int j=1;j&lt;=n;++j)&#123; mat[j]=omat[j]; &#125; while(x)&#123; if(x&amp;1) update(state,mat); update(mat,mat); x&gt;&gt;=1; &#125; for(int j=1;j&lt;=n;++j)&#123; if(state[j].any()) break; if(j==n)&#123; puts(&quot;Impossible&quot;); return 0; &#125; &#125; while(cur&lt;=m&amp;&amp;arr[cur].w&lt;=i)&#123; if(!omat[arr[cur].u][arr[cur].v])&#123; omat[arr[cur].u][arr[cur].v]=1; &#125; ++cur; &#125; int tmp=bfs(); ans=min(ans,tmp+val[i]); &#125; if(ans&lt;0x3f3f3f3f) printf(&quot;%d&quot;,ans); else puts(&quot;Impossible&quot;); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3233 [HNOI2014]世界树]]></title>
    <url>%2F2018%2F05%2F29%2Fluogu3233%20%5BHNOI2014%5D%E4%B8%96%E7%95%8C%E6%A0%91%2F</url>
    <content type="text"><![CDATA[123456789101112显然是虚树然而怎么dp。。看题解看题解。。先两遍dfs求出虚树上每个点到哪个点最近注意到虚树上的一条链所属的点一定和某一个端点是一样的（为什么我没有注意到）然后就是看两个端点是否是属于同一个点是的话说明整条链就是这个点的不是的话可以算出中间的分割点的深度倍增可以求节点a的深度为x的祖先倍增大概有3种写法，若用dep[fa[x][i]]&gt;=dep[y]，请将根节点的dep设为1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=300008;int num,n,m,qn;int x,y;int nume,head[N];struct edge&#123; int to,nxt;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;int dfn[N],dfc,sz[N],fa[N][20],dep[N];inline void dfs(int x)&#123; dfn[x]=++dfc; sz[x]=1; for(int i=1;(1&lt;&lt;i)&lt;=dep[x];++i)&#123; fa[x][i]=fa[fa[x][i-1]][i-1]; &#125; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x][0])&#123; fa[e[i].to][0]=x; dep[e[i].to]=dep[x]+1; dfs(e[i].to); sz[x]+=sz[e[i].to]; &#125; &#125;&#125;inline int lca(int x,int y)&#123; if(x==y) return x; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=19;i&gt;=0;--i)&#123; if(dep[x]&gt;=dep[y]+(1&lt;&lt;i))&#123;//dep[fa[x][i]]&gt;=dep[y] (1&lt;&lt;i)&amp;bin x=fa[x][i]; &#125; &#125; if(x==y) return x; for(int i=19;i&gt;=0;--i)&#123; if(fa[x][i]!=fa[y][i])&#123; x=fa[x][i]; y=fa[y][i]; &#125; &#125; return fa[x][0]; &#125;int a[N],t[N],ori[N];int s[N],ta;int par[N],dis[N];PII g[N];int rem[N];int ans[N];inline bool cmp(const int &amp;a,const int &amp;b)&#123; return dfn[a]&lt;dfn[b];&#125;inline void addedge_2(int x,int y)&#123; par[y]=x; dis[y]=dep[y]-dep[x];&#125;inline void dp()&#123; for(int i=n;i&gt;1;--i)&#123; int t1=t[i],t2=par[t1]; g[t2]=min(g[t2],mp(g[t1].first+dis[t1],g[t1].second)); &#125; for(int i=2;i&lt;=n;++i)&#123; int t1=t[i],t2=par[t1]; g[t1]=min(g[t1],mp(g[t2].first+dis[t1],g[t2].second)); &#125;&#125;inline int find(int x,int pos)&#123; for(int i=19;i&gt;=0;--i)&#123; if(dep[x]&gt;=pos+(1&lt;&lt;i))&#123; x=fa[x][i]; &#125; &#125; return x;&#125;inline void solve()&#123; m=read();n=0; for(int i=1;i&lt;=m;++i)&#123; t[++n]=ori[i]=a[i]=read(); g[a[i]]=mp(0,a[i]); &#125; sort(a+1,a+m+1,cmp); ta=0; for(int i=1;i&lt;=m;++i)&#123; if(!ta)&#123; s[++ta]=a[i]; &#125; else&#123; int tmp=lca(a[i],s[ta]); while(dfn[tmp]&lt;dfn[s[ta]])&#123; if(dfn[tmp]&gt;=dfn[s[ta-1]])&#123; addedge_2(tmp,s[ta]); --ta; if(s[ta]!=tmp)&#123; s[++ta]=tmp; t[++n]=tmp; g[tmp]=mp(0x3f3f3f3f,0); &#125; break; &#125; else&#123; addedge_2(s[ta-1],s[ta]); --ta; &#125; &#125; s[++ta]=a[i]; &#125; &#125; while(ta&gt;1)&#123; addedge_2(s[ta-1],s[ta]); --ta; &#125; sort(t+1,t+n+1,cmp); dp(); for(int i=1;i&lt;=n;++i)&#123; rem[t[i]]=sz[t[i]]; &#125; ans[g[t[1]].second]=num-sz[t[1]]; for(int i=2;i&lt;=n;++i)&#123; int t1=t[i],t2=par[t1];//par[t1]=0; int tmp=find(t1,dep[t2]-1); rem[t2]-=sz[tmp]; if(g[t1].second==g[t2].second)&#123; ans[g[t1].second]+=sz[tmp]-sz[t1]; &#125; else&#123; int len=g[t1].first+g[t2].first+dis[t1],mid=dep[t1]-(len/2-g[t1].first); if(!(len&amp;1)&amp;&amp;g[t1].second&gt;g[t2].second) ++mid; int tmp2=find(t1,mid); ans[g[t1].second]+=sz[tmp2]-sz[t1]; ans[g[t2].second]+=sz[tmp]-sz[tmp2]; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; ans[g[t[i]].second]+=rem[t[i]]; &#125; for(int i=1;i&lt;=m;++i)&#123; printf(&quot;%d &quot;,ans[ori[i]]); ans[ori[i]]=0; &#125; puts(&quot;&quot;);&#125;int main()&#123; num=n=read(); for(int i=1;i&lt;n;++i)&#123; x=read();y=read(); addedge(x,y); addedge(y,x); &#125; dfs(1); qn=read(); while(qn--)&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>虚树</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3320 [SDOI2015]寻宝游戏]]></title>
    <url>%2F2018%2F05%2F28%2Fluogu3320%20%5BSDOI2015%5D%E5%AF%BB%E5%AE%9D%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[123每加入一个点，其实就是在虚树上从前驱和后继向这个点连边虚树不需要建，用set求前驱后继细节！！ 1.有点麻烦，用dfn求lca要求fa,topfa,dep,dep2都以dfn为下标123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int x,y,z;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;bool has[N];int num;int dfn[N],dfc,sz[N],fa[N],dep[N],heavyson[N],topfa[N];LL dep2[N];inline void dfs(int x,int f,int p)&#123; dfn[x]=++dfc; dep[dfn[x]]=dep[p]+1; dep2[dfn[x]]=dep2[p]+f; fa[dfn[x]]=p; sz[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(!dfn[e[i].to])&#123; dfs(e[i].to,e[i].f,dfn[x]); sz[x]+=sz[e[i].to]; if(sz[e[i].to]&gt;sz[heavyson[x]])&#123; heavyson[x]=e[i].to; &#125; &#125; &#125;&#125;inline void dfs2(int x,int anc)&#123; topfa[dfn[x]]=dfn[anc]; if(heavyson[x]) dfs2(heavyson[x],anc); for(int i=head[x];i;i=e[i].nxt)&#123; if(dfn[e[i].to]!=fa[dfn[x]]&amp;&amp;e[i].to!=heavyson[x]) dfs2(e[i].to,e[i].to); &#125;&#125;inline int lca(int x,int y)&#123; while(topfa[x]!=topfa[y])&#123; dep[topfa[x]]&gt;dep[topfa[y]]?x=fa[topfa[x]]:y=fa[topfa[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;set&lt;int&gt; s;set&lt;int&gt;::iterator it;LL ans;int t1,t2,t3;inline LL dis(int x,int y)&#123; return dep2[x]+dep2[y]-2*dep2[lca(x,y)];&#125;inline void solve()&#123; if(has[x])&#123; s.insert(dfn[x]); it=s.lower_bound(dfn[x]); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans+=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); &#125; else&#123; it=s.lower_bound(dfn[x]); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans-=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); s.erase(dfn[x]); &#125; printf(&quot;%lld\n&quot;,ans);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;n;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); addedge(y,x,z); &#125; dfs(1,0,0); dfs2(1,1); while(m--)&#123; x=read(); if(has[x])&#123; has[x]=0; --num; &#125; else&#123; has[x]=1; ++num; &#125; if(num&lt;=1)&#123; if(has[x])&#123; s.insert(dfn[x]); &#125; else&#123; s.erase(dfn[x]); &#125; puts(&quot;0&quot;); &#125; else&#123; solve(); &#125; &#125; return 0;&#125; 2.记录每个dfn对应的节点，这样不需要改树剖了，但多开一个数组，会更慢。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int x,y,z;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;bool has[N];int num;int dfn[N],dfc,sz[N],fa[N],dep[N],heavyson[N],topfa[N],pos[N];LL dep2[N];inline void dfs(int x)&#123; dfn[x]=++dfc; pos[dfc]=x; sz[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(!dfn[e[i].to])&#123; fa[e[i].to]=x; dep[e[i].to]=dep[x]+1; dep2[e[i].to]=dep2[x]+e[i].f; dfs(e[i].to); sz[x]+=sz[e[i].to]; if(sz[e[i].to]&gt;sz[heavyson[x]])&#123; heavyson[x]=e[i].to; &#125; &#125; &#125;&#125;inline void dfs2(int x,int anc)&#123; topfa[x]=anc; if(heavyson[x]) dfs2(heavyson[x],anc); for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x]&amp;&amp;e[i].to!=heavyson[x]) dfs2(e[i].to,e[i].to); &#125;&#125;inline int lca(int x,int y)&#123; while(topfa[x]!=topfa[y])&#123; dep[topfa[x]]&gt;dep[topfa[y]]?x=fa[topfa[x]]:y=fa[topfa[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;set&lt;int&gt; s;set&lt;int&gt;::iterator it;LL ans;int t1,t2,t3;inline LL dis(int x,int y)&#123; x=pos[x];y=pos[y]; return dep2[x]+dep2[y]-2*dep2[lca(x,y)];&#125;inline void solve()&#123; if(has[x])&#123; s.insert(dfn[x]); it=s.lower_bound(dfn[x]); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans+=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); &#125; else&#123; it=s.lower_bound(dfn[x]); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans-=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); s.erase(dfn[x]); &#125; printf(&quot;%lld\n&quot;,ans);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;n;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); addedge(y,x,z); &#125; dfs(1); dfs2(1,1); while(m--)&#123; x=read(); if(has[x])&#123; has[x]=0; --num; &#125; else&#123; has[x]=1; ++num; &#125; if(num&lt;=1)&#123; if(has[x])&#123; s.insert(dfn[x]); &#125; else&#123; s.erase(dfn[x]); &#125; puts(&quot;0&quot;); &#125; else&#123; solve(); &#125; &#125; return 0;&#125; 3.set居然可以用struct作cmp，学习了，当然速度超慢123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int x,y,z;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;bool has[N];int num;int dfn[N],dfc,sz[N],fa[N],dep[N],heavyson[N],topfa[N];LL dep2[N];inline void dfs(int x)&#123; dfn[x]=++dfc; sz[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(!dfn[e[i].to])&#123; fa[e[i].to]=x; dep[e[i].to]=dep[x]+1; dep2[e[i].to]=dep2[x]+e[i].f; dfs(e[i].to); sz[x]+=sz[e[i].to]; if(sz[e[i].to]&gt;sz[heavyson[x]])&#123; heavyson[x]=e[i].to; &#125; &#125; &#125;&#125;inline void dfs2(int x,int anc)&#123; topfa[x]=anc; if(heavyson[x]) dfs2(heavyson[x],anc); for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x]&amp;&amp;e[i].to!=heavyson[x]) dfs2(e[i].to,e[i].to); &#125;&#125;inline int lca(int x,int y)&#123; while(topfa[x]!=topfa[y])&#123; dep[topfa[x]]&gt;dep[topfa[y]]?x=fa[topfa[x]]:y=fa[topfa[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;struct cmp&#123; bool operator()(const int &amp;x,const int &amp;y)&#123; return dfn[x]&lt;dfn[y]; &#125;&#125;;set&lt;int,cmp&gt; s;set&lt;int,cmp&gt;::iterator it;LL ans;int t1,t2,t3;inline LL dis(int x,int y)&#123; return dep2[x]+dep2[y]-2*dep2[lca(x,y)];&#125;inline void solve()&#123; if(has[x])&#123; s.insert(x); it=s.lower_bound(x); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans+=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); &#125; else&#123; it=s.lower_bound(x); t1=*it; if(it==s.begin())&#123; t2=*(--s.end()); &#125; else&#123; --it; t2=*it; ++it; &#125; if(it==--s.end())&#123; t3=*s.begin(); &#125; else&#123; ++it; t3=*it; --it; &#125; ans-=dis(t1,t2)+dis(t1,t3)-dis(t2,t3); s.erase(x); &#125; printf(&quot;%lld\n&quot;,ans);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;n;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); addedge(y,x,z); &#125; dfs(1); dfs2(1,1); while(m--)&#123; x=read(); if(has[x])&#123; has[x]=0; --num; &#125; else&#123; has[x]=1; ++num; &#125; if(num&lt;=1)&#123; if(has[x])&#123; s.insert(x); &#125; else&#123; s.erase(x); &#125; puts(&quot;0&quot;); &#125; else&#123; solve(); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu1599 find the mincost route]]></title>
    <url>%2F2018%2F05%2F27%2Fhdu1599%20find%20the%20mincost%20route%2F</url>
    <content type="text"><![CDATA[12345无向图找最小环floyd O(n^3)枚举三点的环，但要确保有一点不在其他两个点的最短路上，所以一边floyd一边枚举注意0x3f3f3f3f*3会爆int 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108;int n,m;int x,y,z;int w[N][N],dis[N][N],ans;int main()&#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)&#123; memset(dis,0x3f,sizeof(dis)); memset(w,0x3f,sizeof(w)); ans=0x3f3f3f3f; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read();z=read(); if(w[x][y]&gt;z) w[x][y]=w[y][x]=dis[x][y]=dis[y][x]=z; &#125; for(int k=1;k&lt;=n;++k)&#123; for(int i=1;i&lt;k;++i)&#123; for(int j=i+1;j&lt;k;++j)&#123; ans=min((LL)ans,0ll+dis[i][j]+w[i][k]+w[j][k]); &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; if(dis[i][k]&lt;0x3f3f3f3f)&#123; for(int j=1;j&lt;=n;++j)&#123; if(dis[i][k]+dis[k][j]&lt;dis[i][j])&#123; dis[i][j]=dis[i][k]+dis[k][j]; &#125; &#125; &#125; &#125; &#125; if(ans==0x3f3f3f3f) puts(&quot;It&apos;s impossible.&quot;); else printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】虚树 luogu2495 [SDOI2011]消耗战]]></title>
    <url>%2F2018%2F05%2F25%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%99%9A%E6%A0%91%20luogu2495%20%5BSDOI2011%5D%E6%B6%88%E8%80%97%E6%88%98%2F</url>
    <content type="text"><![CDATA[123456789在树形dp的基础上保留关键点每个点记录的信息要是从这个点到根的构造的方法1.将关键点排序，相邻的两点求lca，这样所有的点对lca都包含在其中（反证法证明）。在将它们放一起排序，去重，用栈连边。复杂度O(nlogn)（常数大）2.栈中时刻维护一条链，每加入一个点要维护到这个新的点的链，过程中连边。复杂度O(nlogn)（常数小，难理解）方法1注意：包括lca的那个数组要开两倍大（或者记录一下哪些数已经出现了），vector要清空 方法1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=250008;int n;int u,v,w;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int sz[N],fa[N],dep[N],heavyson[N],topfa[N];LL mini[N];int dfn[N],dfc;inline void dfs(int x)&#123; dfn[x]=++dfc; ++sz[x]; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x])&#123; fa[e[i].to]=x; dep[e[i].to]=dep[x]+1; mini[e[i].to]=min(mini[x],(LL)e[i].f); dfs(e[i].to); sz[x]+=sz[e[i].to]; if(sz[e[i].to]&gt;sz[heavyson[x]])&#123; heavyson[x]=e[i].to; &#125; &#125; &#125;&#125;inline void dfs2(int x,int anc)&#123; topfa[x]=anc; if(heavyson[x]) dfs2(heavyson[x],anc); for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x]&amp;&amp;e[i].to!=heavyson[x]) dfs2(e[i].to,e[i].to); &#125;&#125;inline int lca(int x,int y)&#123; while(topfa[x]!=topfa[y])&#123; dep[topfa[x]]&gt;dep[topfa[y]]?x=fa[topfa[x]]:y=fa[topfa[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;inline void build()&#123; mini[1]=LONG_LONG_MAX; dfs(1); dfs2(1,1);&#125;int qn;int s[N],ta;bool key[N];vector&lt;int&gt; vis;inline bool cmp(const int &amp;a,const int &amp;b)&#123; return dfn[a]&lt;dfn[b];&#125;inline void addedge_2(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;LL f[N];inline LL dp(int x)&#123; LL tmp=0; for(int i=head[x];i;i=e[i].nxt)&#123; tmp+=dp(e[i].to); &#125; if(key[x]) f[x]=mini[x]; else f[x]=min(mini[x],tmp); head[x]=0; return f[x];&#125;int a[N&lt;&lt;1];//// inline void solve()&#123; nume=0; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); key[a[i]]=1; vis.pb(a[i]); &#125; sort(a+1,a+n+1,cmp); for(int i=n;i&gt;1;--i)&#123; a[++n]=lca(a[i],a[i-1]); &#125; sort(a+1,a+n+1,cmp); n=unique(a+1,a+n+1)-a-1; ta=0; for(int i=1;i&lt;=n;++i)&#123; if(ta==0)&#123; s[++ta]=a[i]; &#125; else&#123; while(dfn[s[ta]]+sz[s[ta]]&lt;=dfn[a[i]])&#123; --ta; &#125; addedge_2(s[ta],a[i]); s[++ta]=a[i]; &#125; &#125; dp(a[1]); for(int i=0;i&lt;vis.size();++i)&#123; key[vis[i]]=0; &#125; vis.clear();//////////// printf(&quot;%lld\n&quot;,f[a[1]]);&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i)&#123; u=read();v=read();w=read(); addedge(u,v,w); addedge(v,u,w); &#125; build(); qn=read(); memset(head,0,sizeof(head)); while(qn--)&#123; solve(); &#125; return 0;&#125; 方法2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=250008;int n;int u,v,w;int nume,head[N];struct edge&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(edge)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int sz[N],fa[N],dep[N],heavyson[N],topfa[N];LL mini[N];int dfn[N],dfc;inline void dfs(int x)&#123; dfn[x]=++dfc; ++sz[x]; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x])&#123; fa[e[i].to]=x; dep[e[i].to]=dep[x]+1; mini[e[i].to]=min(mini[x],(LL)e[i].f); dfs(e[i].to); sz[x]+=sz[e[i].to]; if(sz[e[i].to]&gt;sz[heavyson[x]])&#123; heavyson[x]=e[i].to; &#125; &#125; &#125;&#125;inline void dfs2(int x,int anc)&#123; topfa[x]=anc; if(heavyson[x]) dfs2(heavyson[x],anc); for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa[x]&amp;&amp;e[i].to!=heavyson[x]) dfs2(e[i].to,e[i].to); &#125;&#125;inline int lca(int x,int y)&#123; while(topfa[x]!=topfa[y])&#123; dep[topfa[x]]&gt;dep[topfa[y]]?x=fa[topfa[x]]:y=fa[topfa[y]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;inline void build()&#123; mini[1]=LONG_LONG_MAX; dfs(1); dfs2(1,1);&#125;int qn;int s[N],ta;bool key[N];inline bool cmp(const int &amp;a,const int &amp;b)&#123; return dfn[a]&lt;dfn[b];&#125;inline void addedge_2(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;LL f[N];inline LL dp(int x)&#123; LL tmp=0; for(int i=head[x];i;i=e[i].nxt)&#123; tmp+=dp(e[i].to); &#125; if(key[x]) f[x]=mini[x]; else f[x]=min(mini[x],tmp); head[x]=0; return f[x];&#125;int a[N&lt;&lt;1];//// inline void solve()&#123; nume=0; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); key[a[i]]=1; &#125; sort(a+1,a+n+1,cmp); ta=0; for(int i=1;i&lt;=n;++i)&#123; if(ta==0)&#123; s[++ta]=a[i]; &#125; else&#123; int tmp=lca(s[ta],a[i]); while(dfn[tmp]&lt;dfn[s[ta]])&#123; if(dfn[tmp]&gt;=dfn[s[ta-1]])&#123; addedge_2(tmp,s[ta]); --ta; if(s[ta]!=tmp) s[++ta]=tmp; break; &#125; else&#123; addedge_2(s[ta-1],s[ta]); --ta; &#125; &#125; s[++ta]=a[i]; &#125; &#125; while(ta!=1)&#123; addedge_2(s[ta-1],s[ta]); --ta; &#125; dp(s[1]); for(int i=1;i&lt;=n;++i)&#123; key[a[i]]=0; &#125; printf(&quot;%lld\n&quot;,f[s[1]]);&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;++i)&#123; u=read();v=read();w=read(); addedge(u,v,w); addedge(v,u,w); &#125; build(); qn=read(); memset(head,0,sizeof(head)); while(qn--)&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树上dp</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguP2414 [NOI2011]阿狸的打字机]]></title>
    <url>%2F2018%2F05%2F23%2FluoguP2414%20%5BNOI2011%5D%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[先做完bzoj3172 [Tjoi2013]单词再看这题觉得思路清爽多了 答案是x在fail树上的子树和但是只能保留第y个串的字符按照字符顺序处理正好能求出当前串的字符所以想到离线处理询问按y排序将fail树转成dfs序在dfs序上做单点修改，区间求和 第二次做fail树是一个很重要的东西fa是自己的最长后缀每个点是一个前缀在fail树上某个点的孩子/孙子/曾孙表明自己在它孩子/孙子/曾孙中作为这个前缀的后缀出现错了一次是因为dfn和sz搞错trie的sz是不包括0的fail树的dfn是包括0的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;char s[N];int n;struct node&#123; int ch[26],fail,fa;&#125;t[N];int sz,num,pos[N];int m;struct node_q&#123; int x,y,id;&#125;que[N];inline bool cmp(const node_q &amp;a,const node_q &amp;b)&#123; return a.y&lt;b.y;&#125;int ans[N];inline void build()&#123; int u=0,c; for(int i=1;i&lt;=n;++i)&#123; if(s[i]=='P')&#123; pos[++num]=u; &#125; else if(s[i]=='B')&#123; u=t[u].fa; &#125; else&#123; c=s[i]-'a'; if(!t[u].ch[c]) t[u].ch[c]=++sz; t[t[u].ch[c]].fa=u; u=t[u].ch[c]; &#125; &#125;&#125;int q[N],he,ta;int nume,head[N];struct edge&#123; int to,nxt;&#125;e[N];inline void addedge(int x,int y)&#123; e[++nume]=(edge)&#123;y,head[x]&#125;;head[x]=nume;&#125;inline void getAC()&#123; he=1;ta=1; for(int i=0;i&lt;26;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; addedge(0,t[0].ch[i]); &#125; &#125; int u,v; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;26;++i)&#123; v=t[u].ch[i]; if(!v)&#123; t[u].ch[i]=t[t[u].fail].ch[i]; continue; &#125; t[v].fail=t[t[u].fail].ch[i]; q[ta]=v; ++ta; addedge(t[v].fail,v); &#125; &#125;&#125;int din[N],dout[N],dfn;inline void dfs(int x)&#123; din[x]=++dfn; for(int i=head[x];i;i=e[i].nxt)&#123; dfs(e[i].to); &#125; dout[x]=dfn;&#125;int bit[N];inline void add(int pos,int x)&#123; for(int i=pos;i&lt;=dfn;i+=i&amp;-i)&#123; bit[i]+=x; &#125;&#125;inline int sum(int pos)&#123; int tmp=0; for(int i=pos;i;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125;inline void solve()&#123; int u=0,qn=0,p=1,c,l,r; for(int i=1;i&lt;=n;++i)&#123; if(s[i]=='P')&#123; ++qn; while(qn==que[p].y)&#123; l=din[pos[que[p].x]]; r=dout[pos[que[p].x]]; ans[que[p].id]=sum(r)-sum(l-1); ++p; &#125; &#125; else if(s[i]=='B')&#123; add(din[u],-1); u=t[u].fa; &#125; else&#123; c=s[i]-'a'; u=t[u].ch[c]; add(din[u],1); &#125; &#125;&#125;int main()&#123; scanf("%s",s+1); n=strlen(s+1); build(); getAC(); dfs(0); m=read(); for(int i=1;i&lt;=m;++i)&#123; que[i].x=read();que[i].y=read();que[i].id=i; &#125; sort(que+1,que+m+1,cmp); solve(); for(int i=1;i&lt;=m;++i)&#123; printf("%d\n",ans[i]); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;char s[N];struct trie&#123; int ch[26],f,fa;&#125;ac[N];int sz;int pos[N],num;inline void build()&#123; int u=0,c; for(int i=1;i&lt;=n;++i)&#123; if(s[i]=='B')&#123; u=ac[u].fa; &#125; else if(s[i]=='P')&#123; pos[++num]=u; &#125; else&#123; c=s[i]-'a'; if(!ac[u].ch[c]) ac[u].ch[c]=++sz; ac[ac[u].ch[c]].fa=u; u=ac[u].ch[c]; &#125; &#125; &#125;int q[N],he,ta;vector&lt;int&gt; e[N];inline void get_acam()&#123; he=ta=1; for(int i=0;i&lt;26;++i)&#123; if(ac[0].ch[i])&#123; q[ta]=ac[0].ch[i]; ++ta; e[0].pb(ac[0].ch[i]); &#125; &#125; while(he!=ta)&#123; int u=q[he];++he; for(int i=0;i&lt;26;++i)&#123; int v=ac[u].ch[i]; if(v)&#123; ac[v].f=ac[ac[u].f].ch[i]; q[ta]=v; ++ta; e[ac[v].f].pb(v); &#125; else&#123; ac[u].ch[i]=ac[ac[u].f].ch[i]; &#125; &#125; &#125;&#125;int in[N],out[N],dfn;inline void dfs(int x)&#123; in[x]=++dfn; for(int i=0;i&lt;e[x].size();++i)&#123; dfs(e[x][i]); &#125; out[x]=dfn;&#125;int qn;struct que&#123; int x,y,id;&#125;qx[N];inline bool cmp(const que &amp;a,const que &amp;b)&#123; return a.y&lt;b.y;&#125;int bit[N];inline void add(int pos,int x)&#123; if(!pos) return; for(int i=pos;i&lt;=dfn;i+=i&amp;-i)&#123;//dfn=sz+1，sz没有算0！！ bit[i]+=x; &#125;&#125;inline int sum(int pos)&#123; int tmp=0; for(int i=pos;i&gt;0;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125;int ans[N];inline void solve()&#123; int u=0,c,cnt=0,t=1,l,r; for(int i=1;i&lt;=n;++i)&#123; if(s[i]=='B')&#123; add(in[u],-1); u=ac[u].fa; &#125; else if(s[i]=='P')&#123; ++cnt; while(cnt==qx[t].y)&#123; l=in[pos[qx[t].x]]; r=out[pos[qx[t].x]]; ans[qx[t].id]=sum(r)-sum(l-1); ++t; &#125; &#125; else&#123; c=s[i]-'a'; u=ac[u].ch[c]; add(in[u],1); &#125; &#125;&#125;int main()&#123; scanf("%s",s+1); n=strlen(s+1); build(); get_acam(); dfs(0); qn=read(); for(int i=1;i&lt;=qn;++i)&#123; qx[i].x=read(); qx[i].y=read(); qx[i].id=i; &#125; sort(qx+1,qx+qn+1,cmp); solve(); for(int i=1;i&lt;=qn;++i)&#123; printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3172 [Tjoi2013]单词]]></title>
    <url>%2F2018%2F05%2F23%2Fbzoj3172%20%5BTjoi2013%5D%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[12345fail指针表示最长后缀每个单词的每个位置对它的所有后缀都有贡献也就是每个单词的答案为fail树中这个点的子树和注意一个单词的每个位置都有1的初值可以不用把fail树单独建出来，处理bfs序就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1000008;int n;char s[N];struct node&#123; int ch[26],fail,num;&#125;t[N];int sz;int pos[208];inline void inser(int &amp;x)&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-&apos;a&apos;; if(!t[u].ch[c]) t[u].ch[c]=++sz; u=t[u].ch[c]; ++t[u].num; &#125; x=u;&#125;int q[N],he,ta;inline void getAC()&#123; he=1;ta=1; for(int i=0;i&lt;26;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; &#125; int u,v; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;26;++i)&#123; v=t[u].ch[i]; if(!v)&#123; t[u].ch[i]=t[t[u].fail].ch[i]; continue; &#125; t[v].fail=t[t[u].fail].ch[i]; q[ta]=v; ++ta; &#125; &#125; for(int i=ta-1;i;--i)&#123; t[t[q[i]].fail].num+=t[q[i]].num; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s+1); inser(pos[i]); &#125; getAC(); for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%d\n&quot;,t[pos[i]].num); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ac自动机</tag>
        <tag>fail树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2444 [POI2000]病毒]]></title>
    <url>%2F2018%2F05%2F22%2Fluogu2444%20%5BPOI2000%5D%E7%97%85%E6%AF%92%2F</url>
    <content type="text"><![CDATA[12trie图上面跑环先因为trie树多加continue跪了，然后发现没有把fail指向危险节点的点标为危险的（后缀中有危险的，说明自身也是危险的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=30008;int n;char s[N];struct node&#123; int ch[2],fail; bool num;&#125;t[N];int sz;inline void inser()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-&apos;0&apos;; if(!t[u].ch[c])&#123; t[u].ch[c]=++sz; &#125; u=t[u].ch[c]; &#125; t[u].num=1;&#125;int q[N],he,ta;inline void getAC()&#123; he=1;ta=1; for(int i=0;i&lt;2;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; &#125; int u,v; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;2;++i)&#123; v=t[u].ch[i]; if(!v)&#123; t[u].ch[i]=t[t[u].fail].ch[i]; continue; &#125; t[v].fail=t[t[u].fail].ch[i]; t[v].num|=t[t[t[u].fail].ch[i]].num; q[ta]=v; ++ta; &#125; &#125;&#125;bool ins[N],vis[N];inline bool dfs(int x)&#123; ins[x]=1; vis[x]=1; for(int i=0;i&lt;2;++i)&#123; if(ins[t[x].ch[i]]) return 1; if(!t[t[x].ch[i]].num&amp;&amp;!vis[t[x].ch[i]])&#123; if(dfs(t[x].ch[i])) return 1; &#125; &#125; ins[x]=0; return 0;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s+1); inser(); &#125; getAC(); if(dfs(0))&#123; puts(&quot;TAK&quot;); &#125; else&#123; puts(&quot;NIE&quot;); &#125; return 0;&#125; 错误代码：将没有的设为-1反例：1012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=30008;int n;char s[N];struct node&#123; int ch[2],fail; bool num;&#125;t[N];int sz;inline void inser()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-&apos;0&apos;; if(!t[u].ch[c])&#123; t[u].ch[c]=++sz; &#125; u=t[u].ch[c]; &#125; t[u].num=1;&#125;int q[N],he,ta;inline void getAC()&#123; he=1;ta=1; for(int i=0;i&lt;2;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; else&#123; t[0].ch[i]=-1; &#125; &#125; int u,v,x; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;2;++i)&#123; v=t[u].ch[i]; if(!v)&#123; t[u].ch[i]=t[t[u].fail].ch[i]; continue; &#125; t[v].fail=t[t[u].fail].ch[i]; t[v].num|=t[t[t[u].fail].ch[i]].num; q[ta]=v; ++ta; &#125; &#125;&#125;bool ins[N],vis[N];inline bool dfs(int x)&#123; ins[x]=1; vis[x]=1; for(int i=0;i&lt;2;++i)&#123; if(t[x].ch[i]==-1) continue; if(ins[t[x].ch[i]]) return 1; if(!t[t[x].ch[i]].num&amp;&amp;!vis[t[x].ch[i]])&#123; if(dfs(t[x].ch[i])) return 1; &#125; &#125; ins[x]=0; return 0;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s+1); inser(); &#125; getAC(); if(dfs(0))&#123; puts(&quot;TAK&quot;); &#125; else&#123; puts(&quot;NIE&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3808 【模板】AC自动机（简单版）]]></title>
    <url>%2F2018%2F05%2F21%2Fluogu3808%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[12ac自动机或者trie图字符集过大不能用trie图，需要map的ac自动机 ac自动机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1000008;int n;char s[N];struct node&#123; int ch[26],fail,num;&#125;t[N];int sz;inline void ins()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-'a'; if(!t[u].ch[c]) t[u].ch[c]=++sz; u=t[u].ch[c]; &#125; ++t[u].num;&#125;int q[N],he,ta;inline void getAC()&#123; he=1;ta=1; int u,v,x; for(int i=0;i&lt;26;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; &#125; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;26;++i)&#123; v=t[u].ch[i]; if(v)&#123; x=t[u].fail; while(x!=0&amp;&amp;!t[x].ch[i]) x=t[x].fail; if(t[x].ch[i]) x=t[x].ch[i]; t[v].fail=x; q[ta]=v; ++ta; &#125; &#125; &#125;&#125;int ans;bool vis[N];inline void AC()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-'a'; while(u!=0&amp;&amp;!t[u].ch[c]) u=t[u].fail; if(t[u].ch[c])&#123; u=t[u].ch[c]; for(int v=u;v!=0&amp;&amp;!vis[v];v=t[v].fail)&#123; ans+=t[v].num; vis[v]=1; &#125; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; scanf("%s",s+1); ins(); &#125; getAC(); scanf("%s",s+1); AC(); printf("%d",ans); return 0;&#125; trie图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1000008;int n;char s[N];struct node&#123; int ch[26],fail,num;&#125;t[N];int sz;inline void ins()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-&apos;a&apos;; if(!t[u].ch[c]) t[u].ch[c]=++sz; u=t[u].ch[c]; &#125; ++t[u].num;&#125;int q[N],he,ta;inline void getAC()&#123; he=1;ta=1; int u,v,x; for(int i=0;i&lt;26;++i)&#123; if(t[0].ch[i])&#123; q[ta]=t[0].ch[i]; ++ta; &#125; &#125; while(he!=ta)&#123; u=q[he]; ++he; for(int i=0;i&lt;26;++i)&#123; v=t[u].ch[i]; if(!v)&#123; t[u].ch[i]=t[t[u].fail].ch[i]; continue; &#125; t[v].fail=t[t[u].fail].ch[i]; q[ta]=v; ++ta; &#125; &#125;&#125;int ans;bool vis[N];inline void AC()&#123; int u=0,n=strlen(s+1),c; for(int i=1;i&lt;=n;++i)&#123; c=s[i]-&apos;a&apos;; u=t[u].ch[c]; for(int v=u;v!=0&amp;&amp;!vis[v];v=t[v].fail)&#123; ans+=t[v].num; vis[v]=1; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s+1); ins(); &#125; getAC(); scanf(&quot;%s&quot;,s+1); AC(); printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客 贝壳找房户外拓展（中等）]]></title>
    <url>%2F2018%2F05%2F21%2F%E8%AE%A1%E8%92%9C%E5%AE%A2%20%E8%B4%9D%E5%A3%B3%E6%89%BE%E6%88%BF%E6%88%B7%E5%A4%96%E6%8B%93%E5%B1%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[12345678910111213主力强啊考试时写分块没时间调试了x轴扫描线+区间维护一次函数线段树啊写啥分块。。困难版要k-d tree，不会重点在区间可以维护一次函数顺序不需要管因为合并就是从左到右的（我傻了）一位网友跟我讲可以按y扫描线但我不太会（询问可能重叠但是插入不会） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008,mod=323232323;int n,m,qn;char ch;int an,tmp;struct node&#123; int l,r,y,p,q;&#125;a[N];inline bool cmpa(const node &amp;a,const node &amp;b)&#123; if(a.l!=b.l) return a.l&lt;b.l; return a.r&lt;b.r;&#125;bool vis[N];int bn;struct nodeq&#123; int x,l,r,id;&#125;b[N];inline bool cmpb(const nodeq &amp;a,const nodeq &amp;b)&#123; return a.x&lt;b.x;&#125;int ans[N],cnt;priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;struct node_tree&#123; int p,q;&#125;tree[N&lt;&lt;2];inline void pushup(int t)&#123; int lson=t&lt;&lt;1,rson=t&lt;&lt;1|1; tree[t].p=1ll*tree[lson].p*tree[rson].p%mod; tree[t].q=(1ll*tree[lson].q*tree[rson].p+tree[rson].q)%mod;&#125; inline void update(int t,int l,int r,int dest,int p,int q)&#123; if(l==dest&amp;&amp;r==dest)&#123; tree[t].p=p; tree[t].q=q; return; &#125; int mid=(l+r)&gt;&gt;1; if(dest&lt;=mid) update(t&lt;&lt;1,l,mid,dest,p,q); else update(t&lt;&lt;1|1,mid+1,r,dest,p,q); pushup(t); return;&#125;inline void query(int t,int l,int r,int ll,int rr)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; cnt=(1ll*cnt*tree[t].p+tree[t].q)%mod; return; &#125; int mid=(l+r)&gt;&gt;1; if(ll&lt;=mid) query(t&lt;&lt;1,l,mid,ll,rr); if(mid&lt;rr) query(t&lt;&lt;1|1,mid+1,r,ll,rr); return;&#125;int main()&#123; n=read();m=read();qn=read(); for(int i=1;i&lt;=m*4;++i)&#123; tree[i].p=1; &#125; while(qn--)&#123; ch=getchar(); while(ch&lt;&apos;A&apos;||ch&gt;&apos;Z&apos;) ch=getchar(); if(ch==&apos;I&apos;)&#123; ++an; a[an].l=read(); a[an].r=read(); a[an].y=read(); a[an].p=read(); a[an].q=read(); vis[an]=1; &#125; if(ch==&apos;D&apos;)&#123; tmp=read(); vis[tmp]=0; &#125; if(ch==&apos;Q&apos;)&#123; ++bn; b[bn].x=read(); b[bn].l=read(); b[bn].r=read(); b[bn].id=bn; &#125; &#125; tmp=an;an=0; for(int i=1;i&lt;=tmp;++i)&#123; if(vis[i])&#123; a[++an]=a[i]; &#125; &#125; sort(a+1,a+an+1,cmpa); sort(b+1,b+bn+1,cmpb); tmp=1; for(int i=1;i&lt;=bn;++i)&#123; while(a[tmp].l&lt;=b[i].x&amp;&amp;tmp&lt;=an)&#123; q.push(mp(a[tmp].r,tmp)); update(1,1,m,a[tmp].y,a[tmp].p,a[tmp].q); ++tmp; &#125; while(!q.empty()&amp;&amp;q.top().first&lt;b[i].x)&#123; update(1,1,m,a[q.top().second].y,1,0); q.pop(); &#125; cnt=0; query(1,1,m,b[i].l,b[i].r); ans[b[i].id]=cnt; &#125; for(int i=1;i&lt;=bn;++i)&#123; printf(&quot;%d\n&quot;,ans[i]); &#125; return 0;&#125; 分块终于过了千万不要将0也搞到块里面（很麻烦请这样写be[i]=(i-1)/blk+1;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008,mod=323232323,BLK=330;int n,m,qn,blk;int be[N];char ch;int an,tmp;struct node&#123; int l,r,y,p,q;&#125;a[N];inline bool cmpa(const node &amp;a,const node &amp;b)&#123; if(a.l!=b.l) return a.l&lt;b.l; return a.r&lt;b.r;&#125;bool vis[N];int bn;struct nodeq&#123; int x,l,r,id;&#125;b[N];inline bool cmpb(const nodeq &amp;a,const nodeq &amp;b)&#123; return a.x&lt;b.x;&#125;int ans[N];LL cnt;priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;struct node_blk&#123; LL p,q;&#125;c[N],block[BLK];inline void update(int dest,int p,int q)&#123; c[dest].p=p;c[dest].q=q; int l=(be[dest]-1)*blk+1,r=min(m,be[dest]*blk); p=1;q=0; for(int i=l;i&lt;=r;++i)&#123; p=1ll*p*c[i].p%mod; q=(1ll*q*c[i].p+c[i].q)%mod; &#125; block[be[dest]].p=p; block[be[dest]].q=q;&#125;inline void query(int l,int r)&#123; cnt=0; if(be[l]==be[r])&#123; for(int i=l;i&lt;=r;++i)&#123; cnt=(1ll*cnt*c[i].p+c[i].q)%mod; &#125; &#125; else&#123; for(int i=l;i&lt;=be[l]*blk;++i)&#123; cnt=(1ll*cnt*c[i].p+c[i].q)%mod; &#125; for(int i=be[l]+1;i&lt;be[r];++i)&#123; cnt=(1ll*cnt*block[i].p+block[i].q)%mod; &#125; for(int i=(be[r]-1)*blk+1;i&lt;=r;++i)&#123; cnt=(1ll*cnt*c[i].p+c[i].q)%mod; &#125; &#125;&#125;int main()&#123; n=read();m=read();qn=read(); blk=sqrt(m); for(int i=1;i&lt;=m;++i)&#123; be[i]=(i-1)/blk+1; c[i].p=1; &#125; for(int i=1;i&lt;=m/blk+1;++i)&#123;//m/blk+1才是块数 block[i].p=1; &#125; while(qn--)&#123; ch=getchar(); while(ch&lt;&apos;A&apos;||ch&gt;&apos;Z&apos;) ch=getchar(); if(ch==&apos;I&apos;)&#123; ++an; a[an].l=read(); a[an].r=read(); a[an].y=read(); a[an].p=read(); a[an].q=read(); vis[an]=1; &#125; if(ch==&apos;D&apos;)&#123; tmp=read(); vis[tmp]=0; &#125; if(ch==&apos;Q&apos;)&#123; ++bn; b[bn].x=read(); b[bn].l=read(); b[bn].r=read(); b[bn].id=bn; &#125; &#125; tmp=an;an=0; for(int i=1;i&lt;=tmp;++i)&#123; if(vis[i])&#123; a[++an]=a[i]; &#125; &#125; sort(a+1,a+an+1,cmpa); sort(b+1,b+bn+1,cmpb); tmp=1; for(int i=1;i&lt;=bn;++i)&#123; while(a[tmp].l&lt;=b[i].x&amp;&amp;tmp&lt;=an)&#123; q.push(mp(a[tmp].r,tmp)); update(a[tmp].y,a[tmp].p,a[tmp].q); ++tmp; &#125; while(!q.empty()&amp;&amp;q.top().first&lt;b[i].x)&#123; update(a[q.top().second].y,1,0); q.pop(); &#125; query(b[i].l,b[i].r); ans[b[i].id]=cnt; &#125; for(int i=1;i&lt;=bn;++i)&#123; printf(&quot;%d\n&quot;,ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F05%2F20%2F%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[title:题目网络流 luogu4249 [WC2007]剪刀石头布S - (1,0) - 边 - (1,0) - 点 - (1,0)/(1,1)/…/(1,n-1) - T跑10000的费用流，数据较水能过 luogu3973 [TJOI2015]线性代数每个数取0/1，建图如图 bzoj3894 文理分科图 bzoj3232 圈地游戏1.二分+spfa判负环2.二分+[线性代数]建图，要解方程 bzoj2229 [Zjoi2011]最小割gomory hu tree O(n*flow) 最小割树建树有两种1.任选s,t跑最小割，然后分治（递归）2.1下面连2到n，从2到n，s=fa[x],t=x跑网络流，每次将和x相连的点的fa指向x 【BZOJ2085】[Poi2010]Hamsters hash+倍增floyd bzoj2795 [Poi2012]A Horrible Poem判断一个字符串的循环节：枚举len（len整除|s|)然后判断前|s|-len和后|s|-len个的hash值是否相同对每个询问，不断除以长度的质因数并判断总复杂度是O(n+qlogn)先线性筛求出每个数的最小质因数，然后可以在O(总因数个数)内求出1到n的因数个数 [BZOJ 4416][Shoi2013]阶乘字符串序列自动机就是dp（next）。。记录next[i][26]，O(26n)的预处理，从n到1，每次a[26]记录最后出现的位置，然后复制给next就可以了（next是dag）状压加手算优化（大于21就无解我也不会证） hihocoder1412 : Rikka with Subsequence不考虑删除，建出next，问题等价于dag中以起点开始的不同路径的个数，dp即可考虑删除方程变成：$c[ch]=\sum{j&lt;i}$$(f[j]*\prod{(j&lt;k&lt;i\bigcup a[k]=ch)}a_k)$ c[ch]表示到i位置前面的f对第i位字符为ch的贡献$f[i]=c[s[i]]*(1-ai)$ f[i]表示第i位对答案的贡献（大概是这样请手推） [NOI2015]品酒大会codeforces 452E 和品酒大会差不多 bzoj4516 [Sdoi2016]生成魔咒不同子串的个数为n(n+1)/2-sum(height) [AHOI2014/JSOI2014]骑士游戏最短路就是某种意义上的dp（无负边），每次用最小值更新这题也是每次用每个点的最小值更新其他点，一开始将所有点的魔法值入堆 [AHOI2014/JSOI2014]支线剧情上下界网络流 [AHOI2014/JSOI2014]奇怪的计算器先二分出全变成l和r的地方中间的在线段树上做，加、乘、at三个标记 [AHOI2014/JSOI2014]拼图先枚举底在第i行，再枚举高度为j，最后每一列扫一遍复杂度$O(nmmin(m,n))$ [Jsoi2014]病毒分类trie树上搞出每个串属于的两个集合每个串变成边求最小点覆盖 题目：区间有每个数的出现次数限制，求数的最小次数差分约束 [Jsoi2014]支线剧情2 [Jsoi2014]打兔子观察发现发枪顺序没有影响，且不会发相邻的枪dp[i][j][0/1]表示到i打j枪且i处是否发枪多dp几遍，考虑第1个位置和第2个位置放不放 2118: 墨墨的等式套路dp考虑B%ai的值,0~ai-1对每个余数i进行dp，求出最小的余数为i的Bf[i]=min(f[j]+ak|(j+ak%ai)%ai==i)dp的顺序不知道变成最短路即可建图的复杂度是O(na)跑spfa或者dijk的复杂度是O(能过)显然用ai最小的值作除数 4082: [Wf2014]Surveillance去掉包含的区间：先排序，R[i]=max(R[i-1],end[i])表示左端点在i及左边，右端点的最远值，则对于区间[l,r]，只要判断R[l]和r的关系即可先变成链（翻两倍），去掉包含的区间 O(nlogn)在环上预处理后继的区间 O(nlogn)再变成链倍增求出f[i][j]表示从第i个区间/第i个位置走j步到达的最远距离然后每个区间的首位置再判一遍 2303: [Apio2011]方格染色注意到第一行和第一列确定后可以确定整个图图中每个点(i,j)可以列出异或方程：a11^a1j^ai1^aij=[i,j都是偶数]aij和a11都可以去掉然后并查集 3150: [Ctsc2013]猴子先考虑n=10一个状态可以变成好多状态啊列方程吧f(s)表示s状态的胜率结论：f(s)∩f(t)=∅，f(s)+f(t)=f(s+t)证明:s=s1+s2,f(s1)+f(s2)+f(t)=1,f(s)+f(t)=1 =&gt; f(s)=f(s1)+f(s2)所以处理所有只有一个1的状态就可以了 4237: 稻草人分治加平衡树O(nlognlogn) hdu5800 To My Girlfriendf[i][j][f1][f2]表示到第i个和为j已经’钦定’的选的个数为f1，’钦定’不选的为f2 多区间问题，每个区间有要求，如：2018 计蒜之道 初赛 第四场 贝壳找房搜房[USACO13OPEN]照片Photo 18-7-1b. sigma(g[i](n-i)-g[i+1](n-i-1)*(i+1))f.区间排序的套路：二分，使序列变成0/1 18-7-4d.套路分块 f[i][x]表示从i到第x块结束的答案 f[x][i]表示从第x块开始到i的答案 O(nsqrtnlogn)a.f[i][j][x]表示i到j最终变成字符x，转移是枚举i,j,分界点k,和变化规则，O(n^4) g[i][j]表示第一个到i，第二个到j，的最短长度，转移再枚举p,q,O(n^4)b.预处理撞到每个红灯的时间区间，从后往前做，在线段树上覆盖（动态开点），然后求出每个红灯到终点的答案（相当于求一辆车到的下一个红灯）c.和最大的情况下x1最小，等价于x2最大，所以重新定义优先级后，再求线性基，线性基中的所有数都给x2，其他给x1e.建图小技巧：要连nm条边的时候，考虑每个ai加辅助点ci，排序，每个点向自己的辅助点连wi，辅助点向自己连0，ci向ci+1连差，ci+1向ci连0，这样只有O(n)条边，在起点前加一个0点，重点后加两个0点（因为在新图上走一步就是走两条边）最终答案为最后两个0点中的较小值 约瑟夫问题1)n个人，顺着杀和倒着杀k个人 顺着杀： m=1(mod n) m=1(mod n-1) . . . m=1(mod n-k+1) 倒着杀： m=0(mod n) m=0(mod n-1) . . . m=0(mod n-k+1)2)n个人，要求让第k个人活下来，求m 若n为质数： m=k-1(mod n) m=0(mod 1) m=0(mod 2) . . . m=0(mod n-1) 或者 m=k+1(mod n) m=1(mod 1) m=1(mod 2) . . . m=1(mod n-1) 若n为不是质数： 伯特兰—切比雪夫定理说明：若整数n &gt; 3，则至少存在一个质数p，符合n &lt; p &lt; 2n − 2。另一个稍弱说法是：对于所有大于1的整数n，存在一个质数p，符合n &lt; p &lt; 2n。 不妨设k&gt;n/2 m=1(mod lcm(1,2,…,n)/p) m=k+1-n(mod p) 18-7-6a.欧拉函数可以不管指数！用LL记录60个质数是否出现过，复杂度少一个60b.f(S)表示集合S中连通块的个数（S包含1），$f(S)=\prod (C{ij}+1)-f(S’)*(C{i’j’}+1)$(S’属于S,i’,j’属于S/S’) d.1e12以内因数最多的数大概有6000个因数，f[i][x]={a,b}表示前i个数选了a个，总和为b，且与k的最大公因数为x，f[i][x] - a[i+1] -&gt; f[i+1][gcd(x*a[i+1],k)] 答案为f[n][k]，记录每个f从哪个状态转移过来的，倒推可以求出序列f.n(n&gt;=3)可以，则n+2可以。n=3，6可以，n=4不可以e.线段树，维护加标记和相同标记和颜色标记(如果相同标记=1)，对于区间修改，若该区间相同标记=1,直接改，否则递归下去处理。复杂度等于添加标记的次数为O(nlogn) 18-7-8a.用hash可以去一个logb.基尔霍夫矩阵去一行一列的行列式的值等于选n-1条边构成树，每条边权的乘积的和。最傻的做法会发现没有考虑其他边被删掉的情况，所以先把所有边都删掉，再在矩阵中补上$ans=\prod(1-p{ij})*|p{ij}/(1-p_{ij})|$ c.二维线段树可以改成一维线段树，按r建线段树，叶子节点开vector记录所有l，非叶子记录子树中l的最大值，删除的话就暴力删，反正只有m个区间d.按dfs序排序，值等于相邻点的距离加起来/2e.记录每个点向前最远到那+倍增f.卡空间。两种做法：1.分块，每sqrt(n)行记录一次dp值，求路径的话就再用O(sqrt(n))的空间暴力求2.分治，对于行(l,r)，找出中间行的最优位置，每次面积/2 18-7-10a.多项式c.谁想写谁写。。f[i][sta][s]表示到第i个数的，前i个数的集合为s，单调栈中的集合为sta，O(n)转移d.n^2构造，对一个连通块，yes &lt;=&gt; sigma(ai)=sigma(bi)，dfs到叶子，以叶子为根再dfs，能流就流e.dp优化网络流，0代表与s相连，1代表与t相连，1的前面有0的话就要有一个c的贡献，dp[i][j]表示前i个点中有j个1，O(1)转移 18-7-11e.和[文理分科]很想，一只狗可以选择公的或者母的，一个人希望某些狗是公的或者母的。最小割，狗向s,t连边，人向他希望的那些狗连边。联系最小割的含义建图。f.n=3,4无解，n&gt;4，第一条边长1000，以后每条边减0.1，最后两条边直接算，有相等的概率很小。。d.f[i][j][k]表示前i个人中，有j组未闭合，代价和为k。 1到n每个位置上有一盏灯，点亮i要w[i]的代价，每个位置会被自己及左右照亮，要求每个位置都亮的最小代价。dp[i][0/1/2]表示到i，0：i点亮了，1：i没点亮i-1点亮了，2：i没点亮i-1没点亮复杂度O(n)加强：可以交换k（k&lt;=9)对位置的代价，求最小代价f[i][j][k][0/1/2]表示到i，前面有j个已经钦点了（可以是负数），已经换了k对，0/1/2同上其实就是已经选了某些位置的集合不好表示，用背包来做复杂度O(nk^2)]]></content>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】splay]]></title>
    <url>%2F2018%2F05%2F09%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91splay%2F</url>
    <content type="text"><![CDATA[splay是个好东西复杂度O(nlogn)（势能分析我不会）常数较大请写迭代每次询问后都要做splay操作（一直询问深度为O(n)的点就挂了，例如依次插入1到n）一个常数不太大的模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n;int opt,x;int tot,rt,ch[N][2],fa[N],key[N],num[N],sum[N];inline void newnode(int &amp;pos,int p,int x)&#123; pos=++tot; fa[pos]=p; key[pos]=x; num[pos]=sum[pos]=1; ch[pos][0]=ch[pos][1]=0;&#125;inline void pushup(int x)&#123; sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+num[x];&#125;inline void rotate(int x,int op)&#123; int y=fa[x]; ch[y][!op]=ch[x][op]; fa[ch[x][op]]=y; if(fa[y])&#123; ch[fa[y]][ch[fa[y]][1]==y]=x; &#125; fa[x]=fa[y]; ch[x][op]=y; fa[y]=x; pushup(y); pushup(x); &#125;inline void splay(int x,int goal)&#123; while(fa[x]!=goal)&#123; if(fa[fa[x]]==goal)&#123; rotate(x,ch[fa[x]][0]==x); &#125; else&#123; int y=fa[x]; bool op=ch[fa[y]][0]==y; if(ch[y][op]==x)&#123; rotate(x,!op); rotate(x,op); &#125; else&#123; rotate(y,op); rotate(x,op); &#125; &#125; &#125; if(goal==0)&#123; rt=x; &#125;&#125;inline void insert(int x)&#123; if(rt==0)&#123; newnode(rt,0,x); return; &#125; int tmp=rt; while(1)&#123; if(key[tmp]==x)&#123; ++num[tmp]; splay(tmp,0); return; &#125; if(ch[tmp][key[tmp]&lt;x]==0) break; tmp=ch[tmp][key[tmp]&lt;x]; &#125; newnode(ch[tmp][key[tmp]&lt;x],tmp,x); splay(tot,0); return;&#125;inline bool find(int x)&#123; int tmp=rt; while(tmp)&#123; if(key[tmp]==x)&#123; splay(tmp,0); return 1; &#125; if(key[tmp]&gt;x)&#123; tmp=ch[tmp][0]; &#125; else&#123; tmp=ch[tmp][1]; &#125; &#125; return 0;&#125;inline void pop()&#123; if(num[rt]&gt;1)&#123; --num[rt];--sum[rt];return; &#125; if(!ch[rt][0])&#123; fa[ch[rt][1]]=0; rt=ch[rt][1]; return; &#125; if(!ch[rt][1])&#123; fa[ch[rt][0]]=0; rt=ch[rt][0]; return; &#125; int tmp=ch[rt][0]; while(ch[tmp][1]) tmp=ch[tmp][1]; splay(tmp,rt); ch[tmp][1]=ch[rt][1]; rt=tmp; fa[tmp]=0; fa[ch[rt][1]]=rt; pushup(rt);&#125;inline void del(int x)&#123; if(find(x))&#123; pop(); &#125; &#125;inline int get_pre(int x)&#123; int tmp=rt,ans=INT_MIN; while(1)&#123; if(key[tmp]&lt;x)&#123; ans=max(ans,key[tmp]); if(!ch[tmp][1])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][1]; &#125; else&#123; if(!ch[tmp][0])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][0]; &#125; &#125; return ans;&#125;inline int get_nxt(int x)&#123; int tmp=rt,ans=INT_MAX; while(1)&#123; if(key[tmp]&gt;x)&#123; ans=min(ans,key[tmp]); if(!ch[tmp][0])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][0]; &#125; else&#123; if(!ch[tmp][1])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][1]; &#125; &#125; return ans;&#125;inline int rank(int x)&#123; int tmp=rt,ans=0; while(1)&#123; if(key[tmp]&gt;=x)&#123; if(!ch[tmp][0])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][0]; &#125; else&#123; ans+=sum[ch[tmp][0]]+num[tmp]; if(!ch[tmp][1])&#123; splay(tmp,0); break; &#125; tmp=ch[tmp][1]; &#125; &#125; return ans+1;&#125;inline int kth(int x)&#123; int tmp=rt; while(x)&#123; if(sum[ch[tmp][0]]&gt;=x)&#123; tmp=ch[tmp][0]; &#125; else&#123; x-=sum[ch[tmp][0]]; if(x&lt;=num[tmp])&#123; splay(tmp,0); return key[tmp]; &#125; x-=num[tmp]; tmp=ch[tmp][1]; &#125; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; opt=read();x=read(); switch (opt)&#123; case 1:&#123; insert(x); break; &#125; case 2:&#123; del(x); break; &#125; case 3:&#123; printf(&quot;%d\n&quot;,rank(x)); break; &#125; case 4:&#123; printf(&quot;%d\n&quot;,kth(x)); break; &#125; case 5:&#123; printf(&quot;%d\n&quot;,get_pre(x)); break; &#125; case 6:&#123; printf(&quot;%d\n&quot;,get_nxt(x)); break; &#125; &#125; &#125; return 0;&#125; splay最特色的区间翻转123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m;int l,r,rt,tot;int fa[N],sz[N],ch[N][2];bool rev[N];inline void pushup(int x)&#123; sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1;&#125;inline void rotate(int x,int op)&#123; int y=fa[x]; ch[y][!op]=ch[x][op]; fa[ch[x][op]]=y; if(fa[y])&#123; ch[fa[y]][ch[fa[y]][1]==y]=x; &#125; fa[x]=fa[y]; ch[x][op]=y; fa[y]=x; pushup(y); pushup(x);&#125;inline void splay(int x,int goal)&#123; while(fa[x]!=goal)&#123; if(fa[fa[x]]==goal)&#123; rotate(x,ch[fa[x]][0]==x); &#125; else&#123; int y=fa[x]; bool op=ch[fa[y]][0]==y; if(ch[y][op]==x)&#123; rotate(x,!op); rotate(x,op); &#125; else&#123; rotate(y,op); rotate(x,op); &#125; &#125; &#125; if(goal==0)&#123; rt=x; &#125;&#125;inline void pushdown(int x)&#123; if(rev[x])&#123; swap(ch[x][0],ch[x][1]); rev[ch[x][0]]^=1; rev[ch[x][1]]^=1; rev[x]=0; &#125;&#125;inline int find(int x)&#123; int tmp=rt,cnt=0; while(1)&#123; pushdown(tmp); if(sz[ch[tmp][0]]+1==x) return tmp; if(sz[ch[tmp][0]]&gt;=x)&#123; tmp=ch[tmp][0]; &#125; else&#123; x-=sz[ch[tmp][0]]+1; tmp=ch[tmp][1]; &#125; &#125;&#125;inline void rever(int l,int r)&#123; int x=find(l-1),y=find(r+1); splay(x,0); splay(y,rt); rev[ch[y][0]]^=1;&#125;inline void build(int p,int l,int r)&#123; if(l&gt;r) return; if(l==r)&#123; fa[l]=p; sz[l]=1; if(l&lt;p)&#123; ch[p][0]=l; &#125; else&#123; ch[p][1]=l; &#125; return; &#125; int mid=(l+r)&gt;&gt;1; fa[mid]=p; build(mid,l,mid-1); build(mid,mid+1,r); pushup(mid); if(mid&lt;p)&#123; ch[p][0]=mid; &#125; else&#123; ch[p][1]=mid; &#125;&#125;int main()&#123; n=read();m=read(); build(0,1,n+2); rt=(n+3)&gt;&gt;1; while(m--)&#123; l=read()+1;r=read()+1; if(l==r) continue; rever(l,r); &#125; //不能print！！有标记还没下放！！ for(int i=2;i&lt;=n+1;++i)&#123; printf(&quot;%d &quot;,find(i)-1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2985The k-th Largest Group]]></title>
    <url>%2F2018%2F05%2F07%2Fpoj2985The%20k-th%20Largest%20Group%2F</url>
    <content type="text"><![CDATA[123456单点修改找第k大二分+树状数组，复杂度O(nlog^2n)树状数组上二分，复杂度O(nlogn)妙极了树状数组二分和线段树二分差不多 二分+树状数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=300008;int n,m;int op,x,y;int p[N],p1,p2;int a[N],bit[N];int num;int l,r,mid,k,ans;inline void add(int pos,int x)&#123; for(int i=pos;i&lt;=n;i+=i&amp;-i)&#123; bit[i]+=x; &#125;&#125;inline int sum(int pos)&#123; int tmp=0; for(int i=pos;i;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125;inline int find(int x)&#123; return x==p[x]?x:p[x]=find(p[x]);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; p[i]=i; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]=1; &#125; add(1,n); num=n; while(m--)&#123; op=read(); if(op==0)&#123; x=read();y=read(); p1=find(x); p2=find(y); if(p1==p2) continue; add(a[p1],-1); add(a[p2],-1); add(a[p2]=a[p1]+a[p2],1); p[p1]=p2; --num; &#125; else&#123; k=read(); k=num-k+1; l=1; r=n; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(sum(mid)&gt;=k)&#123; r=mid-1; ans=mid; &#125; else&#123; l=mid+1; &#125; &#125; printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; 树状数组上二分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=300008;int n,m;int op,x,y;int p[N],p1,p2;int a[N],bit[N];int num;int k;inline void add(int pos,int x)&#123; for(int i=pos;i&lt;=n;i+=i&amp;-i)&#123; bit[i]+=x; &#125;&#125;inline int sum(int pos)&#123; int tmp=0; for(int i=pos;i;i-=i&amp;-i)&#123; tmp+=bit[i]; &#125; return tmp;&#125;inline int find(int x)&#123; return x==p[x]?x:p[x]=find(p[x]);&#125;inline int query(int pos)&#123; int tmp=0,cnt=0; for(int i=20;i&gt;=0;--i)&#123; tmp+=1&lt;&lt;i; if(tmp&gt;=n||cnt+bit[tmp]&gt;=pos)&#123; tmp-=1&lt;&lt;i; &#125; else&#123; cnt+=bit[tmp]; &#125; &#125; return tmp+1;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; p[i]=i; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]=1; &#125; add(1,n); num=n; while(m--)&#123; op=read(); if(op==0)&#123; x=read();y=read(); p1=find(x); p2=find(y); if(p1==p2) continue; add(a[p1],-1); add(a[p2],-1); add(a[p2]=a[p1]+a[p2],1); p[p1]=p2; --num; &#125; else&#123; k=read(); printf(&quot;%d\n&quot;,query(num-k+1)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1903 [国家集训队]数颜色]]></title>
    <url>%2F2018%2F05%2F02%2Fluogu1903%20%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E6%95%B0%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[1234567891011带修改的莫队设块长为blk则复杂度为O(n*blk+n*n/blk+(n/blk)*(n/blk)*n)均值求出blk=n^(2/3)总复杂度为O(n^5/3)排序的时候一定要求出每个点所属的块不要用除法！不要用除法！不要用除法！（t到死） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=50008,MAX=1000008;int n,m,blk;int a[N],b[N],be[N];char ch;int idxq,idxc;int curl,curr,curt;int tmp,ans[N],cnt[MAX];struct node&#123; int l,r,tim,id;&#125;q[N];struct node2&#123; int pos,now,pre;&#125;c[N];inline bool cmp(const node &amp;a,const node &amp;b)&#123; return (be[a.l]==be[b.l])?((be[a.r]==be[b.r])?a.tim&lt;b.tim:a.r&lt;b.r):a.l&lt;b.l;&#125;inline void add(int x)&#123; if(!cnt[x]) ++tmp; ++cnt[x];&#125;inline void remove(int x)&#123; --cnt[x]; if(!cnt[x]) --tmp;&#125;inline void going(int pos,int x)&#123; if(curl&lt;=pos&amp;&amp;pos&lt;=curr)&#123; remove(a[pos]); add(x); &#125; a[pos]=x;&#125;int main()&#123; n=read();m=read(); blk=pow(n,0.666666); for(int i=1;i&lt;=n;++i)&#123; b[i]=a[i]=read(); be[i]=i/blk+1; &#125; for(int i=1;i&lt;=m;++i)&#123; ch=getchar(); while(ch!=&apos;Q&apos;&amp;&amp;ch!=&apos;R&apos;) ch=getchar(); if(ch==&apos;Q&apos;)&#123; q[++idxq].l=read(); q[idxq].r=read(); q[idxq].tim=idxc; q[idxq].id=idxq; &#125; else&#123; c[++idxc].pos=read(); c[idxc].pre=b[c[idxc].pos]; b[c[idxc].pos]=c[idxc].now=read(); &#125; &#125; sort(q+1,q+idxq,cmp); for(int i=1;i&lt;=idxq;++i)&#123; while(curt&lt;q[i].tim)&#123; ++curt; going(c[curt].pos,c[curt].now); &#125; while(curt&gt;q[i].tim)&#123; going(c[curt].pos,c[curt].pre); --curt; &#125; while(curl&gt;q[i].l)&#123; add(a[--curl]); &#125; while(curr&lt;q[i].r)&#123; add(a[++curr]); &#125; while(curl&lt;q[i].l)&#123; remove(a[curl]); ++curl; &#125; while(curr&gt;q[i].r)&#123; remove(a[curr]); --curr; &#125; ans[q[i].id]=tmp; &#125; for(int i=1;i&lt;=idxq;++i)&#123; printf(&quot;%d\n&quot;,ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2709 小B的询问]]></title>
    <url>%2F2018%2F05%2F01%2Fluogu2709%20%E5%B0%8FB%E7%9A%84%E8%AF%A2%E9%97%AE%2F</url>
    <content type="text"><![CDATA[1234567关于排序的速度：cmp&lt;重载&lt;友元重载（部分数据即实验结果）莫队裸题小优化：对奇数块，r从小到大对偶数快，r从大到小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=50008;int n,m,k,blk;int a[N];int curl,curr;int tmp,ans[N],cnt[N];struct node&#123; int l,r,id;&#125;q[N];inline bool cmp(const node &amp;a,const node &amp;b)&#123; //return (a.l/blk==b.l/blk)?a.r&lt;b.r:a.l&lt;b.l; if(a.l/blk!=b.l/blk) return a.l&lt;b.l; if(a.l/blk%2) return a.r&lt;b.r; return a.r&gt;b.r;&#125;inline void add(int x)&#123; tmp+=2*cnt[a[x]]+1; ++cnt[a[x]];&#125;inline void remove(int x)&#123; tmp-=2*cnt[a[x]]-1; --cnt[a[x]];&#125;int main()&#123; n=read();m=read();k=read(); blk=sqrt(n); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;=m;++i)&#123; q[i].l=read();q[i].r=read();q[i].id=i; &#125; sort(q+1,q+m+1,cmp); curl=1;curr=0; for(int i=1;i&lt;=m;++i)&#123; while(curl&gt;q[i].l)&#123; add(--curl); &#125; while(curr&lt;q[i].r)&#123; add(++curr); &#125; while(curl&lt;q[i].l)&#123; remove(curl); ++curl; &#125; while(curr&gt;q[i].r)&#123; remove(curr); --curr; &#125; ans[q[i].id]=tmp; &#125; for(int i=1;i&lt;=m;++i)&#123; printf(&quot;%d\n&quot;,ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1198 [JSOI2008]最大数]]></title>
    <url>%2F2018%2F04%2F30%2Fluogu1198%20%5BJSOI2008%5D%E6%9C%80%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1234567做法很多把板子复习一下1.单调队列，然后二分2.单调队列，然后维护每个位置的更优解，加上路径压缩3.树状数组，需要从后往前加，最大值不能作减法4.线段树5.分块 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int M=200008;int m,d,a;char c[1];int t,l;int q[M],ta,tim[M];int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;d); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%s%d&quot;,c,&amp;a); if(c[0]==&apos;A&apos;)&#123; a=(0ll+a+t)%d; while(ta&amp;&amp;q[ta]&lt;=a) --ta; q[++ta]=a; tim[ta]=++l; &#125; else&#123; if(a)&#123; printf(&quot;%d\n&quot;,t=q[lower_bound(tim+1,tim+ta+1,l-a+1)-tim]); &#125; else&#123; puts(&quot;0&quot;); &#125; &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int M=200008;int m,d,a;char c[1];int t;int q[M],ta,fa[M],num[M],id[M],len;inline int find(int x)&#123; return x==fa[x]?x:fa[x]=find(fa[x]);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;d); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%s%d&quot;,c,&amp;a); if(c[0]==&apos;A&apos;)&#123; a=(0ll+a+t)%d; ++len; num[len]=a; fa[len]=len; while(ta&amp;&amp;q[ta]&lt;=a)&#123; fa[id[ta]]=len; --ta; &#125; q[++ta]=a; id[ta]=len; &#125; else&#123; if(a)&#123; printf(&quot;%d\n&quot;,t=num[find(len-a+1)]); &#125; else&#123; puts(&quot;0&quot;); &#125; &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int M=200008;int m,d,a;char c[1];int t,num,b[M];inline void add(int p,int x)&#123; for(int i=p;i&lt;=m;i+=i&amp;-i)&#123; b[i]=max(b[i],x); &#125;&#125;inline int query(int p)&#123; int tmp=INT_MIN; for(int i=p;i;i-=i&amp;-i)&#123; tmp=max(tmp,b[i]); &#125; return tmp;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;d); num=m; for(int i=1;i&lt;=m;++i)&#123; b[i]=INT_MIN; &#125; for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%s%d&quot;,c,&amp;a); if(c[0]==&apos;A&apos;)&#123; a=(0ll+a+t)%d; add(num,a); --num; &#125; else&#123; if(a)&#123; printf(&quot;%d\n&quot;,t=query(num+a)); &#125; else&#123; puts(&quot;0&quot;); &#125; &#125; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int M=200008;int m,d,a;char c[1];int len,t;int tree[M&lt;&lt;2];inline void update(int x,int l,int r)&#123; if(l==len&amp;&amp;r==len)&#123; tree[x]=a; return; &#125; int mid=(l+r)&gt;&gt;1; if(len&lt;=mid) update(x&lt;&lt;1,l,mid); else update(x&lt;&lt;1|1,mid+1,r); tree[x]=max(tree[x&lt;&lt;1],tree[x&lt;&lt;1|1]);&#125;inline int query(int x,int l,int r)&#123; if(len-a+1&lt;=l&amp;&amp;r&lt;=len)&#123; return tree[x]; &#125; int mid=(l+r)&gt;&gt;1; if(len&lt;=mid) return query(x&lt;&lt;1,l,mid); if(len-a+1&gt;mid) return query(x&lt;&lt;1|1,mid+1,r); return max(query(x&lt;&lt;1,l,mid),query(x&lt;&lt;1|1,mid+1,r));&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;d); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%s%d&quot;,c,&amp;a); if(c[0]==&apos;A&apos;)&#123; a=(0ll+a+t)%d; ++len; update(1,1,m); &#125; else&#123; if(a)&#123; printf(&quot;%d\n&quot;,t=query(1,1,m)); &#125; else&#123; puts(&quot;0&quot;); &#125; &#125; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int M=200008;int m,d,a,t;char c[1];int blk,len;int num[M],bl[M],maxi[M];inline void update()&#123; ++len; bl[len]=(len-1)/blk+1; num[len]=a; maxi[bl[len]]=max(maxi[bl[len]],a);&#125;inline int query(int l,int r)&#123; int tmp=INT_MIN; for(int i=min(r,bl[l]*blk);i&gt;=l;--i)&#123; tmp=max(tmp,num[i]); &#125; for(int i=bl[l]+1;i&lt;bl[r];++i)&#123; tmp=max(tmp,maxi[i]); &#125; for(int i=max(l,(bl[r]-1)*blk+1);i&lt;=r;++i)&#123; tmp=max(tmp,num[i]); &#125; return tmp;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;d); blk=sqrt(m); for(int i=m/blk+1;i;--i)&#123; maxi[i]=INT_MIN; &#125; for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%s%d&quot;,c,&amp;a); if(c[0]==&apos;A&apos;)&#123; a=(0ll+a+t)%d; update(); &#125; else&#123; if(a)&#123; printf(&quot;%d\n&quot;,t=query(len-a+1,len)); &#125; else&#123; puts(&quot;0&quot;); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>单调队列</tag>
        <tag>并查集</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1484 种树]]></title>
    <url>%2F2018%2F04%2F30%2Fluogu1484%20%E7%A7%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[12345678910111213大根堆要能够反悔注意到选了一个，它一定比两边的优所以要么选它，要么两边同时选选一个点之后将它两边的值减去它，更新到这个点，删去两边的点这样每轮还是相当于选一个点注意边界处理调了一天要先弹完用过的再判负顺序很重要！顺序很重要！顺序很重要！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=500008;int n,k;int pre[N],nxt[N];LL a[N];priority_queue&lt;pair&lt;LL,int&gt; &gt; q;LL ans;bool vis[N];int main()&#123; n=read();k=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); q.push(mp(a[i],i)); pre[i]=i-1; nxt[i]=i+1; &#125; while(k--)&#123; while(vis[q.top().second])&#123;//要用while，if的话会消耗k q.pop(); &#125; if(q.top().first&lt;=0) break; ans+=q.top().first; int x=q.top().second; q.pop(); a[x]=a[pre[x]]+a[nxt[x]]-a[x]; if(pre[x]!=0)&#123; vis[pre[x]]=1; pre[x]=pre[pre[x]]; nxt[pre[x]]=x; &#125; if(nxt[x]!=n+1)&#123; vis[nxt[x]]=1; nxt[x]=nxt[nxt[x]]; pre[nxt[x]]=x; &#125; q.push(mp(a[x],x)); &#125; printf(&quot;%lld&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技巧]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[内啡肽：冷静作用促进内啡肽分泌的方式：运动，冥想，深呼吸，笑 多巴胺：预期奖励短期大量释放多巴胺，让我们更追求短期快感，更没耐心。更多的多巴胺或提高阈值，导致更难获得快乐。保持平常心，减少情绪波动，降低多巴胺分泌。 差不多退役了算法竞赛教会我什么呢多年之后还能影响到我的估计只有思维上多出的一丝敏捷（这都没有就啥都没有了吉老师线段树什么的怎么可能记得呢（亏我熬夜到一点去调代码，结果是思维方式有问题（把tag放在一起考虑，，合并起来也方便 要是有机会去wc的话，接下来一段时间的目标是数学和dp有机会了（这是你颓废那么多天的结果吗。。 1.$n$维曼哈顿距离可以变成$2^{n-1}$维契比雪夫距离。（相当于枚举$n-1$个的符号） 2.三分：(2l+r)/3,(l+2r+2)/3 3.对时间建线段树可以代替cdq分治 4.二进制分组 5.离散化：sort+unique+lower_boundsort(a+1,a+n+1);n=unique(a+1,a+n+1)-a-1;查值x：return lower_bound(a+1,a+n+1,x)-a;或者12345678910for(int i=1;i&lt;=n;++i)&#123; a[i].x=read();a[i].id=i;&#125;sort(a+1,a+n+1,cmp);last=1;b[a[1].id]=1;for(int i=2;i&lt;=n;++i)&#123; if(a[i].x!=a[i-1].x) ++last; b[a[i].id]=last;&#125; 6.hash：模$2^{31}+1$，设后31位为a，前面为b，原数为$a+b*2^{31}$，模完为$a-b$ 7.压位 8.区间众数离线：莫队 $O(n\sqrt{n})$ 右端点递增；左端点固定，每次向左移到询问的位置，结束再撤回（回滚莫队）在线：(1) 分块+vector二分 $O(n\sqrt{nlogn})$ (2) 分块，对每种值在每个块末尾记录出现次数，$O(n\sqrt{n})$ 9.dtx： 倍增替代二分 10.二分图中：最小点覆盖等于最大匹配（最小点覆盖$\geq$最大匹配，且每个匹配中取一个点可以成为点覆盖） 最大独立集+最小点覆盖=点数（独立集是点覆盖的补集） 11.符号：%的值同被除数，/的值根据被除数和除数的符号，相同为正，不相同为负 12.[k/i]一共根号个值，下一个i=k/(k/i)+1可以用到整除分块的形式，大致是这样的： $$ \sum_{i=1}^{n}[\frac{n}{i}] $$from peng-ym这个式子，O(n)计算是非常显然的。但，有的时候因为多组数据的要求，可能O(n)并不是正确的时间复杂度。那么这个时候，我们就有一种O($\sqrt{n}$)的做法。这就是：整除分块！对于每一个⌊n/i⌋我们可以通过打表(或理性的证明)可以发现：有许多⌊n/i⌋的值是一样的，而且它们呈一个块状分布；再通过打表之类的各种方法,我们惊喜的发现对于每一个值相同的块，它的最后一个数就是n/(n/i)。得出这个结论后，我们就可以做的O($\sqrt{n}$)处理了。附一个整除分块的代码吧：12345for(int l=1,r;l&lt;=n;l=r+1)&#123; r=n/(n/l); ans+=(r-l+1)*(n/l);&#125; 13.printf输出double是四舍五入的，保留两位向下取整就-0.005+eps再输出，向上取整就+0.005-eps再输出 double有15位有效数字 eps应该是小于你能算出来所有数两两之差(xy) 精度误差可以认为在[-1e-13,1e-13]之间 何时+/-eps凭感觉(xy) 只能详细记录各种情况了： （负数的四舍五入要看题目定义，故只讨论正数） 拿边界往里带 正数的四舍五入要+eps，（负数可能要-eps) 14.尺规作图只能做加减乘除开方五种运算 15.隔板法要么是隔数字要么是隔位置 16.线性求逆元：inv[i]=(p-p/i)inv[p%i]%p或者inv[i]=p-p/iinv[p%i]%p; inv[1]=1是一定要写的！ 17.最大团和最大独立集是等价的，都是npc 一个图的最大团和取反的图的最大独立集等价 18.高维前缀和要一位一位做 集合的子集和和高维前缀和一样 要一位一位做 否则会重复 001&lt;-000 010&lt;-000 011&lt;-001 &lt;-010 然后发现000在011中出现两次、 应该是 001&lt;-000 011&lt;-010 010&lt;-000 011&lt;-001 19.坐标范围1到n的下凸壳上有sqrt(n)个点 20.A坐标系中的切比雪夫距离=B坐标系中的曼哈顿距离 A坐标系中的曼哈顿距离=B坐标系中的切比雪夫距离（B为A旋转45°，顺时针和逆时针是一样的，因为在互相垂直的坐标系中切比雪夫距离和曼哈顿距离是等价的） 旋转45°,(x,y)-&gt;((x+y)/2,(x-y)/2) 曼哈顿距离：dis=|x1−x2|+|y1−y2| 切比雪夫距离：dis=max(|x1−x2|,|y1−y2|) 将一个点(x,y)(x,y)的坐标变为(x+y,x−y)(x+y,x−y)后,原坐标系中的曼哈顿距离 == 新坐标系中的切比雪夫距离 将一个点(x,y)(x,y)的坐标变为((x+y)/2,(x−y)/2)((x+y)/2,(x−y)/2) 后,原坐标系中的切比雪夫距离 == 新坐标系中的曼哈顿距离 21.无向仙人掌图判定：dfs+差分，返祖边的下端点+1，上端点-1，一条边属于&gt;2个环就不是仙人掌，否则是。 有向仙人掌图判定：dfs，找到一个环就暴力的把环上每条边+1 22.$T(n)=2T(n/2)+O(n) =&gt; O(nlogn)$ $T(n)=T(n/2)+O(n) =&gt; O(n)$ $T(n)=4T(n/2)+O(n) =&gt; O(n^2)$ 23.处理与询问无关可以用分治 24.打决策点看决策单调性 25.一定要造极限数据！！把int全换成ll再跑一遍看结果之类的。 26.两遍dfs找树的直径不适用于负权（证明需要每条边大于等于0，还是dp管用） 例子：(1) -&gt; 1 -&gt; (2) -&gt; -2 -&gt; (3) -&gt; 2 -&gt; (4)，从2开始就爆炸了 27.$\sum_{i|n}n/i=O(n)*质因数个数(n)$ 28.开根复杂度：O(loglogn)牛顿迭代复杂度 29.p1+p2=1则模意义下p1+p2=1(mod p)（要求：设p1=a/b（没有约分时）,(a,p)=1,(b,p)=1） 30.在剩下的数中等概率选，可以等价为：不减少数，在所有数中等概率选，选中不合法的无收益，重来 证明： $F=\frac{1}{n-1}(f(1)+…+f(n-1))$ $F=\frac{1}{n}(f(1)+…+f(n-1))+\frac{1}{n}F$ 显然两式等价 31.treap的删除要注意，删到不存在的节点要停住，不然tle（cjq） 32.rand用48271ll*seed%INT_MAX可以生产1到INT_MAX-1的所有数 33.结构体中的函数可以调用该结构体后面的函数，结构体中不能声明函数。 正常的函数如果出现循环调用要先声明。 34.集合s 遍历s的子集 for(int i=s;i&gt;0;i=(i-1)&amp;s)（没有枚举空集 int x=s; while(1){ solve(); if(x==0) break; x=(x-1)&s;//只有x是s的子集的时候是有效的 } 遍历s的超集 for(int i=s;i&lt;Max;i=(i+1)|s) 35.最短路计数（先判掉0环） spfa：每次更新后要清0 dijk：不能处理0边？（无0环） 36.dag上dp：拓扑出来或者记忆化搜索，spfa会t啊。 37.可并堆的3种写法： 1.左偏（dist_left&gt;=dist_right) 2.无脑换 3.随机换 38.单调上升转成单调不降通过ai -&gt; ai-i 单调不降转成单调上升通过ai -&gt; ai+i 39.最短路：边多：不加优化的dijk 边少：加堆优化的dijk 40.树上背包有时可以转化成dfs序做（比如必须要是连通的，对于某个点，选就继续，不选就跳过整个子树） 41.有时边存不下仍然是可能可以跑出来的（存边需要乘上一个常数，心中有边即可。。） 42.数组直接做参数会隐式转换为指针，传参的时候a[]和*a是等价的，甚至方括号里写一个长度都是等价的，不过二维或更高维数组只有第一维变成指针 43.手动开栈：-Wl,–stack=/字节数/ -Wl,–stack=1000000000 //开1GB的栈 44.区间加等差数列：维护每个区间加的a+bi（i是第几项） 线段树要求记录的值和tag可以合并 45.bit上的二分： 1234567891011inline int solve(int x)//求min(i)，使得sum[i]&gt;=x&#123; int pos=0; for(int i=20;i&gt;=0;--i)&#123;//20是logn if(pos+(1&lt;&lt;i)&lt;=n&amp;&amp;bit[pos+(1&lt;&lt;i)]&lt;=x)&#123; pos+=(1&lt;&lt;i); x-=bit[pos]; &#125; &#125; return pos;&#125; 46.（二维数点）求矩形内点的个数（离线）： 按x排序，在y轴上建树桩，遇到矩形的左边界作减法，遇到矩形的右边界作加法 （在线或带修改）： bit套权值线段树 //233 47.线段树维护区间gcd：是nlog（做一次辗转相除，gcd减小一倍） 48.noi2016区间，按区间长度排序，左右指针，线段树维护被覆盖的最大值 49.BZOJ 4552 线段树合并？ 50.组合数 $(x+1)^n=\sum{i=0}^n({i}^{n})*x^i$ 两边求导后令x=1，可以求得一阶和式 再求导可得二阶和式.. 卢卡斯定理（p为质数） 当p=2时，$({k}^{n})=0$只有n=0,k=1，$({k}^{n})=1(mod 2)&lt;=&gt;(n and k)==k$ 小根堆，确定树的结构，求不同树的个数：$\frac{n!}{\prod_{x=1}^n sz[x]}$ 51.区间可减（求和）比区间合并/区间可加性（min/max）条件更强 猫树只需要满足区间合并，不修改 $$f\big|\bigcup_{i=1}^nAi \big|=\sum{i=1}^nf\big|Ai\big|-\sum{1&lt;=i&lt;j&lt;=n}f\big|A_i\bigcap A_j\big|+…+(-1)^{n-1}f\big|A_1\bigcap…\bigcap A_n\big|$$ 53.随机1到i-1作为父亲的树：平均深度O(logn)，期望最大深度logn prufer编码生成树：期望最大深度O(sqrt(n))，期望平均深度O(logn) 54.斯特林数/卡特兰数/划分数怎么用： 卡特兰数：（以下都是等价的） 通项公式1：$Cn=\dfrac{1}{n+1}{C}{2n}^n={C}{2n}^n-{C}{2n}^{n-1}$ 通项公式2：$Cn=\dfrac{1}{n+1}\sum\limits{i=0}^n\left({C}n^i\right)^2$ 递推公式1：$C{n+1}=\dfrac{2(2n+1)}{n+2}C_n,C0=1$ 递推公式2：$C{n+1}=\sum\limits_{i=0}^nCiC{n-i},C0=1$ 第二类斯特林数： 通项公式：$S(n,k)=\frac{1}{k!}\sum{j=0}^{k}(-1)^{k-j}(^k_j)j^n$ 递推公式：$S(n+1,k)=k*S(n,k)+S(n,k-1)$ 划分数： 递推公式：$p(n,k)=p(n-k,k)+p(n-1,k-1)$ 55.对一堆询问len[l,r]=k，区间只满足可加性，O(n)做法（在线）：在k的倍数的位置划分，向前向后维护一段，每个询问必定过一个划分位置 56.对一堆询问，不存在区间包含，即l1&lt;=l2&lt;=l3&lt;=l4…,r1&lt;=r2&lt;=r3&lt;=r4…，区间只满足可加性，O(n)做法（离线）：以r1为划分向前向后做，这样可以处理所有过r1的询问，当li&gt;r1的时候，每次向左扫只需要扫到上次的r，这样每个点只会从左边和右边各扫一遍 57.可持久化线段树的区间修改：要开2log的空间（因为每层访问最外边的两个节点），标记永久化，每次经过都加上标记即可 58.启发式合并复杂度O(nlognlogn)每个数只会被插入logn次 splay/treap/fhq treap合并是nlogn 启发式合并的空间怎么释放?没有浪费空间，只是更新指针所指的位置 59.线段树合并：一开始n个位置，nlogn个节点，时间复杂度nlogn（每dfs一次就减少一个点，一共就一开始的nlogn个点，合并过程中不开新点了），空间复杂度nlogn 60.区间加等差数列，区间求max：分块（线段树不可做） 区间加等差数列，区间求：线段树 61. 123456for(int i=0;i&lt;n*2;i++) for(int j=0;j&lt;=n;j++) &#123; f[i+1][j][0]=(f[i][j][0]+f[i][j][1])%mo; if(lk[i+1]) f[i+1][j+1][1]=f[i][j][0]; &#125; 怎么ntt？每个链用组合数算，ntt合并 62.S可简单图化：Havel–Hakimi algorithm/Erdős–Gallai theorem HH是贪心，复杂度O(n^2logn) EG是结论（？），复杂度O(n)，？ 63.找一个图的所有环？tan90 64.点上打标记：(1)子树和 (2)到根的和 65.n^3/64找最短路（边权为1..） bitset lowbit？ 66.取模，除0：记录有多少个0，每次减 67.答案比状态小可以用答案作为状态 68.决策单调性： 1)dp值已知？？分段，先求前面再求后面 12345678solve(l,r,opt_l,opt_r)&#123; if(l+1&gt;=r) return; mid=(l+r)/2; for()//找到opt_mid solve(l,mid,opt_l,opt_mid); solve(mid,r,opt_mid,opt_r);&#125; 2)从1到n依次刷表 栈维护每个决策点和左右端点 69.区间平方和满足四边形不等式（能转化成区间平方之类的大概有可能满足吧） 70.include要1M空间，不用的空间可能会被优化掉(O2?) 71.子集和问题（一些数的和能否为x） sum(a)&lt;=n，共O(sqrt(n))个不同的数，O(nsqrtn)的多重背包（多重背包不能压位） 或者把sqrtn个东西二进制拆分，变成01背包，变成O(sqrtnlogn)，然后bitset优化，O(nsqrtnlogn/w) 对一开始的物品： 2x+1个a =&gt; a，x个2a 2x+2个a =&gt; a，a，x个2a 这样每个物品不超过2个，变成sqrtn个不同数的01背包 复杂度O(nsqrtn/w) 72.V 1e9 n 100 体积 ai2^bi (a&lt;=10,b&lt;=30) 价值 ci (&lt;=1e9) bi从大到小排序 dp(i,j)表示到第i个物品，实际容量还有j2^bi+V%2^bi j最大到sum(ai) (记到1000) 改一下dp dp(w,j)表示到第w个物品，实际容量还有j*2^w+V%2^w 例题： 1（梦幻岛宝珠） 2体积小的，物品少，V 1e18，完全背包。完全背包的物品可以变成ai2^0,ai2^1… 73.石子合并：有决策单调性，O(n^2) 先按长度dp，每层转移是O(n) 74.合并同余方程： 互质：中国剩余定理 不互质：两两合并（就是解二元一次方程。）推导 75.二次剩余不要搞错： $x^2=n(mod p)$对每个确定的n在[0,p)上只有一个解 对(p-1)/2+1个n有解 76.((~0)&gt;&gt;1)=-1 ((~0u)&gt;&gt;1)=INT_MAX -x=2^32-x a^b&lt;=a+b a^b+2(a&amp;b)=a+b a^b=a+b &lt;=&gt; a&amp;b=0 或的单调性 (x|y)&gt;=x 77.bitset解决5维偏序（可以解决k维偏序，复杂度：预处理O(kn)，每次询问O(ksqrtn)） 78.动态加边，求两点路径和？nlogn，启发式合并 79.给定 n 个数 a[1..n]，求有几个子集满足：子集的异或和等于这个子集的AND 80.double的二分姿势：不能卡精度，只能卡次数 while(r-l&gt;eps)是错的。。 for(次数)（推荐写法） while会停不下来（因为mid=(l+r)/2==l） 1234567 l=1;r=123456789123.123;while(r-l&gt;eps)&#123; mid=(l+r)/2; l=mid; printf("%.10f %.10f %.10f\n",l,r,mid);&#125; [-A,A]的外接圆的半径是A^2级别的 二分用sqrt(l*r)可以次数更少。(l,r&gt;0) 函数对long doulbe有单独的版本 89.$[\frac {[\frac{a}{b}]}{c}]=[\frac{a}{bc}]$ 画画线段就能证明 90.knight’s tour： nn中，n&gt;=5存在哈密尔顿路径，n&gt;=6且n为偶数存在哈密尔顿回路（证明见wiki） nm中，只要min(n,m)&gt;=5则存在哈密尔顿路径，无证明（搜索证明。。 91.double的三分姿势 12345//注意卡次数//mid1=l+(r-l)/3;//mid2=l+(r-l)/3*2;mid1=(2*l+r)/3,mid2=(l+2*r)/3;//2种结果一样的三分方式，这种时间竟然是注释掉的那种的1/4，神奇 int的三分姿势 12345while(l+9&lt;=r)&#123; ll=l+(r-l)/3; rr=r-(r-l)/3;&#125;for(l to r) update(ans); 92.常见npc： 哈密尔顿回路（哈密尔顿路径不是，但是依旧没有多项式算法） tsp 图同构：图G1是否与图G2同构？子图同构：图G1是否与图G2的任一子图同构？子图同构问题是NPC，而图同构问题一般认为不是P也不是NPC问题，虽然它明显是一个NP问题。这是一个典型被认为很难却还不是NPC问题的例子。 3sat及以上 背包 一般图染色 子集和问题 全排列问题 n皇后问题常见np-hard： 求图的最长路 一般图最大团 一般图最大独立集常见np： 拓扑图计数 93.(a|b)+(a&amp;b)=a+b 94.c++03的东西： 123timeb tim;ftime(&amp;tim);srand(tim.time*1000+tim.millitm); 95.set s; 重载方式： 1.直接重载pair的比较方式 在全局写bool operator &lt; (const pii &amp;a,const pii &amp;b) 2.在这个set里面重载 struct cmp{ bool operator () (const pii &amp;a,const pii &amp;b){ } } 96.a&lt;b，b&lt;c，如果能推出a&lt;c 97.()后的const表示当前结构体，什么时候要用？库函数（不修改this） friend什么时候要用？有private，和写外面一样 98.模拟退火 爬山（凸函数，也就是只有一座山峰） 99.要对10以内的c敏感 from dtx 100.局部到整体 101.全序关系才能排序，偏序关系只能拓扑排序 102.dijk用堆优化mlogn 用桶优化O(n+m+最大权值)，用指针维护（权值递增） /：根目录/home/noilinux/或~/：当前用户的目录ls：显示当前列表ls + 路径：显示路径下的列表cd + 路径：/home（绝对路径） 或 Desktop（相对路径）或 cd ..（返回上一层）/./：当前路径/../：上层路径mkdir：创建文件夹rm -r + 目录：删除当前目录及里面所有的东西（-r 递归地删）sf_sharefold和/不是同级的：在/下的某个文件夹内touch + 文件名：（创建文件）修改文件的修改日期（没有就创建）cat + 文件 + 文件：（显示文件内容）将几个文件的内容显示出来mv + 文件 + 路径：将文件移动到路径下cp + 文件 + 路径：将文件复制到路径下将文件复制到文件：1.cp + 文件 + 文件2.cat + 文件 + &gt;文件mv和cp 都要加-r才能对文件夹操作;可以隔开两个命令echo或printf：输出\;可以输出;“”可以把东西搞成字符串echo + 信息 + &gt;文件：将信息覆盖到文件echo + 信息 + &gt;&gt;文件：将信息追加到文件后0：stdin1：stdout2：stderrctrl+c：退出当前命令ctrl+z：将当前命令压到栈中fg：将命令从栈中弹出ctrl+d：EOFdiff + 文件 + 文件：相同为0，不同不为0g++ -Wall：显示所有warning -O0 -O1 -O2 -O3 -Ofast：加速 -g：生成给调试器用的信息 -lm：链接数学库（不加也行） -o + 文件：输出到指定文件 -std=c++11 -Wl,–stack=/栈的大小，单位字节/bash + a.sh：用bash运行文件 104.+-1rmq：按len=logn/2分块，对整块作st表，复杂度O(n) 对块内进行预处理，本质不同的块一共O(2^len)=O(sqrt(n))个，对这些块的每个[l,r]都暴力预处理，复杂度O(sqrtloglog) 查询O(1)105.dag中求： 1)一个点能到的点数：O(nn/32)，bitset优化暴力 2)拓扑序的个数：状压，O(2^nn) 106.%d–&gt; for int %u–&gt; for unsigned int %ld–&gt; for long int %lu–&gt; for unsigned long int %lld–&gt; for long long int %llu–&gt; for unsigned long long int 107.char[][]（一堆字符串）进行排序：新开一个位置数组，对这个数组排序 108.namespace是个好东西，在namespace里面、函数外面定义的变量还是全局的，除了可以重变量名没啥特别。 109.字符串hash冲突的概率：使用次数^2/模数大小（和生日悖论差不多？），要双hash 110.#define rep(形参，形参，…) 替换列表 例如： #define rep(i,x,y) for(int i=(x);i&lt;=(y);++i)//记得打括号，不然传1&lt;&lt;n就挂了 111.二维数组传参(int a[x][y])或者(int a[][y])，只有第一维可以不写！ 112.rand()是通过线性递推 windows下模32768 rand()%(2^x)有周期，大概1e5 更好的随机数是 mt19937 mt(/随机数种子/); 设置种子的第二种方法： mt.seed(/随机数种子/); 在里面（c++11） mt19937 mt(time(0)); mt();//返回一个随机数 mt.min();//mt的最小值0 mt.max();//mt的最大值2^32-1 mt19937_64 mt(time(0)); mt(); mt.max();//最大值为2^64-1 注意u和llu输出 113.dijk不用vis每次判断和最小值是否相同即可，pq写大根堆也会得到正确的结果（但是会t） 114.高斯消元复杂度：nmmin(n,m) 115.邻接表判重边： 116.k叉哈夫曼树可以O(n)构造： 桶排，然后用两个队列 k叉哈夫曼树的dp f[i][j]表示已经做完了前i个元素，还空出j个叶子节点的最小代价 f[0][1]=0,其他为inf 第二维最大为大于n的2的幂 $f[i+1][j-1]=min(f[i][j]),f[i][j*k]=min(f[i][j]+\sum_{p=i+1}^{n}a[p])$ $ans=min(f[n][p])(0&lt;=p&lt;n)$ #458. 我才不是萝莉控呢 这题和哈夫曼树的dp有类似 但是有些不同 将dp的含义改成f[i][j]表示做完前i-1个元素即可 要求的答案也是f[n][1]，因为最后放完一定没有空节点 117.tr1是c++03的using namespace tr1;（在using std之后加） 头文件如#include 118.保序回归： 将数列a调整成单调不降的最小代价，a调整为b的代价为|a-b| 调整为单调上升则对ai-=i 原因： 维护的每个点可以到达的最低距离 只有当再次小于最低距离后才要继续更新答案 做法出处：http://codeforces.com/blog/entry/47094?#comment-315161 写的好看的dp：https://blog.csdn.net/Vectorxj/article/details/78793739 仔细思考发现，考虑函数图像并不能很好的解释（或者我太弱了 本质还是维护到达的最低距离 但是原来的理解有些偏差 记f[i]表示考虑[1,i]的答案 那么f[i]是单调不降的 （注意题解中的fi[x]是下凸的，没有斜率为非负的线段） pq中存的是不改变当前答案的情况下，能变成的最低的情况 因为fi[opt[i]]=fi-1[opt[i-1]]+opt[i-1]-a[i] 所以尽量把opt[i]变小，就是把大的往下拉（注意拉完之后并不是合法的序列，只是保证有1.满足答案2.最大值是opt[i] 的序列） 当所有opt[i]都变小以后，最大值就变小了 反正就是不太容易理解 cjq太强了 cf的做法是维护折线 维护折线一般要维护横纵坐标或者斜率什么的 这题只需要维护横坐标和斜率 一个点和下一个点的斜率为严格比这个点大的点的个数 因为斜率的变化只有+-1 可以通过加点和删点来维护 听完sr的讲解整个人神清气爽，他的题目是树上的，更复杂。 链的做法的解释：f[i][j]表示前i个数变成单调不降，第i个数为j的最小代价g[i][j]表示前i个数变成单调不降，第i个数小于等于j的最小代价f[i][j]=g[i-1][j]+abs(a[i]-j)g[i][j]=min(g[i][j-1],f[i][j])（g是f的前缀最小值）sr称这是用函数去表示状态对每个特定的i，都能画出j-f[i][j]和j-g[i][j]的函数图像这类函数有两个特点：1.函数均是下凸壳2.函数每一段的斜率都是整数（横坐标的差是1）f函数最后一段的斜率是1，g函数最后一段的斜率是0通过维护每个横坐标上的数量来维护斜率比如f函数的点数是1，2，则斜率是-2，-1，1下面的代码维护了g函数（维护f也行，但是这题维护g比较方便）新加入的点如果小于最大，则斜率一段-1一段+1那么最大的数量-1，新加入的点+2因为f[i][j]最小（也就是f函数中斜率为0）的就是答案，比最大的值小的点加入要把它改成最大，这个差贡献到答案新加入的点如果大于最大，则最大点之前斜率-1链的代码：12345678910 priority_queue&lt;int&gt; q; q.push(a[1]); for(int i=2;i&lt;=half_n;++i)&#123; if(q.top()&gt;a[i])&#123; ans+=q.top()-a[i]; q.pop(); q.push(a[i]); &#125; q.push(a[i]);&#125; 树上的做法：f[i][j]表示以i为根的子树中，i向fa[i]连j的边的最小代价g[i][j]表示以i为根的子树中，i向fa[i]连大于等于j的边的最小代价f[i][j]=sum(g[son[i]][j])+abs(a[i]-j)g[i][j]=min(g[i][j+1],f[i][j])（g是f的后缀最小值）也满足链中的性质：1.函数均是下凸壳2.函数每一段的斜率都是整数（横坐标的差是1）还是维护堆（这次是小根堆）但是多了sum操作，所以使用可并堆维护g（合并的话就是把堆合并，因为斜率对应的点数也是可加的）还要维护g在最左边的纵坐标（这是答案，合并的时候直接加） 119.vector()表示空vector 120.一般图四元环：n^3/32 二分图四元环：msqrt(m)，分大小点 12345678for (int i = 1; i &lt;= n; i++) &#123; f[i] = a[i];&#125;for (int i = 1; i &lt;= n; i++) &#123; for (int j = 2 * i; j &lt;= n; j += i) &#123; f[j] -= f[i]; &#125;&#125; 当a[i]=i时，f[i]=\phi(i)猜一波结论：$$when\ \varphi(i)\neq0,f[i]=(\sum{j|i}\mu(j)\cdot a[j])\cdot\mu(i)$$$$when\ \varphi(i)=0,t=\text{product of every prime factor of i},f[i]=(\sum{j|t}\mu(j)\cdot a[j\cdot\frac{i}{t}])\cdot \mu(t)$$ 122.ctrl+m：把dev分成左右两个窗口 123.f[i]表示二进制下是i的超集的数的个数 先枚举某一位j，再枚举i（从小到大和从大到小都可以，因为每一位只有0/1） f[i^(1&lt;]]></content>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2278 [HNOI2003]操作系统]]></title>
    <url>%2F2018%2F04%2F28%2Fluogu2278%20%5BHNOI2003%5D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[12345678好久没写重载了less需要重载小于号greater需要重载大于号stl中使用结构体会使成员变量变成private，导致只可访问，不可修改所以成员函数要加constpriority_queue：从小到大排序后每次取最后一个sort/set：从小到大排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;int id,t1,t2,a,pre;struct node&#123; int x,y,z; inline bool operator &lt; (const node &amp;a) const&#123; if(x!=a.x) return x&lt;a.x; return y&gt;a.y; &#125;&#125;;priority_queue&lt;node&gt; q;int main()&#123; while(scanf(&quot;%d&quot;,&amp;id)!=EOF)&#123; t1=read();t2=read();a=read(); if(q.empty())&#123; q.push((node)&#123;a,id,t2&#125;); pre=t1; &#125; else&#123; while(!q.empty()&amp;&amp;pre+q.top().z&lt;=t1)&#123; pre+=q.top().z; printf(&quot;%d %d\n&quot;,q.top().y,pre); q.pop(); &#125; if(!q.empty()&amp;&amp;pre&lt;t1)&#123; node t=q.top(); q.pop(); t.z-=t1-pre; q.push(t); &#125; q.push((node)&#123;a,id,t2&#125;); pre=t1; &#125; &#125; while(!q.empty())&#123; pre+=q.top().z; printf(&quot;%d %d\n&quot;,q.top().y,pre); q.pop(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luoguP2149 [SDOI2009]Elaxia的路线]]></title>
    <url>%2F2018%2F04%2F28%2FluoguP2149%20%5BSDOI2009%5DElaxia%E7%9A%84%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[1234567显然他们只会在一段连续的点上相遇先求出每个点是否在最短路上然后暴力枚举起点和终点这样就a了但过不了bzoj上提供的额外两组数据因为两个点在最短路上不代表它们在同一条最短路上还要判断它们的距离差是否相等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1508;int n,m;int x[3],y[3];int u,v,l;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[N*N*2];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[3][N];int q[N],he,ta;bool inq[N],ina[3][N];int ans;inline void spfa(int t)&#123; memset(inq,0,sizeof(inq)); dis[t][x[t]]=0; he=1;ta=2; q[1]=x[t]; inq[x[t]]=1; while(he!=ta)&#123; int x=q[he]; inq[x]=0; ++he; if(he==1503) he=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[t][e[i].to]&gt;dis[t][x]+e[i].f)&#123; dis[t][e[i].to]=dis[t][x]+e[i].f; if(!inq[e[i].to])&#123; q[ta]=e[i].to; inq[e[i].to]=1; ++ta; if(ta==1503) ta=1; &#125; &#125; &#125; &#125; he=1;ta=2; q[1]=y[t]; inq[y[t]]=1; while(he!=ta)&#123; int x=q[he]; ++he; ina[t][x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[t][x]-e[i].f==dis[t][e[i].to])&#123; if(!inq[e[i].to])&#123; q[ta]=e[i].to; inq[e[i].to]=1; ++ta; &#125; &#125; &#125; &#125;&#125;int main()&#123; memset(dis,0x3f,sizeof(dis)); n=read();m=read();x[1]=read();y[1]=read();x[2]=read();y[2]=read(); for(int i=1;i&lt;=m;++i)&#123; u=read();v=read();l=read(); addedge(u,v,l); addedge(v,u,l); &#125; spfa(1); spfa(2); for(int i=1;i&lt;=n;++i)&#123; if(ina[1][i]&amp;&amp;ina[2][i])&#123; for(int j=1;j&lt;=n;++j)&#123; if(i!=j&amp;&amp;ina[1][j]&amp;&amp;ina[2][j]&amp;&amp;abs(dis[1][i]-dis[1][j])==abs(dis[2][i]-dis[2][j]))&#123; ans=max(ans,abs(dis[1][i]-dis[1][j])); &#125; &#125; &#125; &#125; printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1345 [USACO5.4]奶牛的电信Telecowmunication]]></title>
    <url>%2F2018%2F04%2F28%2Fluogu1345%20%5BUSACO5.4%5D%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1Telecowmunication%2F</url>
    <content type="text"><![CDATA[12345678910111213看上去像网络流写了一发80分还以为小细节挂了其实整个程序都是错的。。是求最小的割点数转化成求最小的割边数（最小割）每个点拆成两个点i - 1 - i&apos;原图中的边连INF这样只会割掉1的边相当于割掉了这个点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108,M=608;int n,m,s,t;int x,y;int nume=1,head[N*2],cur[N*2];struct node&#123; int to,nxt,f;&#125;e[M*4+N*2];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;int dis[N*2];int q[N*2],he,ta;inline bool bfs()&#123; memset(dis,0,sizeof(dis)); dis[s]=1; he=1;ta=2; q[1]=s; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=1;i&lt;=n*2;++i) cur[i]=head[i]; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int main()&#123; n=read();m=read();s=read();t=read(); s+=n; for(int i=1;i&lt;=n;++i)&#123; if(i!=s-n&amp;&amp;i!=t)&#123; addedge(i,n+i,1); &#125; &#125; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read(); addedge(x+n,y,INT_MAX); addedge(y+n,x,INT_MAX); &#125; printf(&quot;%d&quot;,dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1993 小K的农场]]></title>
    <url>%2F2018%2F04%2F27%2Fluogu1993%20%E5%B0%8FK%E7%9A%84%E5%86%9C%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617一眼差分约束，一眼数据1e4一看题解，全写的是spfa_dfs！？spfa还能用dfs？吓得我赶紧去负环的模板题看题解也是dfs？不过高级的管理员改了数据把复杂度没有保证的dfs全部hack了只能愉快的写bfs啦直接写的话会t新技能：保存每个点的最短路径长度，&gt;n说明出现负环这样写开O2才能a掉但是数据太弱&gt;15就认为出现负环这样就0ms过了顺便做了一下负环的模板题发现记录路径长度比记录进队次数慢。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=10008;int n,m,t;int x,y,z;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[N];int q[N],he,ta;bool inq[N];int tim[N];inline bool spfa()&#123; for(int i=1;i&lt;=n;++i)&#123; q[i]=i; inq[i]=1; tim[i]=1; &#125; he=1;ta=n+1; while(he!=ta)&#123; int x=q[he]; inq[x]=0; ++he; if(he==10003) he=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; //++tim[e[i].to]; //if(tim[e[i].to]&gt;n) return 0; tim[e[i].to]=tim[x]+1; if(tim[e[i].to]&gt;n)&#123;//&gt;15也可以，0ms return 0; &#125; if(!inq[e[i].to])&#123; q[ta]=e[i].to; inq[e[i].to]=1; ++ta; if(ta==10003) ta=1; &#125; &#125; &#125; &#125; return 1;&#125;int main()&#123; n=read();m=read(); while(m--)&#123; t=read(); if(t==1)&#123; x=read();y=read();z=read(); addedge(x,y,-z); &#125; else if(t==2)&#123; x=read();y=read();z=read(); addedge(y,x,z); &#125; else&#123; x=read();y=read(); addedge(x,y,0); addedge(y,x,0); &#125; &#125; if(spfa())&#123; puts(&quot;Yes&quot;); &#125; else&#123; puts(&quot;No&quot;); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=4008,M=6008;int T;int n,m;int x,y,z;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[M&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[N],q[N],he,ta,tim[N];bool inq[N];inline void spfa()&#123; for(int i=1;i&lt;=n;++i)&#123; dis[i]=0; inq[i]=1; q[i]=i; tim[i]=1; &#125; he=1;ta=n+1;//队列的ta要+1 while(he!=ta)&#123; int x=q[he]; inq[x]=0; ++he; if(he==4003) he=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; ++tim[e[i].to]; /*if(tim[e[i].to]&gt;n)&#123; puts(&quot;YE5&quot;); return; &#125;*/ tim[e[i].to]=tim[x]+1; if(tim[e[i].to]&gt;min(2500,n))&#123; puts(&quot;YE5&quot;); return; &#125; if(!inq[e[i].to])&#123; q[ta]=e[i].to; inq[e[i].to]=1; ++ta; if(ta==4003) ta=1; &#125; &#125; &#125; &#125; puts(&quot;N0&quot;); return;&#125;int main()&#123; T=read(); while(T--)&#123; nume=0; memset(head,0,sizeof(head)); n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); if(z&gt;=0)&#123; addedge(y,x,z); &#125; &#125; spfa(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1268 树的重量]]></title>
    <url>%2F2018%2F04%2F25%2Fluogu1268%20%E6%A0%91%E7%9A%84%E9%87%8D%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617好题啊看了半天不会去看题解妙啊还是不明白重点就是不知道为什么树的重量是一定的而做法就相当于证明一样每加上去一个点，相当于从一对点的路径上伸出来一条边看题解时发现一个有趣的结论根据两两点之间的最短距离建出的树应该都是同构的（边权均非负）然而应该不是同构每次选最小的值w(i,j)若存在k，使得w(i,k)+w(k,j)=w(i,j)，则i,j之间不需要连边否则就连边这样应该可以确定一个边数最少的图在这个图上填一写较大的边（大于两端点的最短距离）不会产生任何影响 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=38;int n;int a[N][N];int ans,tmp;int main()&#123; while(1)&#123; n=read(); if(!n) return 0; memset(a,0,sizeof(a)); for(int i=1;i&lt;n;++i)&#123; for(int j=i+1;j&lt;=n;++j)&#123; a[i][j]=read(); a[j][i]=a[i][j]; &#125; &#125; ans=a[1][2]; for(int i=3;i&lt;=n;++i)&#123; tmp=INT_MAX; for(int j=1;j&lt;i;++j)&#123; for(int k=j+1;k&lt;i;++k)&#123; tmp=min(tmp,(a[j][i]+a[k][i]-a[j][k])/2); &#125; &#125; ans+=tmp; &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十年磨一剑]]></title>
    <url>%2F2018%2F04%2F23%2F%E5%85%BB%E6%B0%94%2F</url>
    <content type="text"><![CDATA[18/4/23开始|序号|质数|平方数|立方数||:-:|:-:|:-:|:-:|| 1| 2| 1| 1|| 2| 3| 4| 8|| 3| 5| 9| 27|| 4| 7| 16| 64|| 5| 11| 25| 125|| 6| 13| 36| 216|| 7| 17| 49| 343|| 8| 19| 64| 512|| 9| 23| 81| 729|| 10| 29| 100| 1000|| 11| 31| 121| 1331|| 12| 37| 144| 1728|| 13| 41| 169| 2197|| 14| 43| 196| 2744|| 15| 47| 225| 3375|| 16| 53| 256| 4096|| 17| 59| 289| 4913|| 18| 61| 324| 5832|| 19| 67| 361| 6859|| 20| 71| 400| 8000|| 21| 73| 441| 9261|| 22| 79| 484| 10648|| 23| 83| 529| 12167|| 24| 89| 576| 13824|| 25| 93| 625| 15625|| 26| 101| 676| 17576|| 27| 103| 729| 19683|| 28| 107| 784| 21952|| 29| 109| 841| 24389|| 30| 113| 900| 27000|| 31| 127| 961| 29791|| 32| 131| 1024| 32768|| 33| 137| 1089| 35937|| 34| 139| 1156| 39304|| 35| 149| 1225| 42875|| 36| 151| 1296| 46656|| 37| 157| 1369| 50653|| 38| 163| 1444| 54872|| 39| 167| 1521| 59319|| 40| 173| 1600| 64000|| 41| 179| 1681| 68921|| 42| 181| 1764| 74088|| 43| 191| 1849| 79507|| 44| 197| 1936| 85184|| 45| 197| 2025| 91125|| 46| 199| 2116| 97336|| 47| 211| 2209| 103823|| 48| 223| 2304| 110592|| 49| 227| 2401| 117649|| 50| 229| 2500| 125000|| 51| 233| 2601| 132651|| 52| 239| 2704| 140608|| 53| 241| 2809| 148877|| 54| 251| 2916| 157464|| 55| 257| 3025| 166375|·戒 ·爱 ·控 ·主|序号|质数|平方数|立方数||:-:|:-:|:-:|:-:|| 56| 263| 3136| 175616|| 57| 269| 3249| 185193|| 58| 271| 3364| 195112|| 59| 277| 3481| 205379|| 60| 281| 3600| 216000|| 61| 283| 3721| 226981|| 62| 293| 3844| 238328|火箭发射！！|序号|质数|平方数|立方数||:-:|:-:|:-:|:-:|| 63| 307| 3969| 250047|| 64| 311| 4096| 262144|| 65| 313| 4225| 274625|| 66| 317| 4356| 287496|| 67| 331| 4489| 300763|| 68| 337| 4624| 314432|| 69| 347| 4761| 328509|| 70| 349| 4900| 343000|| 71| 353| 5041| 357911|| 72| 359| 5184| 373248|| 73| 367| 5329| 389017|| 74| 373| 5476| 405224|| 75| 379| 5625| 421875|| 76| 383| 5776| 438976|| 77| 389| 5929| 456533|| 78| 397| 6084| 474552|| 79| 401| 6241| 493039|| 80| 409| 6400| 512000|| 81| 419| 6561| 531441|| 82| 421| 6724| 551368|| 83| 431| 6889| 571787|| 84| 433| 7056| 592704|| 85| 439| 7225| 614125|| 86| 443| 7396| 636056|| 87| 449| 7569| 658503|| 88| 457| 7744| 681472|| 89| | | || 90| | | || 91| | | || 92| | | || 93| | | || 94| | | || 95| | | || 96| | | || 97| | | || 98| | | || 99| | | || 100| | | || 101| | | || 102| | | || 103| | | || 104| | | || 105| | | || 106| | | || 107| | | || 108| | | || 109| | | || 110| | | || 111| | | || 112| | | || 113| | | || 114| | | || 115| | | || 116| | | || 117| | | || 118| | | || 119| | | || 120| | | || 121| | | || 122| | | || 123| | | || 124| | | || 125| | | || 126| | | || 127| | | || 128| | | || 129| | | || 130| | | || 131| | | || 132| | | || 133| | | || 134| | | || 135| | | || 136| | | || 137| | | || 138| | | || 139| | | || 140| | | || 141| | | || 142| | | || 143| | | || 144| | | || 145| | | || 146| | | || 147| | | || 148| | | || 149| | | || 150| | | || 151| | | || 152| | | || 153| | | || 154| | | || 155| | | || 156| | | || 157| | | || 158| | | || 159| | | || 160| | | || 161| | | || 162| | | || 163| | | || 164| | | || 165| | | || 166| | | || 167| | | || 168| | | || 169| | | || 170| | | || 171| | | || 172| | | || 173| | | || 174| | | || 175| | | || 176| | | || 177| | | || 178| | | || 179| | | || 180| | | || 181| | | || 182| | | || 183| | | || 184| | | || 185| | | || 186| | | || 187| | | || 188| | | || 189| | | || 190| | | || 191| | | || 192| | | || 193| | | || 194| | | || 195| | | || 196| | | || 197| | | || 198| | | || 199| | | || 200| | | || 201| | | || 202| | | || 203| | | || 204| | | || 205| | | || 206| | | || 207| | | || 208| | | || 209| | | || 210| | | || 211| | | || 212| | | || 213| | | || 214| | | || 215| | | || 216| | | || 217| | | || 218| | | || 219| | | || 220| | | || 221| | | || 222| | | || 223| | | || 224| | | || 225| | | || 226| | | || 227| | | || 228| | | || 229| | | || 230| | | || 231| | | || 232| | | || 233| | | || 234| | | || 235| | | || 236| | | || 237| | | || 238| | | || 239| | | || 240| | | || 241| | | || 242| | | || 243| | | || 244| | | || 245| | | || 246| | | || 247| | | || 248| | | || 249| | | || 250| | | || 251| | | || 252| | | || 253| | | || 254| | | || 255| | | || 256| | | || 257| | | || 258| | | || 259| | | || 260| | | || 261| | | || 262| | | || 263| | | || 264| | | || 265| | | || 266| | | || 267| | | || 268| | | || 269| | | || 270| | | || 271| | | || 272| | | || 273| | | || 274| | | || 275| | | || 276| | | || 277| | | || 278| | | || 279| | | || 280| | | || 281| | | || 282| | | || 283| | | || 284| | | || 285| | | || 286| | | || 287| | | || 288| | | || 289| | | || 290| | | || 291| | | || 292| | | || 293| | | || 294| | | || 295| | | || 296| | | || 297| | | || 298| | | || 299| | | || 300| | | || 301| | | || 302| | | || 303| | | || 304| | | || 305| | | || 306| | | || 307| | | || 308| | | || 309| | | || 310| | | || 311| | | || 312| | | || 313| | | || 314| | | || 315| | | || 316| | | || 317| | | || 318| | | || 319| | | || 320| | | || 321| | | || 322| | | || 323| | | || 324| | | || 325| | | || 326| | | || 327| | | || 328| | | || 329| | | || 330| | | || 331| | | || 332| | | || 333| | | || 334| | | || 335| | | || 336| | | || 337| | | || 338| | | || 339| | | || 340| | | || 341| | | || 342| | | || 343| | | || 344| | | || 345| | | || 346| | | || 347| | | || 348| | | || 349| | | || 350| | | || 351| | | || 352| | | || 353| | | || 354| | | || 355| | | || 356| | | || 357| | | || 358| | | || 359| | | || 360| | | || 361| | | || 362| | | || 363| | | || 364| | | || 365| | | || 366| | | || 367| | | || 368| | | || 369| | | || 370| | | || 371| | | || 372| | | || 373| | | || 374| | | || 375| | | || 376| | | || 377| | | || 378| | | || 379| | | || 380| | | || 381| | | || 382| | | || 383| | | || 384| | | || 385| | | || 386| | | || 387| | | || 388| | | || 389| | | || 390| | | || 391| | | || 392| | | || 393| | | || 394| | | || 395| | | || 396| | | || 397| | | || 398| | | || 399| | | || 400| | | || 401| | | || 402| | | || 403| | | || 404| | | || 405| | | || 406| | | || 407| | | || 408| | | || 409| | | || 410| | | || 411| | | || 412| | | || 413| | | || 414| | | || 415| | | || 416| | | || 417| | | || 418| | | || 419| | | || 420| | | || 421| | | || 422| | | || 423| | | || 424| | | || 425| | | || 426| | | || 427| | | || 428| | | || 429| | | || 430| | | || 431| | | || 432| | | || 433| | | || 434| | | || 435| | | || 436| | | || 437| | | || 438| | | || 439| | | || 440| | | || 441| | | || 442| | | || 443| | | || 444| | | || 445| | | || 446| | | || 447| | | || 448| | | || 449| | | || 450| | | || 451| | | || 452| | | || 453| | | || 454| | | || 455| | | || 456| | | || 457| | | || 458| | | || 459| | | || 460| | | || 461| | | || 462| | | || 463| | | || 464| | | || 465| | | || 466| | | || 467| | | || 468| | | || 469| | | || 470| | | || 471| | | || 472| | | || 473| | | || 474| | | || 475| | | || 476| | | || 477| | | || 478| | | || 479| | | || 480| | | || 481| | | || 482| | | || 483| | | || 484| | | || 485| | | || 486| | | || 487| | | || 488| | | || 489| | | || 490| | | || 491| | | || 492| | | || 493| | | || 494| | | || 495| | | || 496| | | || 497| | | || 498| | | || 499| | | || 500| | | || 501| | | || 502| | | || 503| | | || 504| | | || 505| | | || 506| | | || 507| | | || 508| | | || 509| | | || 510| | | || 511| | | || 512| | | || 513| | | || 514| | | || 515| | | || 516| | | || 517| | | || 518| | | || 519| | | || 520| | | || 521| | | || 522| | | || 523| | | || 524| | | || 525| | | || 526| | | || 527| | | || 528| | | || 529| | | || 530| | | || 531| | | || 532| | | || 533| | | || 534| | | || 535| | | || 536| | | || 537| | | || 538| | | || 539| | | || 540| | | || 541| | | || 542| | | || 543| | | || 544| | | || 545| | | || 546| | | || 547| | | || 548| | | || 549| | | || 550| | | || 551| | | || 552| | | || 553| | | || 554| | | || 555| | | || 556| | | || 557| | | || 558| | | || 559| | | || 560| | | || 561| | | || 562| | | || 563| | | || 564| | | || 565| | | || 566| | | || 567| | | || 568| | | || 569| | | || 570| | | || 571| | | || 572| | | || 573| | | || 574| | | || 575| | | || 576| | | || 577| | | || 578| | | || 579| | | || 580| | | || 581| | | || 582| | | || 583| | | || 584| | | || 585| | | || 586| | | || 587| | | || 588| | | || 589| | | || 590| | | || 591| | | || 592| | | || 593| | | || 594| | | || 595| | | || 596| | | || 597| | | || 598| | | || 599| | | || 600| | | || 601| | | || 602| | | || 603| | | || 604| | | || 605| | | || 606| | | || 607| | | || 608| | | || 609| | | || 610| | | || 611| | | || 612| | | || 613| | | || 614| | | || 615| | | || 616| | | || 617| | | || 618| | | || 619| | | || 620| | | || 621| | | || 622| | | || 623| | | || 624| | | || 625| | | || 626| | | || 627| | | || 628| | | || 629| | | || 630| | | || 631| | | || 632| | | || 633| | | || 634| | | || 635| | | || 636| | | || 637| | | || 638| | | || 639| | | || 640| | | || 641| | | || 642| | | || 643| | | || 644| | | || 645| | | || 646| | | || 647| | | || 648| | | || 649| | | || 650| | | || 651| | | || 652| | | || 653| | | || 654| | | || 655| | | || 656| | | || 657| | | || 658| | | || 659| | | || 660| | | || 661| | | || 662| | | || 663| | | || 664| | | || 665| | | || 666| | | || 667| | | || 668| | | || 669| | | || 670| | | || 671| | | || 672| | | || 673| | | || 674| | | || 675| | | || 676| | | || 677| | | || 678| | | || 679| | | || 680| | | || 681| | | || 682| | | || 683| | | || 684| | | || 685| | | || 686| | | || 687| | | || 688| | | || 689| | | || 690| | | || 691| | | || 692| | | || 693| | | || 694| | | || 695| | | || 696| | | || 697| | | || 698| | | || 699| | | || 700| | | || 701| | | || 702| | | || 703| | | || 704| | | || 705| | | || 706| | | || 707| | | || 708| | | || 709| | | || 710| | | || 711| | | || 712| | | || 713| | | || 714| | | || 715| | | || 716| | | || 717| | | || 718| | | || 719| | | || 720| | | || 721| | | || 722| | | || 723| | | || 724| | | || 725| | | || 726| | | || 727| | | || 728| | | || 729| | | || 730| | | || 731| | | || 732| | | || 733| | | || 734| | | || 735| | | || 736| | | || 737| | | || 738| | | || 739| | | || 740| | | || 741| | | || 742| | | || 743| | | || 744| | | || 745| | | || 746| | | || 747| | | || 748| | | || 749| | | || 750| | | || 751| | | || 752| | | || 753| | | || 754| | | || 755| | | || 756| | | || 757| | | || 758| | | || 759| | | || 760| | | || 761| | | || 762| | | || 763| | | || 764| | | || 765| | | || 766| | | || 767| | | || 768| | | || 769| | | || 770| | | || 771| | | || 772| | | || 773| | | || 774| | | || 775| | | || 776| | | || 777| | | || 778| | | || 779| | | || 780| | | || 781| | | || 782| | | || 783| | | || 784| | | || 785| | | || 786| | | || 787| | | || 788| | | || 789| | | || 790| | | || 791| | | || 792| | | || 793| | | || 794| | | || 795| | | || 796| | | || 797| | | || 798| | | || 799| | | || 800| | | || 801| | | || 802| | | || 803| | | || 804| | | || 805| | | || 806| | | || 807| | | || 808| | | || 809| | | || 810| | | || 811| | | || 812| | | || 813| | | || 814| | | || 815| | | || 816| | | || 817| | | || 818| | | || 819| | | || 820| | | || 821| | | || 822| | | || 823| | | || 824| | | || 825| | | || 826| | | || 827| | | || 828| | | || 829| | | || 830| | | || 831| | | || 832| | | || 833| | | || 834| | | || 835| | | || 836| | | || 837| | | || 838| | | || 839| | | || 840| | | || 841| | | || 842| | | || 843| | | || 844| | | || 845| | | || 846| | | || 847| | | || 848| | | || 849| | | || 850| | | || 851| | | || 852| | | || 853| | | || 854| | | || 855| | | || 856| | | || 857| | | || 858| | | || 859| | | || 860| | | || 861| | | || 862| | | || 863| | | || 864| | | || 865| | | || 866| | | || 867| | | || 868| | | || 869| | | || 870| | | || 871| | | || 872| | | || 873| | | || 874| | | || 875| | | || 876| | | || 877| | | || 878| | | || 879| | | || 880| | | || 881| | | || 882| | | || 883| | | || 884| | | || 885| | | || 886| | | || 887| | | || 888| | | || 889| | | || 890| | | || 891| | | || 892| | | || 893| | | || 894| | | || 895| | | || 896| | | || 897| | | || 898| | | || 899| | | || 900| | | || 901| | | || 902| | | || 903| | | || 904| | | || 905| | | || 906| | | || 907| | | || 908| | | || 909| | | || 910| | | || 911| | | || 912| | | || 913| | | || 914| | | || 915| | | || 916| | | || 917| | | || 918| | | || 919| | | || 920| | | || 921| | | || 922| | | || 923| | | || 924| | | || 925| | | || 926| | | || 927| | | || 928| | | || 929| | | || 930| | | || 931| | | || 932| | | || 933| | | || 934| | | || 935| | | || 936| | | || 937| | | || 938| | | || 939| | | || 940| | | || 941| | | || 942| | | || 943| | | || 944| | | || 945| | | || 946| | | || 947| | | || 948| | | || 949| | | || 950| | | || 951| | | || 952| | | || 953| | | || 954| | | || 955| | | || 956| | | || 957| | | || 958| | | || 959| | | || 960| | | || 961| | | || 962| | | || 963| | | || 964| | | || 965| | | || 966| | | || 967| | | || 968| | | || 969| | | || 970| | | || 971| | | || 972| | | || 973| | | || 974| | | || 975| | | || 976| | | || 977| | | || 978| | | || 979| | | || 980| | | || 981| | | || 982| | | || 983| | | || 984| | | || 985| | | || 986| | | || 987| | | || 988| | | || 989| | | || 990| | | || 991| | | || 992| | | || 993| | | || 994| | | || 995| | | || 996| | | || 997| | | || 998| | | || 999| | | || 1000| | | || 1001| | | || 1002| | | || 1003| | | || 1004| | | || 1005| | | || 1006| | | || 1007| | | || 1008| | | || 1009| | | || 1010| | | || 1011| | | || 1012| | | || 1013| | | || 1014| | | || 1015| | | || 1016| | | || 1017| | | || 1018| | | || 1019| | | || 1020| | | || 1021| | | || 1022| | | || 1023| | | || 1024| | | || 1025| | | || 1026| | | || 1027| | | || 1028| | | || 1029| | | || 1030| | | || 1031| | | || 1032| | | || 1033| | | || 1034| | | || 1035| | | || 1036| | | || 1037| | | || 1038| | | || 1039| | | || 1040| | | || 1041| | | || 1042| | | || 1043| | | || 1044| | | || 1045| | | || 1046| | | || 1047| | | || 1048| | | || 1049| | | || 1050| | | || 1051| | | || 1052| | | || 1053| | | || 1054| | | || 1055| | | || 1056| | | || 1057| | | || 1058| | | || 1059| | | || 1060| | | || 1061| | | || 1062| | | || 1063| | | || 1064| | | || 1065| | | || 1066| | | || 1067| | | || 1068| | | || 1069| | | || 1070| | | || 1071| | | || 1072| | | || 1073| | | || 1074| | | || 1075| | | || 1076| | | || 1077| | | || 1078| | | || 1079| | | || 1080| | | || 1081| | | || 1082| | | || 1083| | | || 1084| | | || 1085| | | || 1086| | | || 1087| | | || 1088| | | || 1089| | | || 1090| | | || 1091| | | || 1092| | | || 1093| | | || 1094| | | || 1095| | | || 1096| | | || 1097| | | || 1098| | | || 1099| | | || 1100| | | || 1101| | | || 1102| | | || 1103| | | || 1104| | | || 1105| | | || 1106| | | || 1107| | | || 1108| | | || 1109| | | || 1110| | | || 1111| | | || 1112| | | || 1113| | | || 1114| | | || 1115| | | || 1116| | | || 1117| | | || 1118| | | || 1119| | | || 1120| | | || 1121| | | || 1122| | | || 1123| | | || 1124| | | || 1125| | | || 1126| | | || 1127| | | || 1128| | | || 1129| | | || 1130| | | || 1131| | | || 1132| | | || 1133| | | || 1134| | | || 1135| | | || 1136| | | || 1137| | | || 1138| | | || 1139| | | || 1140| | | || 1141| | | || 1142| | | || 1143| | | || 1144| | | || 1145| | | || 1146| | | || 1147| | | || 1148| | | || 1149| | | || 1150| | | || 1151| | | || 1152| | | || 1153| | | || 1154| | | || 1155| | | || 1156| | | || 1157| | | || 1158| | | || 1159| | | || 1160| | | || 1161| | | || 1162| | | || 1163| | | || 1164| | | || 1165| | | || 1166| | | || 1167| | | || 1168| | | || 1169| | | || 1170| | | || 1171| | | || 1172| | | || 1173| | | || 1174| | | || 1175| | | || 1176| | | || 1177| | | || 1178| | | || 1179| | | || 1180| | | || 1181| | | || 1182| | | || 1183| | | || 1184| | | || 1185| | | || 1186| | | || 1187| | | || 1188| | | || 1189| | | || 1190| | | || 1191| | | || 1192| | | || 1193| | | || 1194| | | || 1195| | | || 1196| | | || 1197| | | || 1198| | | || 1199| | | || 1200| | | || 1201| | | || 1202| | | || 1203| | | || 1204| | | || 1205| | | || 1206| | | || 1207| | | || 1208| | | || 1209| | | || 1210| | | || 1211| | | || 1212| | | || 1213| | | || 1214| | | || 1215| | | || 1216| | | || 1217| | | || 1218| | | || 1219| | | || 1220| | | || 1221| | | || 1222| | | || 1223| | | || 1224| | | || 1225| | | || 1226| | | || 1227| | | || 1228| | | || 1229| | | || 1230| | | || 1231| | | || 1232| | | || 1233| | | || 1234| | | || 1235| | | || 1236| | | || 1237| | | || 1238| | | || 1239| | | || 1240| | | || 1241| | | || 1242| | | || 1243| | | || 1244| | | || 1245| | | || 1246| | | || 1247| | | || 1248| | | || 1249| | | || 1250| | | || 1251| | | || 1252| | | || 1253| | | || 1254| | | || 1255| | | || 1256| | | || 1257| | | || 1258| | | || 1259| | | || 1260| | | || 1261| | | || 1262| | | || 1263| | | || 1264| | | || 1265| | | || 1266| | | || 1267| | | || 1268| | | || 1269| | | || 1270| | | || 1271| | | || 1272| | | || 1273| | | || 1274| | | || 1275| | | || 1276| | | || 1277| | | || 1278| | | || 1279| | | || 1280| | | || 1281| | | || 1282| | | || 1283| | | || 1284| | | || 1285| | | || 1286| | | || 1287| | | || 1288| | | || 1289| | | || 1290| | | || 1291| | | || 1292| | | || 1293| | | || 1294| | | || 1295| | | || 1296| | | || 1297| | | || 1298| | | || 1299| | | || 1300| | | || 1301| | | || 1302| | | || 1303| | | || 1304| | | || 1305| | | || 1306| | | || 1307| | | || 1308| | | || 1309| | | || 1310| | | || 1311| | | || 1312| | | || 1313| | | || 1314| | | || 1315| | | || 1316| | | || 1317| | | || 1318| | | || 1319| | | || 1320| | | || 1321| | | || 1322| | | || 1323| | | || 1324| | | || 1325| | | || 1326| | | || 1327| | | || 1328| | | || 1329| | | || 1330| | | || 1331| | | || 1332| | | || 1333| | | || 1334| | | || 1335| | | || 1336| | | || 1337| | | || 1338| | | || 1339| | | || 1340| | | || 1341| | | || 1342| | | || 1343| | | || 1344| | | || 1345| | | || 1346| | | || 1347| | | || 1348| | | || 1349| | | || 1350| | | || 1351| | | || 1352| | | || 1353| | | || 1354| | | || 1355| | | || 1356| | | || 1357| | | || 1358| | | || 1359| | | || 1360| | | || 1361| | | || 1362| | | || 1363| | | || 1364| | | || 1365| | | || 1366| | | || 1367| | | || 1368| | | || 1369| | | || 1370| | | || 1371| | | || 1372| | | || 1373| | | || 1374| | | || 1375| | | || 1376| | | || 1377| | | || 1378| | | || 1379| | | || 1380| | | || 1381| | | || 1382| | | || 1383| | | || 1384| | | || 1385| | | || 1386| | | || 1387| | | || 1388| | | || 1389| | | || 1390| | | || 1391| | | || 1392| | | || 1393| | | || 1394| | | || 1395| | | || 1396| | | || 1397| | | || 1398| | | || 1399| | | || 1400| | | || 1401| | | || 1402| | | || 1403| | | || 1404| | | || 1405| | | || 1406| | | || 1407| | | || 1408| | | || 1409| | | || 1410| | | || 1411| | | || 1412| | | || 1413| | | || 1414| | | || 1415| | | || 1416| | | || 1417| | | || 1418| | | || 1419| | | || 1420| | | || 1421| | | || 1422| | | || 1423| | | || 1424| | | || 1425| | | || 1426| | | || 1427| | | || 1428| | | || 1429| | | || 1430| | | || 1431| | | || 1432| | | || 1433| | | || 1434| | | || 1435| | | || 1436| | | || 1437| | | || 1438| | | || 1439| | | || 1440| | | || 1441| | | || 1442| | | || 1443| | | || 1444| | | || 1445| | | || 1446| | | || 1447| | | || 1448| | | || 1449| | | || 1450| | | || 1451| | | || 1452| | | || 1453| | | || 1454| | | || 1455| | | || 1456| | | || 1457| | | || 1458| | | || 1459| | | || 1460| | | || 1461| | | || 1462| | | || 1463| | | || 1464| | | || 1465| | | || 1466| | | || 1467| | | || 1468| | | || 1469| | | || 1470| | | || 1471| | | || 1472| | | || 1473| | | || 1474| | | || 1475| | | || 1476| | | || 1477| | | || 1478| | | || 1479| | | || 1480| | | || 1481| | | || 1482| | | || 1483| | | || 1484| | | || 1485| | | || 1486| | | || 1487| | | || 1488| | | || 1489| | | || 1490| | | || 1491| | | || 1492| | | || 1493| | | || 1494| | | || 1495| | | || 1496| | | || 1497| | | || 1498| | | || 1499| | | || 1500| | | || 1501| | | || 1502| | | || 1503| | | || 1504| | | || 1505| | | || 1506| | | || 1507| | | || 1508| | | || 1509| | | || 1510| | | || 1511| | | || 1512| | | || 1513| | | || 1514| | | || 1515| | | || 1516| | | || 1517| | | || 1518| | | || 1519| | | || 1520| | | || 1521| | | || 1522| | | || 1523| | | || 1524| | | || 1525| | | || 1526| | | || 1527| | | || 1528| | | || 1529| | | || 1530| | | || 1531| | | || 1532| | | || 1533| | | || 1534| | | || 1535| | | || 1536| | | || 1537| | | || 1538| | | || 1539| | | || 1540| | | || 1541| | | || 1542| | | || 1543| | | || 1544| | | || 1545| | | || 1546| | | || 1547| | | || 1548| | | || 1549| | | || 1550| | | || 1551| | | || 1552| | | || 1553| | | || 1554| | | || 1555| | | || 1556| | | || 1557| | | || 1558| | | || 1559| | | || 1560| | | || 1561| | | || 1562| | | || 1563| | | || 1564| | | || 1565| | | || 1566| | | || 1567| | | || 1568| | | || 1569| | | || 1570| | | || 1571| | | || 1572| | | || 1573| | | || 1574| | | || 1575| | | || 1576| | | || 1577| | | || 1578| | | || 1579| | | || 1580| | | || 1581| | | || 1582| | | || 1583| | | || 1584| | | || 1585| | | || 1586| | | || 1587| | | || 1588| | | || 1589| | | || 1590| | | || 1591| | | || 1592| | | || 1593| | | || 1594| | | || 1595| | | || 1596| | | || 1597| | | || 1598| | | || 1599| | | || 1600| | | || 1601| | | || 1602| | | || 1603| | | || 1604| | | || 1605| | | || 1606| | | || 1607| | | || 1608| | | || 1609| | | || 1610| | | || 1611| | | || 1612| | | || 1613| | | || 1614| | | || 1615| | | || 1616| | | || 1617| | | || 1618| | | || 1619| | | || 1620| | | || 1621| | | || 1622| | | || 1623| | | || 1624| | | || 1625| | | || 1626| | | || 1627| | | || 1628| | | || 1629| | | || 1630| | | || 1631| | | || 1632| | | || 1633| | | || 1634| | | || 1635| | | || 1636| | | || 1637| | | || 1638| | | || 1639| | | || 1640| | | || 1641| | | || 1642| | | || 1643| | | || 1644| | | || 1645| | | || 1646| | | || 1647| | | || 1648| | | || 1649| | | || 1650| | | || 1651| | | || 1652| | | || 1653| | | || 1654| | | || 1655| | | || 1656| | | || 1657| | | || 1658| | | || 1659| | | || 1660| | | || 1661| | | || 1662| | | || 1663| | | || 1664| | | || 1665| | | || 1666| | | || 1667| | | || 1668| | | || 1669| | | || 1670| | | || 1671| | | || 1672| | | || 1673| | | || 1674| | | || 1675| | | || 1676| | | || 1677| | | || 1678| | | || 1679| | | || 1680| | | || 1681| | | || 1682| | | || 1683| | | || 1684| | | || 1685| | | || 1686| | | || 1687| | | || 1688| | | || 1689| | | || 1690| | | || 1691| | | || 1692| | | || 1693| | | || 1694| | | || 1695| | | || 1696| | | || 1697| | | || 1698| | | || 1699| | | || 1700| | | || 1701| | | || 1702| | | || 1703| | | || 1704| | | || 1705| | | || 1706| | | || 1707| | | || 1708| | | || 1709| | | || 1710| | | || 1711| | | || 1712| | | || 1713| | | || 1714| | | || 1715| | | || 1716| | | || 1717| | | || 1718| | | || 1719| | | || 1720| | | || 1721| | | || 1722| | | || 1723| | | || 1724| | | || 1725| | | || 1726| | | || 1727| | | || 1728| | | || 1729| | | || 1730| | | || 1731| | | || 1732| | | || 1733| | | || 1734| | | || 1735| | | || 1736| | | || 1737| | | || 1738| | | || 1739| | | || 1740| | | || 1741| | | || 1742| | | || 1743| | | || 1744| | | || 1745| | | || 1746| | | || 1747| | | || 1748| | | || 1749| | | || 1750| | | || 1751| | | || 1752| | | || 1753| | | || 1754| | | || 1755| | | || 1756| | | || 1757| | | || 1758| | | || 1759| | | || 1760| | | || 1761| | | || 1762| | | || 1763| | | || 1764| | | || 1765| | | || 1766| | | || 1767| | | || 1768| | | || 1769| | | || 1770| | | || 1771| | | || 1772| | | || 1773| | | || 1774| | | || 1775| | | || 1776| | | || 1777| | | || 1778| | | || 1779| | | || 1780| | | || 1781| | | || 1782| | | || 1783| | | || 1784| | | || 1785| | | || 1786| | | || 1787| | | || 1788| | | || 1789| | | || 1790| | | || 1791| | | || 1792| | | || 1793| | | || 1794| | | || 1795| | | || 1796| | | || 1797| | | || 1798| | | || 1799| | | || 1800| | | || 1801| | | || 1802| | | || 1803| | | || 1804| | | || 1805| | | || 1806| | | || 1807| | | || 1808| | | || 1809| | | || 1810| | | || 1811| | | || 1812| | | || 1813| | | || 1814| | | || 1815| | | || 1816| | | || 1817| | | || 1818| | | || 1819| | | || 1820| | | || 1821| | | || 1822| | | || 1823| | | || 1824| | | || 1825| | | || 1826| | | || 1827| | | || 1828| | | || 1829| | | || 1830| | | || 1831| | | || 1832| | | || 1833| | | || 1834| | | || 1835| | | || 1836| | | || 1837| | | || 1838| | | || 1839| | | || 1840| | | || 1841| | | || 1842| | | || 1843| | | || 1844| | | || 1845| | | || 1846| | | || 1847| | | || 1848| | | || 1849| | | || 1850| | | || 1851| | | || 1852| | | || 1853| | | || 1854| | | || 1855| | | || 1856| | | || 1857| | | || 1858| | | || 1859| | | || 1860| | | || 1861| | | || 1862| | | || 1863| | | || 1864| | | || 1865| | | || 1866| | | || 1867| | | || 1868| | | || 1869| | | || 1870| | | || 1871| | | || 1872| | | || 1873| | | || 1874| | | || 1875| | | || 1876| | | || 1877| | | || 1878| | | || 1879| | | || 1880| | | || 1881| | | || 1882| | | || 1883| | | || 1884| | | || 1885| | | || 1886| | | || 1887| | | || 1888| | | || 1889| | | || 1890| | | || 1891| | | || 1892| | | || 1893| | | || 1894| | | || 1895| | | || 1896| | | || 1897| | | || 1898| | | || 1899| | | || 1900| | | || 1901| | | || 1902| | | || 1903| | | || 1904| | | || 1905| | | || 1906| | | || 1907| | | || 1908| | | || 1909| | | || 1910| | | || 1911| | | || 1912| | | || 1913| | | || 1914| | | || 1915| | | || 1916| | | || 1917| | | || 1918| | | || 1919| | | || 1920| | | || 1921| | | || 1922| | | || 1923| | | || 1924| | | || 1925| | | || 1926| | | || 1927| | | || 1928| | | || 1929| | | || 1930| | | || 1931| | | || 1932| | | || 1933| | | || 1934| | | || 1935| | | || 1936| | | || 1937| | | || 1938| | | || 1939| | | || 1940| | | || 1941| | | || 1942| | | || 1943| | | || 1944| | | || 1945| | | || 1946| | | || 1947| | | || 1948| | | || 1949| | | || 1950| | | || 1951| | | || 1952| | | || 1953| | | || 1954| | | || 1955| | | || 1956| | | || 1957| | | || 1958| | | || 1959| | | || 1960| | | || 1961| | | || 1962| | | || 1963| | | || 1964| | | || 1965| | | || 1966| | | || 1967| | | || 1968| | | || 1969| | | || 1970| | | || 1971| | | || 1972| | | || 1973| | | || 1974| | | || 1975| | | || 1976| | | || 1977| | | || 1978| | | || 1979| | | || 1980| | | || 1981| | | || 1982| | | || 1983| | | || 1984| | | || 1985| | | || 1986| | | || 1987| | | || 1988| | | || 1989| | | || 1990| | | || 1991| | | || 1992| | | || 1993| | | || 1994| | | || 1995| | | || 1996| | | || 1997| | | || 1998| | | || 1999| | | || 2000| | | || 2001| | | || 2002| | | || 2003| | | || 2004| | | || 2005| | | || 2006| | | || 2007| | | || 2008| | | || 2009| | | || 2010| | | || 2011| | | || 2012| | | || 2013| | | || 2014| | | || 2015| | | || 2016| | | || 2017| | | || 2018| | | || 2019| | | || 2020| | | || 2021| | | || 2022| | | || 2023| | | || 2024| | | || 2025| | | || 2026| | | || 2027| | | || 2028| | | || 2029| | | || 2030| | | || 2031| | | || 2032| | | || 2033| | | || 2034| | | || 2035| | | || 2036| | | || 2037| | | || 2038| | | || 2039| | | || 2040| | | || 2041| | | || 2042| | | || 2043| | | || 2044| | | || 2045| | | || 2046| | | || 2047| | | || 2048| | | || 2049| | | || 2050| | | || 2051| | | || 2052| | | || 2053| | | || 2054| | | || 2055| | | || 2056| | | || 2057| | | || 2058| | | || 2059| | | || 2060| | | || 2061| | | || 2062| | | || 2063| | | || 2064| | | || 2065| | | || 2066| | | || 2067| | | || 2068| | | || 2069| | | || 2070| | | || 2071| | | || 2072| | | || 2073| | | || 2074| | | || 2075| | | || 2076| | | || 2077| | | || 2078| | | || 2079| | | || 2080| | | || 2081| | | || 2082| | | || 2083| | | || 2084| | | || 2085| | | || 2086| | | || 2087| | | || 2088| | | || 2089| | | || 2090| | | || 2091| | | || 2092| | | || 2093| | | || 2094| | | || 2095| | | || 2096| | | || 2097| | | || 2098| | | || 2099| | | || 2100| | | || 2101| | | || 2102| | | || 2103| | | || 2104| | | || 2105| | | || 2106| | | || 2107| | | || 2108| | | || 2109| | | || 2110| | | || 2111| | | || 2112| | | || 2113| | | || 2114| | | || 2115| | | || 2116| | | || 2117| | | || 2118| | | || 2119| | | || 2120| | | || 2121| | | || 2122| | | || 2123| | | || 2124| | | || 2125| | | || 2126| | | || 2127| | | || 2128| | | || 2129| | | || 2130| | | || 2131| | | || 2132| | | || 2133| | | || 2134| | | || 2135| | | || 2136| | | || 2137| | | || 2138| | | || 2139| | | || 2140| | | || 2141| | | || 2142| | | || 2143| | | || 2144| | | || 2145| | | || 2146| | | || 2147| | | || 2148| | | || 2149| | | || 2150| | | || 2151| | | || 2152| | | || 2153| | | || 2154| | | || 2155| | | || 2156| | | || 2157| | | || 2158| | | || 2159| | | || 2160| | | || 2161| | | || 2162| | | || 2163| | | || 2164| | | || 2165| | | || 2166| | | || 2167| | | || 2168| | | || 2169| | | || 2170| | | || 2171| | | || 2172| | | || 2173| | | || 2174| | | || 2175| | | || 2176| | | || 2177| | | || 2178| | | || 2179| | | || 2180| | | || 2181| | | || 2182| | | || 2183| | | || 2184| | | || 2185| | | || 2186| | | || 2187| | | || 2188| | | || 2189| | | || 2190| | | || 2191| | | || 2192| | | || 2193| | | || 2194| | | || 2195| | | || 2196| | | || 2197| | | || 2198| | | || 2199| | | || 2200| | | || 2201| | | || 2202| | | || 2203| | | || 2204| | | || 2205| | | || 2206| | | || 2207| | | || 2208| | | || 2209| | | || 2210| | | || 2211| | | || 2212| | | || 2213| | | || 2214| | | || 2215| | | || 2216| | | || 2217| | | || 2218| | | || 2219| | | || 2220| | | || 2221| | | || 2222| | | || 2223| | | || 2224| | | || 2225| | | || 2226| | | || 2227| | | || 2228| | | || 2229| | | || 2230| | | || 2231| | | || 2232| | | || 2233| | | || 2234| | | || 2235| | | || 2236| | | || 2237| | | || 2238| | | || 2239| | | || 2240| | | || 2241| | | || 2242| | | || 2243| | | || 2244| | | || 2245| | | || 2246| | | || 2247| | | || 2248| | | || 2249| | | || 2250| | | || 2251| | | || 2252| | | || 2253| | | || 2254| | | || 2255| | | || 2256| | | || 2257| | | || 2258| | | || 2259| | | || 2260| | | || 2261| | | || 2262| | | || 2263| | | || 2264| | | || 2265| | | || 2266| | | || 2267| | | || 2268| | | || 2269| | | || 2270| | | || 2271| | | || 2272| | | || 2273| | | || 2274| | | || 2275| | | || 2276| | | || 2277| | | || 2278| | | || 2279| | | || 2280| | | || 2281| | | || 2282| | | || 2283| | | || 2284| | | || 2285| | | || 2286| | | || 2287| | | || 2288| | | || 2289| | | || 2290| | | || 2291| | | || 2292| | | || 2293| | | || 2294| | | || 2295| | | || 2296| | | || 2297| | | || 2298| | | || 2299| | | || 2300| | | || 2301| | | || 2302| | | || 2303| | | || 2304| | | || 2305| | | || 2306| | | || 2307| | | || 2308| | | || 2309| | | || 2310| | | || 2311| | | || 2312| | | || 2313| | | || 2314| | | || 2315| | | || 2316| | | || 2317| | | || 2318| | | || 2319| | | || 2320| | | || 2321| | | || 2322| | | || 2323| | | || 2324| | | || 2325| | | || 2326| | | || 2327| | | || 2328| | | || 2329| | | || 2330| | | || 2331| | | || 2332| | | || 2333| | | || 2334| | | || 2335| | | || 2336| | | || 2337| | | || 2338| | | || 2339| | | || 2340| | | || 2341| | | || 2342| | | || 2343| | | || 2344| | | || 2345| | | || 2346| | | || 2347| | | || 2348| | | || 2349| | | || 2350| | | || 2351| | | || 2352| | | || 2353| | | || 2354| | | || 2355| | | || 2356| | | || 2357| | | || 2358| | | || 2359| | | || 2360| | | || 2361| | | || 2362| | | || 2363| | | || 2364| | | || 2365| | | || 2366| | | || 2367| | | || 2368| | | || 2369| | | || 2370| | | || 2371| | | || 2372| | | || 2373| | | || 2374| | | || 2375| | | || 2376| | | || 2377| | | || 2378| | | || 2379| | | || 2380| | | || 2381| | | || 2382| | | || 2383| | | || 2384| | | || 2385| | | || 2386| | | || 2387| | | || 2388| | | || 2389| | | || 2390| | | || 2391| | | || 2392| | | || 2393| | | || 2394| | | || 2395| | | || 2396| | | || 2397| | | || 2398| | | || 2399| | | || 2400| | | || 2401| | | || 2402| | | || 2403| | | || 2404| | | || 2405| | | || 2406| | | || 2407| | | || 2408| | | || 2409| | | || 2410| | | || 2411| | | || 2412| | | || 2413| | | || 2414| | | || 2415| | | || 2416| | | || 2417| | | || 2418| | | || 2419| | | || 2420| | | || 2421| | | || 2422| | | || 2423| | | || 2424| | | || 2425| | | || 2426| | | || 2427| | | || 2428| | | || 2429| | | || 2430| | | || 2431| | | || 2432| | | || 2433| | | || 2434| | | || 2435| | | || 2436| | | || 2437| | | || 2438| | | || 2439| | | || 2440| | | || 2441| | | || 2442| | | || 2443| | | || 2444| | | || 2445| | | || 2446| | | || 2447| | | || 2448| | | || 2449| | | || 2450| | | || 2451| | | || 2452| | | || 2453| | | || 2454| | | || 2455| | | || 2456| | | || 2457| | | || 2458| | | || 2459| | | || 2460| | | || 2461| | | || 2462| | | || 2463| | | || 2464| | | || 2465| | | || 2466| | | || 2467| | | || 2468| | | || 2469| | | || 2470| | | || 2471| | | || 2472| | | || 2473| | | || 2474| | | || 2475| | | || 2476| | | || 2477| | | || 2478| | | || 2479| | | || 2480| | | || 2481| | | || 2482| | | || 2483| | | || 2484| | | || 2485| | | || 2486| | | || 2487| | | || 2488| | | || 2489| | | || 2490| | | || 2491| | | || 2492| | | || 2493| | | || 2494| | | || 2495| | | || 2496| | | || 2497| | | || 2498| | | || 2499| | | || 2500| | | || 2501| | | || 2502| | | || 2503| | | || 2504| | | || 2505| | | || 2506| | | || 2507| | | || 2508| | | || 2509| | | || 2510| | | || 2511| | | || 2512| | | || 2513| | | || 2514| | | || 2515| | | || 2516| | | || 2517| | | || 2518| | | || 2519| | | || 2520| | | || 2521| | | || 2522| | | || 2523| | | || 2524| | | || 2525| | | || 2526| | | || 2527| | | || 2528| | | || 2529| | | || 2530| | | || 2531| | | || 2532| | | || 2533| | | || 2534| | | || 2535| | | || 2536| | | || 2537| | | || 2538| | | || 2539| | | || 2540| | | || 2541| | | || 2542| | | || 2543| | | || 2544| | | || 2545| | | || 2546| | | || 2547| | | || 2548| | | || 2549| | | || 2550| | | || 2551| | | || 2552| | | || 2553| | | || 2554| | | || 2555| | | || 2556| | | || 2557| | | || 2558| | | || 2559| | | || 2560| | | || 2561| | | || 2562| | | || 2563| | | || 2564| | | || 2565| | | || 2566| | | || 2567| | | || 2568| | | || 2569| | | || 2570| | | || 2571| | | || 2572| | | || 2573| | | || 2574| | | || 2575| | | || 2576| | | || 2577| | | || 2578| | | || 2579| | | || 2580| | | || 2581| | | || 2582| | | || 2583| | | || 2584| | | || 2585| | | || 2586| | | || 2587| | | || 2588| | | || 2589| | | || 2590| | | || 2591| | | || 2592| | | || 2593| | | || 2594| | | || 2595| | | || 2596| | | || 2597| | | || 2598| | | || 2599| | | || 2600| | | || 2601| | | || 2602| | | || 2603| | | || 2604| | | || 2605| | | || 2606| | | || 2607| | | || 2608| | | || 2609| | | || 2610| | | || 2611| | | || 2612| | | || 2613| | | || 2614| | | || 2615| | | || 2616| | | || 2617| | | || 2618| | | || 2619| | | || 2620| | | || 2621| | | || 2622| | | || 2623| | | || 2624| | | || 2625| | | || 2626| | | || 2627| | | || 2628| | | || 2629| | | || 2630| | | || 2631| | | || 2632| | | || 2633| | | || 2634| | | || 2635| | | || 2636| | | || 2637| | | || 2638| | | || 2639| | | || 2640| | | || 2641| | | || 2642| | | || 2643| | | || 2644| | | || 2645| | | || 2646| | | || 2647| | | || 2648| | | || 2649| | | || 2650| | | || 2651| | | || 2652| | | || 2653| | | || 2654| | | || 2655| | | || 2656| | | || 2657| | | || 2658| | | || 2659| | | || 2660| | | || 2661| | | || 2662| | | || 2663| | | || 2664| | | || 2665| | | || 2666| | | || 2667| | | || 2668| | | || 2669| | | || 2670| | | || 2671| | | || 2672| | | || 2673| | | || 2674| | | || 2675| | | || 2676| | | || 2677| | | || 2678| | | || 2679| | | || 2680| | | || 2681| | | || 2682| | | || 2683| | | || 2684| | | || 2685| | | || 2686| | | || 2687| | | || 2688| | | || 2689| | | || 2690| | | || 2691| | | || 2692| | | || 2693| | | || 2694| | | || 2695| | | || 2696| | | || 2697| | | || 2698| | | || 2699| | | || 2700| | | || 2701| | | || 2702| | | || 2703| | | || 2704| | | || 2705| | | || 2706| | | || 2707| | | || 2708| | | || 2709| | | || 2710| | | || 2711| | | || 2712| | | || 2713| | | || 2714| | | || 2715| | | || 2716| | | || 2717| | | || 2718| | | || 2719| | | || 2720| | | || 2721| | | || 2722| | | || 2723| | | || 2724| | | || 2725| | | || 2726| | | || 2727| | | || 2728| | | || 2729| | | || 2730| | | || 2731| | | || 2732| | | || 2733| | | || 2734| | | || 2735| | | || 2736| | | || 2737| | | || 2738| | | || 2739| | | || 2740| | | || 2741| | | || 2742| | | || 2743| | | || 2744| | | || 2745| | | || 2746| | | || 2747| | | || 2748| | | || 2749| | | || 2750| | | || 2751| | | || 2752| | | || 2753| | | || 2754| | | || 2755| | | || 2756| | | || 2757| | | || 2758| | | || 2759| | | || 2760| | | || 2761| | | || 2762| | | || 2763| | | || 2764| | | || 2765| | | || 2766| | | || 2767| | | || 2768| | | || 2769| | | || 2770| | | || 2771| | | || 2772| | | || 2773| | | || 2774| | | || 2775| | | || 2776| | | || 2777| | | || 2778| | | || 2779| | | || 2780| | | || 2781| | | || 2782| | | || 2783| | | || 2784| | | || 2785| | | || 2786| | | || 2787| | | || 2788| | | || 2789| | | || 2790| | | || 2791| | | || 2792| | | || 2793| | | || 2794| | | || 2795| | | || 2796| | | || 2797| | | || 2798| | | || 2799| | | || 2800| | | || 2801| | | || 2802| | | || 2803| | | || 2804| | | || 2805| | | || 2806| | | || 2807| | | || 2808| | | || 2809| | | || 2810| | | || 2811| | | || 2812| | | || 2813| | | || 2814| | | || 2815| | | || 2816| | | || 2817| | | || 2818| | | || 2819| | | || 2820| | | || 2821| | | || 2822| | | || 2823| | | || 2824| | | || 2825| | | || 2826| | | || 2827| | | || 2828| | | || 2829| | | || 2830| | | || 2831| | | || 2832| | | || 2833| | | || 2834| | | || 2835| | | || 2836| | | || 2837| | | || 2838| | | || 2839| | | || 2840| | | || 2841| | | || 2842| | | || 2843| | | || 2844| | | || 2845| | | || 2846| | | || 2847| | | || 2848| | | || 2849| | | || 2850| | | || 2851| | | || 2852| | | || 2853| | | || 2854| | | || 2855| | | || 2856| | | || 2857| | | || 2858| | | || 2859| | | || 2860| | | || 2861| | | || 2862| | | || 2863| | | || 2864| | | || 2865| | | || 2866| | | || 2867| | | || 2868| | | || 2869| | | || 2870| | | || 2871| | | || 2872| | | || 2873| | | || 2874| | | || 2875| | | || 2876| | | || 2877| | | || 2878| | | || 2879| | | || 2880| | | || 2881| | | || 2882| | | || 2883| | | || 2884| | | || 2885| | | || 2886| | | || 2887| | | || 2888| | | || 2889| | | || 2890| | | || 2891| | | || 2892| | | || 2893| | | || 2894| | | || 2895| | | || 2896| | | || 2897| | | || 2898| | | || 2899| | | || 2900| | | || 2901| | | || 2902| | | || 2903| | | || 2904| | | || 2905| | | || 2906| | | || 2907| | | || 2908| | | || 2909| | | || 2910| | | || 2911| | | || 2912| | | || 2913| | | || 2914| | | || 2915| | | || 2916| | | || 2917| | | || 2918| | | || 2919| | | || 2920| | | || 2921| | | || 2922| | | || 2923| | | || 2924| | | || 2925| | | || 2926| | | || 2927| | | || 2928| | | || 2929| | | || 2930| | | || 2931| | | || 2932| | | || 2933| | | || 2934| | | || 2935| | | || 2936| | | || 2937| | | || 2938| | | || 2939| | | || 2940| | | || 2941| | | || 2942| | | || 2943| | | || 2944| | | || 2945| | | || 2946| | | || 2947| | | || 2948| | | || 2949| | | || 2950| | | || 2951| | | || 2952| | | || 2953| | | || 2954| | | || 2955| | | || 2956| | | || 2957| | | || 2958| | | || 2959| | | || 2960| | | || 2961| | | || 2962| | | || 2963| | | || 2964| | | || 2965| | | || 2966| | | || 2967| | | || 2968| | | || 2969| | | || 2970| | | || 2971| | | || 2972| | | || 2973| | | || 2974| | | || 2975| | | || 2976| | | || 2977| | | || 2978| | | || 2979| | | || 2980| | | || 2981| | | || 2982| | | || 2983| | | || 2984| | | || 2985| | | || 2986| | | || 2987| | | || 2988| | | || 2989| | | || 2990| | | || 2991| | | || 2992| | | || 2993| | | || 2994| | | || 2995| | | || 2996| | | || 2997| | | || 2998| | | || 2999| | | || 3000| | | || 3001| | | || 3002| | | || 3003| | | || 3004| | | || 3005| | | || 3006| | | || 3007| | | || 3008| | | || 3009| | | || 3010| | | || 3011| | | || 3012| | | || 3013| | | || 3014| | | || 3015| | | || 3016| | | || 3017| | | || 3018| | | || 3019| | | || 3020| | | || 3021| | | || 3022| | | || 3023| | | || 3024| | | || 3025| | | || 3026| | | || 3027| | | || 3028| | | || 3029| | | || 3030| | | || 3031| | | || 3032| | | || 3033| | | || 3034| | | || 3035| | | || 3036| | | || 3037| | | || 3038| | | || 3039| | | || 3040| | | || 3041| | | || 3042| | | || 3043| | | || 3044| | | || 3045| | | || 3046| | | || 3047| | | || 3048| | | || 3049| | | || 3050| | | || 3051| | | || 3052| | | || 3053| | | || 3054| | | || 3055| | | || 3056| | | || 3057| | | || 3058| | | || 3059| | | || 3060| | | || 3061| | | || 3062| | | || 3063| | | || 3064| | | || 3065| | | || 3066| | | || 3067| | | || 3068| | | || 3069| | | || 3070| | | || 3071| | | || 3072| | | || 3073| | | || 3074| | | || 3075| | | || 3076| | | || 3077| | | || 3078| | | || 3079| | | || 3080| | | || 3081| | | || 3082| | | || 3083| | | || 3084| | | || 3085| | | || 3086| | | || 3087| | | || 3088| | | || 3089| | | || 3090| | | || 3091| | | || 3092| | | || 3093| | | || 3094| | | || 3095| | | || 3096| | | || 3097| | | || 3098| | | || 3099| | | || 3100| | | || 3101| | | || 3102| | | || 3103| | | || 3104| | | || 3105| | | || 3106| | | || 3107| | | || 3108| | | || 3109| | | || 3110| | | || 3111| | | || 3112| | | || 3113| | | || 3114| | | || 3115| | | || 3116| | | || 3117| | | || 3118| | | || 3119| | | || 3120| | | || 3121| | | || 3122| | | || 3123| | | || 3124| | | || 3125| | | || 3126| | | || 3127| | | || 3128| | | || 3129| | | || 3130| | | || 3131| | | || 3132| | | || 3133| | | || 3134| | | || 3135| | | || 3136| | | || 3137| | | || 3138| | | || 3139| | | || 3140| | | || 3141| | | || 3142| | | || 3143| | | || 3144| | | || 3145| | | || 3146| | | || 3147| | | || 3148| | | || 3149| | | || 3150| | | || 3151| | | || 3152| | | || 3153| | | || 3154| | | || 3155| | | || 3156| | | || 3157| | | || 3158| | | || 3159| | | || 3160| | | || 3161| | | || 3162| | | || 3163| | | || 3164| | | || 3165| | | || 3166| | | || 3167| | | || 3168| | | || 3169| | | || 3170| | | || 3171| | | || 3172| | | || 3173| | | || 3174| | | || 3175| | | || 3176| | | || 3177| | | || 3178| | | || 3179| | | || 3180| | | || 3181| | | || 3182| | | || 3183| | | || 3184| | | || 3185| | | || 3186| | | || 3187| | | || 3188| | | || 3189| | | || 3190| | | || 3191| | | || 3192| | | || 3193| | | || 3194| | | || 3195| | | || 3196| | | || 3197| | | || 3198| | | || 3199| | | || 3200| | | || 3201| | | || 3202| | | || 3203| | | || 3204| | | || 3205| | | || 3206| | | || 3207| | | || 3208| | | || 3209| | | || 3210| | | || 3211| | | || 3212| | | || 3213| | | || 3214| | | || 3215| | | || 3216| | | || 3217| | | || 3218| | | || 3219| | | || 3220| | | || 3221| | | || 3222| | | || 3223| | | || 3224| | | || 3225| | | || 3226| | | || 3227| | | || 3228| | | || 3229| | | || 3230| | | || 3231| | | || 3232| | | || 3233| | | || 3234| | | || 3235| | | || 3236| | | || 3237| | | || 3238| | | || 3239| | | || 3240| | | || 3241| | | || 3242| | | || 3243| | | || 3244| | | || 3245| | | || 3246| | | || 3247| | | || 3248| | | || 3249| | | || 3250| | | || 3251| | | || 3252| | | || 3253| | | || 3254| | | || 3255| | | || 3256| | | || 3257| | | || 3258| | | || 3259| | | || 3260| | | || 3261| | | || 3262| | | || 3263| | | || 3264| | | || 3265| | | || 3266| | | || 3267| | | || 3268| | | || 3269| | | || 3270| | | || 3271| | | || 3272| | | || 3273| | | || 3274| | | || 3275| | | || 3276| | | || 3277| | | || 3278| | | || 3279| | | || 3280| | | || 3281| | | || 3282| | | || 3283| | | || 3284| | | || 3285| | | || 3286| | | || 3287| | | || 3288| | | || 3289| | | || 3290| | | || 3291| | | || 3292| | | || 3293| | | || 3294| | | || 3295| | | || 3296| | | || 3297| | | || 3298| | | || 3299| | | || 3300| | | || 3301| | | || 3302| | | || 3303| | | || 3304| | | || 3305| | | || 3306| | | || 3307| | | || 3308| | | || 3309| | | || 3310| | | || 3311| | | || 3312| | | || 3313| | | || 3314| | | || 3315| | | || 3316| | | || 3317| | | || 3318| | | || 3319| | | || 3320| | | || 3321| | | || 3322| | | || 3323| | | || 3324| | | || 3325| | | || 3326| | | || 3327| | | || 3328| | | || 3329| | | || 3330| | | || 3331| | | || 3332| | | || 3333| | | || 3334| | | || 3335| | | || 3336| | | || 3337| | | || 3338| | | || 3339| | | || 3340| | | || 3341| | | || 3342| | | || 3343| | | || 3344| | | || 3345| | | || 3346| | | || 3347| | | || 3348| | | || 3349| | | || 3350| | | || 3351| | | || 3352| | | || 3353| | | || 3354| | | || 3355| | | || 3356| | | || 3357| | | || 3358| | | || 3359| | | || 3360| | | || 3361| | | || 3362| | | || 3363| | | || 3364| | | || 3365| | | || 3366| | | || 3367| | | || 3368| | | || 3369| | | || 3370| | | || 3371| | | || 3372| | | || 3373| | | || 3374| | | || 3375| | | || 3376| | | || 3377| | | || 3378| | | || 3379| | | || 3380| | | || 3381| | | || 3382| | | || 3383| | | || 3384| | | || 3385| | | || 3386| | | || 3387| | | || 3388| | | || 3389| | | || 3390| | | || 3391| | | || 3392| | | || 3393| | | || 3394| | | || 3395| | | || 3396| | | || 3397| | | || 3398| | | || 3399| | | || 3400| | | || 3401| | | || 3402| | | || 3403| | | || 3404| | | || 3405| | | || 3406| | | || 3407| | | || 3408| | | || 3409| | | || 3410| | | || 3411| | | || 3412| | | || 3413| | | || 3414| | | || 3415| | | || 3416| | | || 3417| | | || 3418| | | || 3419| | | || 3420| | | || 3421| | | || 3422| | | || 3423| | | || 3424| | | || 3425| | | || 3426| | | || 3427| | | || 3428| | | || 3429| | | || 3430| | | || 3431| | | || 3432| | | || 3433| | | || 3434| | | || 3435| | | || 3436| | | || 3437| | | || 3438| | | || 3439| | | || 3440| | | || 3441| | | || 3442| | | || 3443| | | || 3444| | | || 3445| | | || 3446| | | || 3447| | | || 3448| | | || 3449| | | || 3450| | | || 3451| | | || 3452| | | || 3453| | | || 3454| | | || 3455| | | || 3456| | | || 3457| | | || 3458| | | || 3459| | | || 3460| | | || 3461| | | || 3462| | | || 3463| | | || 3464| | | || 3465| | | || 3466| | | || 3467| | | || 3468| | | || 3469| | | || 3470| | | || 3471| | | || 3472| | | || 3473| | | || 3474| | | || 3475| | | || 3476| | | || 3477| | | || 3478| | | || 3479| | | || 3480| | | || 3481| | | || 3482| | | || 3483| | | || 3484| | | || 3485| | | || 3486| | | || 3487| | | || 3488| | | || 3489| | | || 3490| | | || 3491| | | || 3492| | | || 3493| | | || 3494| | | || 3495| | | || 3496| | | || 3497| | | || 3498| | | || 3499| | | || 3500| | | || 3501| | | || 3502| | | || 3503| | | || 3504| | | || 3505| | | || 3506| | | || 3507| | | || 3508| | | || 3509| | | || 3510| | | || 3511| | | || 3512| | | || 3513| | | || 3514| | | || 3515| | | || 3516| | | || 3517| | | || 3518| | | || 3519| | | || 3520| | | || 3521| | | || 3522| | | || 3523| | | || 3524| | | || 3525| | | || 3526| | | || 3527| | | || 3528| | | || 3529| | | || 3530| | | || 3531| | | || 3532| | | || 3533| | | || 3534| | | || 3535| | | || 3536| | | || 3537| | | || 3538| | | || 3539| | | || 3540| | | || 3541| | | || 3542| | | || 3543| | | || 3544| | | || 3545| | | || 3546| | | || 3547| | | || 3548| | | || 3549| | | || 3550| | | || 3551| | | || 3552| | | || 3553| | | || 3554| | | || 3555| | | || 3556| | | || 3557| | | || 3558| | | || 3559| | | || 3560| | | || 3561| | | || 3562| | | || 3563| | | || 3564| | | || 3565| | | || 3566| | | || 3567| | | || 3568| | | || 3569| | | || 3570| | | || 3571| | | || 3572| | | || 3573| | | || 3574| | | || 3575| | | || 3576| | | || 3577| | | || 3578| | | || 3579| | | || 3580| | | || 3581| | | || 3582| | | || 3583| | | || 3584| | | || 3585| | | || 3586| | | || 3587| | | || 3588| | | || 3589| | | || 3590| | | || 3591| | | || 3592| | | || 3593| | | || 3594| | | || 3595| | | || 3596| | | || 3597| | | || 3598| | | || 3599| | | || 3600| | | || 3601| | | || 3602| | | || 3603| | | || 3604| | | || 3605| | | || 3606| | | || 3607| | | || 3608| | | || 3609| | | || 3610| | | || 3611| | | || 3612| | | || 3613| | | || 3614| | | || 3615| | | || 3616| | | || 3617| | | || 3618| | | || 3619| | | || 3620| | | || 3621| | | || 3622| | | || 3623| | | || 3624| | | || 3625| | | || 3626| | | || 3627| | | || 3628| | | || 3629| | | || 3630| | | || 3631| | | || 3632| | | || 3633| | | || 3634| | | || 3635| | | || 3636| | | || 3637| | | || 3638| | | || 3639| | | || 3640| | | || 3641| | | || 3642| | | || 3643| | | || 3644| | | || 3645| | | || 3646| | | || 3647| | | || 3648| | | || 3649| | | || 3650| | | |]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1462 通往奥格瑞玛的道路]]></title>
    <url>%2F2018%2F04%2F23%2Fluogu1462%20%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[12345很久没写最短路了题目有点绕看懂之后就是一个二分dijk在开O2下比spfa快（正常也应该快啊。。）deque更快的（O2下，可queue居然是最快的。。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=10008,M=50008;int n,m,b;int a[N];int x,y,z;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[M&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int l,r,mid,ans=INT_MAX;int dis[N];int q[N],he,ta;bool inq[N];inline bool ok()&#123; memset(dis,0x3f,sizeof(dis)); dis[1]=0; he=1;ta=2; q[1]=1; inq[1]=1; while(he!=ta)&#123; int x=q[he]; inq[x]=0; ++he; if(he==10003) he=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(a[e[i].to]&lt;=mid&amp;&amp;dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; if(!inq[e[i].to])&#123; q[ta]=e[i].to; inq[e[i].to]=1; ++ta; if(ta==10003) ta=1; &#125; &#125; &#125; &#125; if(dis[n]&lt;=b) return 1; else return 0;&#125;int main()&#123; n=read();m=read();b=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); r=max(r,a[i]); &#125; l=a[1]; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); addedge(y,x,z); &#125; while(l&lt;=r)&#123; mid=(r-l)/2+l; if(ok())&#123; ans=mid; r=mid-1; &#125; else&#123; l=mid+1; &#125; &#125; if(ans!=INT_MAX) printf(&quot;%d&quot;,ans); else puts(&quot;AFK&quot;); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=10008,M=50008;int n,m,b;int a[N];int x,y,z;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[M&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int l,r,mid,ans=INT_MAX;int dis[N];priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;bool vis[N];inline bool ok()&#123; memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); dis[1]=0; q.push(mp(0,1)); while(!q.empty())&#123; int x=q.top().second; q.pop(); if(vis[x]) continue; vis[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(a[e[i].to]&lt;=mid&amp;&amp;dis[e[i].to]&gt;dis[x]+e[i].f)&#123; dis[e[i].to]=dis[x]+e[i].f; q.push(mp(dis[e[i].to],e[i].to)); &#125; &#125; &#125; if(dis[n]&lt;=b) return 1; else return 0;&#125;int main()&#123; n=read();m=read();b=read(); for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); r=max(r,a[i]); &#125; l=a[1]; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read();z=read(); addedge(x,y,z); addedge(y,x,z); &#125; while(l&lt;=r)&#123; mid=(r-l)/2+l; if(ok())&#123; ans=mid; r=mid-1; &#125; else&#123; l=mid+1; &#125; &#125; if(ans!=INT_MAX) printf(&quot;%d&quot;,ans); else puts(&quot;AFK&quot;); return 0;&#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1341 无序字母对]]></title>
    <url>%2F2018%2F04%2F23%2Fluogu1341%20%E6%97%A0%E5%BA%8F%E5%AD%97%E6%AF%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[12345欧拉回路注意图可能不连通（尽管数据没卡）要求字典序最小的欧拉回路所以要用邻接矩阵注意要倒序输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=58;int n;int a[N][N];char c,ans[N*N];int u,v,rt;int d[N],num;bool vis[N][N],flag;int cnt;inline void getc(int &amp;x)&#123; c=getchar(); while(!(c&gt;=&apos;A&apos;&amp;&amp;c&lt;=&apos;Z&apos;||c&gt;=&apos;a&apos;&amp;&amp;c&lt;=&apos;z&apos;)) c=getchar(); if(c&lt;=&apos;Z&apos;)&#123; x=c-&apos;A&apos;+1; &#125; else&#123; x=c-&apos;a&apos;+27; &#125;&#125;inline char backc(int x)&#123; if(x&lt;=26)&#123; return x+&apos;A&apos;-1; &#125; else&#123; return x+&apos;a&apos;-27; &#125;&#125;inline void dfs(int x)&#123; for(int i=1;i&lt;N;++i)&#123; if(!vis[x][i]&amp;&amp;a[x][i])&#123; vis[x][i]=vis[i][x]=1; dfs(i); &#125; &#125; ans[++cnt]=backc(x);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; getc(u);getc(v); a[u][v]=a[v][u]=1; ++d[u]; ++d[v]; &#125; for(int i=1;i&lt;N;++i)&#123; if(d[i]&amp;1)&#123; ++num; &#125; &#125; if(num!=0&amp;&amp;num!=2)&#123; puts(&quot;No Solution&quot;); return 0; &#125; for(int i=1;i&lt;N;++i)&#123; if(d[i])&#123; if(num==0)&#123; rt=i; break; &#125; else&#123; if(d[i]%2)&#123; rt=i; break; &#125; &#125; &#125; &#125; dfs(rt); if(cnt!=n+1)&#123; puts(&quot;No Solution&quot;); &#125; else&#123; for(int i=cnt;i;--i)&#123; printf(&quot;%c&quot;,ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>欧拉路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】欧拉路&哈密顿路]]></title>
    <url>%2F2018%2F04%2F22%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%AC%A7%E6%8B%89%E8%B7%AF%26%E5%93%88%E5%AF%86%E9%A1%BF%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[12345678910```&lt;!--more--&gt;欧拉路： - 1.存在性判断： 无向图：无奇点等价于欧拉回路；有两个奇点等价于欧拉通路 有向图：所有点的入度都等于出度等价于存在欧拉回路；一个点入度比出度多1，另一个点出度比入度多1等价于欧拉通路 - 2.fleury算法： DFS(u): While (u存在未被删除的边e(u,v)) 删除边e(u,v) DFS(v) End PathSize ← PathSize + 1 Path[ PathSize ] ← u 123456789101112131415 注意有向图的欧拉路要倒序输出 [很好的资料](http://www.cnblogs.com/TheRoadToTheGold/p/8439160.html)哈密顿路（np问题）：- 1.狄拉克定理：如果图G是一个具有$n(n\geq 3)$个顶点的简单无向图，并且图G中每个顶点的度数至少为$n/2$，那么图G是哈密顿图（具有哈密顿回路的图）。（证明：归纳） 奥勒定理（dirac定理的推广）：如果图G是一个具有$n(n\geq 3)$个顶点的简单无向图，并且图G中每一对不相邻的顶点u和v满足$deg(u)+deg(v)\geq n$，那么图G是哈密顿图。 - 2.n(n&gt;=2)阶竞赛图一定存在哈密顿通路。（证明：归纳） 当且仅当竞赛图是强连通的，存在哈密顿回路。（证明：归纳） - 3.竞赛图上的哈密顿回路 先找到一个环，再在环上扩展。 hdu3414 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;climits&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #define mp make_pair #define pb push_back using namespace std; typedef long long LL; typedef pair&lt;int,int&gt; PII; inline LL read() { LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;){if(ch==&apos;-&apos;)f=-1;ch=getchar();} while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();} return x*f; } const int N=1008; int n; int a[N][N]; int nxt[N]; bool vis[N]; bool flag; int cnt; inline bool dfs(int x) { vis[x]=1; if(a[x][1]){ nxt[x]=1; ++cnt; return 1; } for(int i=2;i&lt;=n;++i){ if(!vis[i]&amp;&amp;a[x][i]){ if(dfs(i)){ nxt[x]=i; ++cnt; return 1; } } } return 0; } inline void solve() { memset(nxt,0,sizeof(nxt)); memset(vis,0,sizeof(vis)); cnt=0; if(!dfs(1)){ puts(&quot;-1&quot;); return; } while(1){ flag=0; for(int i=2;i&lt;=n;++i){ if(!nxt[i]){ for(int j=1;j&lt;=n;++j){ if(nxt[j]&amp;&amp;a[j][i]&amp;&amp;a[i][nxt[j]]){ nxt[i]=nxt[j]; nxt[j]=i; ++cnt; flag=1; break; } } } } if(!flag){ break; } } if(cnt==n){ printf(&quot;1&quot;); for(int i=nxt[1];i!=1;i=nxt[i]){ printf(&quot; %d&quot;,i); } puts(&quot;&quot;); } else{ puts(&quot;-1&quot;); } } int main() { while(1){ scanf(&quot;%d&quot;,&amp;n); if(!n) return 0; for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=n;++j){ a[i][j]=read(); } } if(n==1){ puts(&quot;1&quot;); continue; } solve(); } return 0; } ```]]></content>
      <tags>
        <tag>欧拉路</tag>
        <tag>哈密顿路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打鱼记]]></title>
    <url>%2F2018%2F04%2F22%2F%E6%89%93%E9%B1%BC%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1梦游~ 18/4/22 准备好船。坐稳了，老司机要出海打渔了！ 18/4/23 一穷二白的明听闻了来自魔法世界的神秘宝藏，决定坐上他的小木船，去捞上一笔！然而，想要获得钱财，怎能不付出代价？据说神秘宝藏隐藏在“世界尽头”的海域中的一些小岛上。而“世界尽头”，那可是无人生还的禁区！海面之上的风平浪静也掩饰不了它内部的汹涌波涛，而最令人恐惧的，不是那滔天骇浪，而是海上杀手——海灵。海灵是一种能控制水元素的高级元素精灵，人们只在“世界尽头”中发现。而海灵，也只是海岸旁的水生物，那核心区又有什么呢？谁也不知道。为了获得宝藏，明拜访的隐世的魔法师，并学会了她的招牌法术——火球术。用火球术就可以轻松干掉水灵啦！可他不知道，水灵可是水巨人的小喽喽，杀死了水灵会引来水巨人的! 18/4/25 嘚瑟的明被水巨人一拳打飞了… 明再次去找魔法师，希望学会更强的魔法。魔法师告诉明，想要打败水巨人，需要释放掏空一切魔力的毁灭魔法——炎爆术！然而，释放完炎爆术之后，便会精疲力竭，被周围的水灵吞食。聪明的明觉得毁灭不一定是最有效的方法，控制或许能起到更大的效果。于是他学习了能冰冻住别人的冰环——冰霜新星。可是冰环的使用也是有限的，如何巧妙地运用可以决定明最终能拿到几个宝藏。]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F22%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91kd-tree%2F</url>
    <content type="text"><![CDATA[kd-treen个k维空间下的点复杂度O($n^{(k-1)/k}$)待补充]]></content>
  </entry>
  <entry>
    <title><![CDATA[luogu1415 拆分数列]]></title>
    <url>%2F2018%2F04%2F20%2Fluogu1415%20%E6%8B%86%E5%88%86%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[12f[i]表示从前往后到i时，最后一个数为f[i]-i（a-b表示从第a位到第b位），满足数列严格递增的f[i]的最大值g[i]表示从后往前到i时，最后一个数为i-g[i]，满足数列严格递增的g[i]的最大值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=508;char a[N];int n;int f[N],g[N];int pos=1;inline bool cmp(int l1,int r1,int l2,int r2)&#123; while(l1&lt;r1&amp;&amp;a[l1]==&apos;0&apos;) ++l1; while(l2&lt;r2&amp;&amp;a[l2]==&apos;0&apos;) ++l2; if(r1-l1&lt;r2-l2) return 1; if(r1-l1&gt;r2-l2) return 0; int len=r1-l1; for(int i=0;i&lt;=len;++i)&#123; if(a[l1+i]&lt;a[l2+i]) return 1; if(a[l1+i]&gt;a[l2+i]) return 0; &#125; return 0;&#125;inline void dp1()&#123; for(int i=1;i&lt;=n;++i)&#123; f[i]=1; for(int j=i;j&gt;1;--j)&#123; if(cmp(f[j-1],j-1,j,i))&#123; f[i]=j; break; &#125; &#125; &#125;&#125;inline void dp2()&#123; int tmp=f[n]; g[tmp]=n; while(a[tmp-1]==&apos;0&apos;) g[--tmp]=n; for(int i=tmp-1;i;--i)&#123; for(int j=f[n]-1;j&gt;=i;--j)&#123; if(cmp(i,j,j+1,g[j+1]))&#123; g[i]=j; break; &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%s&quot;,a+1); n=strlen(a+1); dp1(); dp2(); while(1)&#123; for(int i=pos;i&lt;=g[pos];++i)&#123; printf(&quot;%c&quot;,a[i]); &#125; pos=g[pos]+1; if(pos&lt;=n)&#123; printf(&quot;,&quot;); &#125; else&#123; break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1070 道路游戏]]></title>
    <url>%2F2018%2F04%2F20%2Fluogu1070%20%E9%81%93%E8%B7%AF%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223dpf[i]表示到i时刻的最大收益sum[k][j]表示第k个机器人前j时间的收益f[i]=max(f[j]+sum[k][i]-sum[k][j]-a[getid(k+j)];其中a[]的下标应该是从k往后走j步的地方记得把f[]初始化成最小的，答案可能是负的这样O($n^3$)就能过了（毕竟pj题）2d/1d考虑优化成2d/0d单调队列i不好放到单调队列里j有限制（j&gt;=i-p），j应该是单调队列的一个下标然而一维并不好处理这个问题q[k][j]表示对每个k的一个单调队列max(f[j]-sum[k][j]-a[getid(k+j)]-&gt;q[k][j]这样对每个i只需要枚举k跑了100+ms然而candy?的代码20+ms但他的代码中有一点问题过不了hackf[i][j]中最大不一定是最好（有后效性）因为step[i][j]=p时，是无法向后转移的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int n,m,p;int a[N],b[N][N],sum[N][N],f[N];inline int getid(int x)&#123; return (x-1)%n+1;&#125;int main()&#123; n=read();m=read();p=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; b[i][j]=read(); &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; sum[i][j]=sum[i][j-1]+b[getid(i+j-1)][j]; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;=m;++i)&#123; f[i]=INT_MIN; &#125; for(int i=1;i&lt;=m;++i)&#123; for(int j=i-1;j&gt;=i-p&amp;&amp;j&gt;=0;--j)&#123; for(int k=1;k&lt;=n;++k)&#123; f[i]=max(f[i],f[j]+sum[k][i]-sum[k][j]-a[getid(k+j)]); &#125; &#125; &#125; printf(&quot;%d&quot;,f[m]); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008;int n,m,p;int a[N],b[N][N],sum[N][N],f[N];int tmp;PII q[N][N];int he[N],ta[N];inline int getid(int x)&#123; return (x-1)%n+1;&#125;int main()&#123; n=read();m=read();p=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; b[i][j]=read(); &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; sum[i][j]=sum[i][j-1]+b[getid(i+j-1)][j]; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;=m;++i)&#123; f[i]=INT_MIN; &#125; for(int i=1;i&lt;=m;++i)&#123; for(int k=1;k&lt;=n;++k)&#123; tmp=f[i-1]-sum[k][i-1]-a[getid(k+i-1)]; while(tmp&gt;q[k][ta[k]].first&amp;&amp;ta[k]&gt;he[k])&#123; --ta[k]; &#125; q[k][++ta[k]]=mp(tmp,i-1); &#125; for(int k=1;k&lt;=n;++k)&#123; while(q[k][he[k]+1].second&lt;i-p)&#123; ++he[k]; &#125; f[i]=max(f[i],q[k][he[k]+1].first+sum[k][i]); &#125; &#125; printf(&quot;%d&quot;,f[m]); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2051 [AHOI2009]中国象棋]]></title>
    <url>%2F2018%2F04%2F18%2Fluogu2051%20%5BAHOI2009%5D%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[12345f[i][j][k]表示到第i行，其中j列有1个，k列有2个转移见代码不要把n和m打错了！！！不要把n和m打错了！！！不要把n和m打错了！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108,mod=9999973;int n,m;int f[N][N][N],ans;int main()&#123; n=read();m=read(); f[0][0][0]=1; for(int i=1;i&lt;=n;++i)&#123; for(int k=0;k&lt;=m;++k)&#123; for(int j=0;j+k&lt;=m;++j)&#123; f[i][j][k]=f[i-1][j][k]; if(j&gt;=1)&#123; f[i][j][k]=(1ll*f[i-1][j-1][k]*(m-k-j+1)%mod+f[i][j][k])%mod; if(j&gt;=2)&#123; f[i][j][k]=(1ll*(m-k-j+2)*(m-k-j+1)/2*f[i-1][j-2][k]%mod+f[i][j][k])%mod; &#125; &#125; if(k&gt;=1)&#123; f[i][j][k]=(1ll*f[i-1][j+1][k-1]*(j+1)%mod+f[i][j][k])%mod; f[i][j][k]=(1ll*(m-k-j+1)*j*f[i-1][j][k-1]%mod+f[i][j][k])%mod; if(k&gt;=2)&#123; f[i][j][k]=(1ll*(j+2)*(j+1)/2*f[i-1][j+2][k-2]%mod+f[i][j][k])%mod; &#125; &#125; &#125; &#125; &#125; /*for(int i=1;i&lt;=n;++i)&#123; for(int k=0;k&lt;=m;++k)&#123; for(int j=0;j+k&lt;=m;++j)&#123; cerr&lt;&lt;i&lt;&lt;&apos; &apos;&lt;&lt;j&lt;&lt;&apos; &apos;&lt;&lt;k&lt;&lt;&apos; &apos;&lt;&lt;f[i][j][k]&lt;&lt;&apos;\n&apos;; &#125; &#125; &#125;*/ for(int j=0;j&lt;=m;++j)&#123; for(int k=0;j+k&lt;=m;++k)&#123; ans+=f[n][j][k]; if(ans&gt;mod)&#123; ans-=mod; &#125; &#125; &#125; printf(&quot;%d&quot;,ans); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108,mod=9999973;int n,m;int f[N][N],ans;int main()&#123; n=read();m=read(); f[0][0]=1; for(int i=1;i&lt;=n;++i)&#123; for(int k=m;k&gt;=0;--k)&#123; for(int j=m-k;j&gt;=0;--j)&#123; f[j][k]=f[j][k]; if(j&gt;=1)&#123; f[j][k]=(1ll*f[j-1][k]*(m-k-j+1)%mod+f[j][k])%mod; if(j&gt;=2)&#123; f[j][k]=(1ll*(m-k-j+2)*(m-k-j+1)/2*f[j-2][k]%mod+f[j][k])%mod; &#125; &#125; if(k&gt;=1)&#123; f[j][k]=(1ll*f[j+1][k-1]*(j+1)%mod+f[j][k])%mod; f[j][k]=(1ll*(m-k-j+1)*j*f[j][k-1]%mod+f[j][k])%mod; if(k&gt;=2)&#123; f[j][k]=(1ll*(j+2)*(j+1)/2*f[j+2][k-2]%mod+f[j][k])%mod; &#125; &#125; &#125; &#125; &#125; for(int j=0;j&lt;=m;++j)&#123; for(int k=0;j+k&lt;=m;++k)&#123; ans+=f[j][k]; if(ans&gt;mod)&#123; ans-=mod; &#125; &#125; &#125; printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2947 Widget Factory]]></title>
    <url>%2F2018%2F04%2F17%2Fpoj2947%20Widget%20Factory%2F</url>
    <content type="text"><![CDATA[12345678910消成对角线的方法就不行了不是方阵消成行阶梯形从now开始以后有系数全为0,但右边不为0的就无解否则now&lt;n多解这题数据挺大的（一般题都是0ms）高斯约旦法在速度上的差异体现出来了会慢100ms左右 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int mod=7,N=308,M=308;int n,m,k;char s[5],t[5];int a[M][N];int cas;int inv[10];inline int sol(char *x)&#123; if(x[0]==&apos;M&apos;) return 1; if(x[0]==&apos;T&apos;&amp;&amp;x[1]==&apos;U&apos;) return 2; if(x[0]==&apos;W&apos;) return 3; if(x[0]==&apos;T&apos;&amp;&amp;x[1]==&apos;H&apos;) return 4; if(x[0]==&apos;F&apos;) return 5; if(x[0]==&apos;S&apos;&amp;&amp;x[1]==&apos;A&apos;) return 6; if(x[0]==&apos;S&apos;&amp;&amp;x[1]==&apos;U&apos;) return 7;&#125;inline int gauss()&#123; register int i,j,k,t,now=1; for(j=1;j&lt;=n;++j)&#123; if(a[now][j]==0)&#123; for(i=now+1;i&lt;=m&amp;&amp;a[i][j]==0;++i); if(i&gt;m) continue; for(k=j;k&lt;=n+1;++k)&#123; swap(a[i][k],a[now][k]); &#125; &#125; for(i=1;i&lt;=m;++i)&#123; if(i!=now&amp;&amp;a[i][j])&#123; t=a[i][j]*inv[a[now][j]]%mod; for(k=j;k&lt;=n+1;++k)&#123; a[i][k]=(a[i][k]-t*a[now][k]%mod+mod)%mod; &#125; &#125; &#125; ++now; &#125; for(int i=now;i&lt;=m;++i)&#123; if(a[i][n+1])&#123; int f=0; for(int j=i;j&lt;=n;++j)&#123; if(a[i][j])&#123; f=1; break; &#125; &#125; if(!f) return -1;//无解 &#125; &#125; if(now&lt;n) return 1;//有自由变量，多解 for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]=a[i][n+1]*inv[a[i][i]]%mod; &#125; return 0;&#125;int main()&#123; inv[1]=1; for(int i=2;i&lt;mod;++i)&#123; inv[i]=mod-mod/i*inv[mod%i]%mod; &#125; while(1)&#123; n=read();m=read(); if(n==0&amp;&amp;m==0) return 0; memset(a,0,sizeof(a)); for(int i=1;i&lt;=m;++i)&#123; k=read(); scanf(&quot;%s%s&quot;,s,t); a[i][n+1]=(sol(t)-sol(s)+1+mod)%mod; while(k--) ++a[i][read()]; for(int j=1;j&lt;=n;++j) a[i][j]%=mod; &#125; cas=gauss(); if(cas==-1)&#123; puts(&quot;Inconsistent data.&quot;); &#125; else if(cas==1)&#123; puts(&quot;Multiple solutions.&quot;); &#125; else&#123; for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%d &quot;,a[i][n+1]&lt;3?a[i][n+1]+mod:a[i][n+1]); &#125; puts(&quot; &quot;); &#125; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int mod=7,N=308,M=308;int n,m,k;char s[5],t[5];int a[M][N];int cas;int inv[10];inline int sol(char *x)&#123; if(x[0]==&apos;M&apos;) return 1; if(x[0]==&apos;T&apos;&amp;&amp;x[1]==&apos;U&apos;) return 2; if(x[0]==&apos;W&apos;) return 3; if(x[0]==&apos;T&apos;&amp;&amp;x[1]==&apos;H&apos;) return 4; if(x[0]==&apos;F&apos;) return 5; if(x[0]==&apos;S&apos;&amp;&amp;x[1]==&apos;A&apos;) return 6; if(x[0]==&apos;S&apos;&amp;&amp;x[1]==&apos;U&apos;) return 7;&#125;inline int gauss()&#123; register int i,j,k,t,now=1; for(j=1;j&lt;=n;++j)&#123; if(a[now][j]==0)&#123; for(i=now+1;i&lt;=m&amp;&amp;a[i][j]==0;++i); if(i&gt;m) continue; for(k=j;k&lt;=n+1;++k)&#123; swap(a[i][k],a[now][k]); &#125; &#125; for(i=now+1;i&lt;=m;++i)&#123; if(a[i][j])&#123; t=a[i][j]*inv[a[now][j]]%mod; for(k=j;k&lt;=n+1;++k)&#123; a[i][k]=(a[i][k]-t*a[now][k]%mod+mod)%mod; &#125; &#125; &#125; ++now; &#125; for(i=now;i&lt;=m;++i)&#123; if(a[i][n+1])&#123; int f=0; for(j=i;j&lt;=n;++j)&#123; if(a[i][j])&#123; f=1; break; &#125; &#125; if(!f) return -1;//ÎÞ½â &#125; &#125; if(now&lt;n) return 1;//ÓÐ×ÔÓÉ±äÁ¿£¬¶à½â for(i=n;i;--i)&#123; for(j=n;j&gt;i;--j)&#123; a[i][n+1]=(a[i][n+1]-a[i][j]*a[j][n+1]%mod+mod)%mod; &#125; a[i][n+1]=a[i][n+1]*inv[a[i][i]]%mod; &#125; return 0;&#125;int main()&#123; inv[1]=1; for(int i=2;i&lt;mod;++i)&#123; inv[i]=mod-mod/i*inv[mod%i]%mod; &#125; while(1)&#123; n=read();m=read(); if(n==0&amp;&amp;m==0) return 0; memset(a,0,sizeof(a)); for(int i=1;i&lt;=m;++i)&#123; k=read(); scanf(&quot;%s%s&quot;,s,t); a[i][n+1]=(sol(t)-sol(s)+1+mod)%mod; while(k--) ++a[i][read()]; for(int j=1;j&lt;=n;++j) a[i][j]%=mod; &#125; cas=gauss(); if(cas==-1)&#123; puts(&quot;Inconsistent data.&quot;); &#125; else if(cas==1)&#123; puts(&quot;Multiple solutions.&quot;); &#125; else&#123; for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%d &quot;,a[i][n+1]&lt;3?a[i][n+1]+mod:a[i][n+1]); &#125; puts(&quot; &quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2065 SETI]]></title>
    <url>%2F2018%2F04%2F17%2Fpoj2065%20SETI%2F</url>
    <content type="text"><![CDATA[123高斯消元解决模线性方程组模数为质数且均相同不同的不会，不是质数的更不会 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=78;int T;int p;int a[N][N];char s[N];int n;inline int ksm(int x,int y)&#123; int tmp=1; while(y)&#123; if(y&amp;1) tmp=tmp*x%p; x=x*x%p; y&gt;&gt;=1; &#125; return tmp;&#125;inline int inv(int x)&#123; return ksm(x,p-2);&#125;inline void gauss()&#123; register int i,j,k,t1,t2; for(int j=1;j&lt;=n;++j)&#123; if(a[j][j]==0)&#123; for(i=j+1;i&lt;=n&amp;&amp;a[i][j]==0;++i); for(k=j;k&lt;=n+1;++k)&#123; swap(a[i][k],a[j][k]); &#125; &#125; t1=inv(a[j][j]); for(i=1;i&lt;=n;++i)&#123; if(i!=j&amp;&amp;a[i][j])&#123; t2=a[i][j]*t1%p; for(k=j;k&lt;=n+1;++k)&#123; a[i][k]=((a[i][k]-t2*a[j][k])%p+p)%p; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]=a[i][n+1]*inv(a[i][i])%p; &#125;&#125;int main()&#123; T=read(); while(T--)&#123; //memset(a,0,sizeof(a)); p=read(); scanf(&quot;%s&quot;,s+1); n=strlen(s+1); for(int i=1;i&lt;=n;++i)&#123; if(s[i]!=&apos;*&apos;) a[i][n+1]=s[i]-&apos;a&apos;+1; else a[i][n+1]=0; a[i][1]=1; for(int j=2;j&lt;=n;++j)&#123; a[i][j]=a[i][j-1]*i%p; &#125; &#125; gauss(); for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%d &quot;,a[i][n+1]); &#125; puts(&quot;&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2962 [USACO09NOV]灯Lights]]></title>
    <url>%2F2018%2F04%2F17%2Fluogu2962%20%5BUSACO09NOV%5D%E7%81%AFLights%2F</url>
    <content type="text"><![CDATA[123456789101112131415高斯消元然后搜索枚举每个自由变量的值为了方便确定自由变量的位置a[i][i]=0表示i是自由变量也就是将系数矩阵消成对角线若对角线上为1，则1上面为0若对角线上为0，则0上面可能有1也就是是说高斯消元不必消成行阶梯形（a[i][j]==0写成a[i][j]，小错误要避免）meet in the middle也能做比高斯消元慢一点（不过感觉搜索的复杂度更没有保证啊。。）代码抄hzwer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=40;int n,m;bitset&lt;N&gt; a[N];int x,y,now;int cnt,ans=INT_MAX,val[N];inline void gauss()&#123; register int i,j; for(int j=1;j&lt;=n;++j)&#123; if(a[j][j]==0)&#123; for(i=j+1;i&lt;=n&amp;&amp;a[i][j]==0;++i); if(i&gt;n) continue; swap(a[j],a[i]); &#125; for(int i=1;i&lt;=n;++i)&#123; if(i!=j&amp;&amp;a[i][j])&#123; a[i]^=a[j]; &#125; &#125; &#125;&#125;inline void dfs(int x)&#123; if(cnt&gt;=ans) return; if(!x)&#123; ans=cnt; return; &#125; if(a[x][x])&#123; int t=a[x][n+1]; for(int j=x+1;j&lt;=n;++j)&#123; if(a[x][j]) t^=val[j]; &#125; val[x]=t; if(t)&#123; ++cnt; dfs(x-1); --cnt; &#125; else&#123; dfs(x-1); &#125; &#125; else&#123; val[x]=0; dfs(x-1); val[x]=1; ++cnt; dfs(x-1); --cnt; &#125;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; a[i][i]=a[i][n+1]=1; &#125; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read(); a[x][y]=a[y][x]=1; &#125; gauss(); dfs(n); printf(&quot;%d&quot;,ans); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=40;int n,m;int x,y;LL ub,a[N];int cnt,ans=INT_MAX;map&lt;LL,int&gt; num;inline void dfs(int x,int tmp,LL key)&#123; if(x&gt;cnt)&#123; if(key==ub)&#123; ans=min(ans,tmp); return; &#125; if(cnt==n)&#123; int t=num[ub-key]; if(t) ans=min(ans,t+tmp); &#125; else&#123; int t=num[key]; if(!t||tmp&lt;t) num[key]=tmp; &#125; return; &#125; dfs(x+1,tmp,key); dfs(x+1,tmp+1,key^a[x]);&#125;int main()&#123; n=read();m=read(); ub=(1ll&lt;&lt;n)-1; for(int i=1;i&lt;=n;++i)&#123; a[i]=1ll&lt;&lt;(i-1); &#125; for(int i=1;i&lt;=m;++i)&#123; x=read();y=read(); a[x]+=1ll&lt;&lt;(y-1); a[y]+=1ll&lt;&lt;(x-1); &#125; cnt=n/2; dfs(1,0,0); cnt=n; dfs(n/2+1,0,0); printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
        <tag>MITM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】非递归exgcd]]></title>
    <url>%2F2018%2F04%2F17%2F%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E9%9D%9E%E9%80%92%E5%BD%92exgcd%2F</url>
    <content type="text"><![CDATA[123456789101112a*1+b*0=aa*0+b*1=b等式右边作辗转相除设ax&apos;&apos;+by&apos;&apos;=t1ax&apos; +by&apos; =t2ax +by =t1-t1/t2*t2令q=t1/t2,r=t1%t2则x=x&apos;&apos;-qx&apos;y=y&apos;&apos;-qy&apos;当r=0时结束 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;int a,b,x,y;inline void exgcd(int a,int b,int &amp;x,int &amp;y)&#123; x=0;y=1; int prevx=1,prevy=0; int q=a/b,r=a%b,t; while(r)&#123; t=x; x=prevx-q*x; prevx=t; t=y; y=prevy-q*y; prevy=t; a=b; b=r; q=a/b; r=a%b; &#125; //return b;//gcd(a,b)=b&#125;int main()&#123; a=read();b=read(); exgcd(a,b,x,y); printf(&quot;%d&quot;,(x%b+b)%b); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2447 [SDOI2010]外星千足虫]]></title>
    <url>%2F2018%2F04%2F16%2Fluogu2447%20%5BSDOI2010%5D%E5%A4%96%E6%98%9F%E5%8D%83%E8%B6%B3%E8%99%AB%2F</url>
    <content type="text"><![CDATA[12345裸的异或方程组注意记录最多用到哪个方程不用bitset不开O2会t3个点当然要用bitset啦（操作复杂度为bitset除以字长，大概就是cpu一次能处理字长长度的bit位吧——bx2k）最快的同学是一边读一边高斯消元的，高级 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008,M=2008;int n,m;int a[M][N];char c;int now=1,ans;inline bool gauss()&#123; register int i,j,k; for(int j=1;j&lt;=n;++j)&#123; if(a[now][j]==0)&#123; for(i=now+1;i&lt;=m&amp;&amp;a[i][j]==0;++i); if(i&gt;m) return 0;//有一个自由变量，多解 ans=max(ans,i);//当前访问的最大行 for(k=j;k&lt;=n+1;++k)&#123; swap(a[now][k],a[i][k]); &#125; &#125; ans=max(ans,j); for(int i=1;i&lt;=m;++i)&#123; if(now!=i&amp;&amp;a[i][j])&#123; for(k=j;k&lt;=n+1;++k)&#123; a[i][k]^=a[now][k]; &#125; &#125; &#125; ++now; &#125; return 1;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; for(int j=1;j&lt;=n+1;++j)&#123; c=getchar(); while(c!=&apos;0&apos;&amp;&amp;c!=&apos;1&apos;) c=getchar(); if(c==&apos;1&apos;)&#123; a[i][j]=1; &#125; &#125; &#125; if(gauss())&#123; printf(&quot;%d\n&quot;,ans); for(int i=1;i&lt;=n;++i)&#123; if(a[i][n+1]) puts(&quot;?y7M#&quot;); else puts(&quot;Earth&quot;); &#125; &#125; else&#123; puts(&quot;Cannot Determine&quot;); &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=1008,M=2008;int n,m;bitset&lt;N&gt; a[M];char c;int now=1,ans;inline bool gauss()&#123; register int i,j,k; for(int j=1;j&lt;=n;++j)&#123; if(a[now][j]==0)&#123; for(i=now+1;i&lt;=m&amp;&amp;a[i][j]==0;++i); if(i&gt;m) return 0; ans=max(ans,i); swap(a[now],a[i]); &#125; ans=max(ans,j); for(int i=1;i&lt;=m;++i)&#123; if(now!=i&amp;&amp;a[i][j])&#123; a[i]^=a[now]; &#125; &#125; ++now; &#125; return 1;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=m;++i)&#123; for(int j=1;j&lt;=n+1;++j)&#123; c=getchar(); while(c!=&apos;0&apos;&amp;&amp;c!=&apos;1&apos;) c=getchar(); if(c==&apos;1&apos;)&#123; a[i][j]=1; &#125; &#125; &#125; if(gauss())&#123; printf(&quot;%d\n&quot;,ans); for(int i=1;i&lt;=n;++i)&#123; if(a[i][n+1]) puts(&quot;?y7M#&quot;); else puts(&quot;Earth&quot;); &#125; &#125; else&#123; puts(&quot;Cannot Determine&quot;); &#125; return 0;&#125; 1别人的代码↓ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;using namespace std;int gi()&#123; int x=0,w=1;char ch=getchar(); while ((ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&amp;&amp;ch!=&apos;-&apos;) ch=getchar(); if (ch==&apos;-&apos;) w=0,ch=getchar(); while (ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;) x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&apos;0&apos;,ch=getchar(); return w?x:-x;&#125;const int N = 1005;int n,m,ele,sol[N];char s[N];bitset&lt;N&gt;a[N],tmp;int main()&#123; n=gi();m=gi(); for (int ans=1;ans&lt;=m;++ans) &#123; scanf(&quot;%s&quot;,s+1);int x=gi(); for (int i=1;i&lt;=n;++i) tmp[i]=s[i]-&apos;0&apos;;tmp[n+1]=x; for (int i=1;i&lt;=n;++i) &#123; if (!tmp[i]) continue; if (!a[i][i]) &#123;a[i]=tmp;++ele;break;&#125; tmp^=a[i]; &#125; if (ele==n) &#123; printf(&quot;%d\n&quot;,ans); for (int i=n;i;--i) &#123; sol[i]=a[i][n+1]; for (int j=n;j&gt;i;--j) if (a[i][j]) sol[i]^=sol[j]; &#125; for (int i=1;i&lt;=n;++i) puts(sol[i]?&quot;?y7M#&quot;:&quot;Earth&quot;); return 0; &#125; &#125; puts(&quot;Cannot Determine&quot;);return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1222 EXTENDED LIGHTS OUT]]></title>
    <url>%2F2018%2F04%2F16%2Fpoj1222%20EXTENDED%20LIGHTS%20OUT%2F</url>
    <content type="text"><![CDATA[12经典的异或方程组bitset用printf输出时要强制转换类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;int T;int tmp;bitset&lt;38&gt; a[38];inline int getid(int x,int y)&#123; return (x-1)*6+y;&#125;inline void gauss()&#123; register int i,j,k,now=1; for(i=1;i&lt;=30;++i)&#123; if(a[now][i]==0)&#123; for(j=now+1;j&lt;=30&amp;&amp;a[j][i]==0;++j); if(j&gt;30) continue; swap(a[now],a[j]); &#125; for(k=1;k&lt;=30;++k)&#123; if(k!=now&amp;&amp;a[k][i]) a[k]^=a[now]; &#125; ++now; &#125;&#125;int main()&#123; T=read(); for(int cas=1;cas&lt;=T;++cas)&#123; printf(&quot;PUZZLE #%d\n&quot;,cas); for(int i=1;i&lt;=30;++i)&#123; a[i].reset(); &#125; for(int i=1;i&lt;=5;++i)&#123; for(int j=1;j&lt;=6;++j)&#123; tmp=getid(i,j); a[tmp][31]=read(); a[tmp][tmp]=1; if(i!=1)&#123; a[tmp][tmp-6]=1; &#125; if(i!=5)&#123; a[tmp][tmp+6]=1; &#125; if(j!=1)&#123; a[tmp][tmp-1]=1; &#125; if(j!=6)&#123; a[tmp][tmp+1]=1; &#125; &#125; &#125; gauss(); for(int i=1;i&lt;=5;++i)&#123; for(int j=1;j&lt;=6;++j)&#123; printf(&quot;%d &quot;,int(a[getid(i,j)][31])); &#125; puts(&quot;&quot;); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj1830 开关问题]]></title>
    <url>%2F2018%2F04%2F16%2Fpoj1830%20%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617高斯消元解决异或方程组异或方程组为a11·x1^a12·x2^...^a1n·xn=y1a21·x1^a22·x2^...^a2n·xn=y2...an1·x1^an2·x2^...^ann·xn=yn增广矩阵为a11 a12 ... a1n y1a21 a22 ... a2n y2...an1 an2 ... ann yn所有a,x,y均是0/1消元的时候将某一行加到另一行相当于某一行异或到另一行（因为是模2的！！）bitset空间消耗更小但是bitset的每一位是1bit，不是c++基本类型，不能^=(a[i]^=j不行，a^=j可以) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=38;int T;int n,a[N][N],x,y,ans;inline int gauss()&#123; register int i,j,k,tmp;//i为行，j为列 for(i=1,j=1;j&lt;=n;++j)&#123; if(a[i][j]==0)&#123; for(tmp=i+1;tmp&lt;=n;++tmp)&#123; if(a[tmp][j]) break; &#125; if(tmp&gt;n) continue; for(k=j;k&lt;=n+1;++k)&#123; swap(a[tmp][k],a[i][k]); &#125; &#125; for(k=1;k&lt;=n;++k)&#123; if(k!=i&amp;&amp;a[k][j])&#123; for(tmp=j;tmp&lt;=n+1;++tmp)&#123; a[k][tmp]^=a[i][tmp]; &#125; &#125; &#125; ++i; &#125; for(j=i;j&lt;=n;++j)&#123; if(a[j][n+1]) return -1; &#125; return 1&lt;&lt;(n-i+1);&#125;int main()&#123; T=read(); while(T--)&#123; memset(a,0,sizeof(a)); n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]=read(); &#125; for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]^=read(); &#125; for(int i=1;i&lt;=n;++i)&#123; a[i][i]=1; &#125; while(1)&#123; x=read();y=read(); if(x==0&amp;&amp;y==0) break; a[y][x]=1; &#125; ans=gauss(); if(ans==-1)&#123; puts(&quot;Oh,it&apos;s impossible~!!&quot;); &#125; else&#123; printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#include&lt;bitset&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=38;int T;int n,x,y,ans;bitset&lt;N&gt; a[N];inline int gauss()&#123; register int i=1,j,k,tmp;//i为行，j为列 for(j=1;j&lt;=n;++j)&#123; if(a[i][j]==0)&#123; for(tmp=i+1;tmp&lt;=n;++tmp)&#123; if(a[tmp][j]) break; &#125; if(tmp&gt;n) continue; swap(a[tmp],a[i]); &#125; for(k=1;k&lt;=n;++k)&#123; if(k!=i&amp;&amp;a[k][j])&#123; a[k]^=a[i]; &#125; &#125; ++i; &#125; for(j=i;j&lt;=n;++j)&#123; if(a[j][n+1]) return -1; &#125; return 1&lt;&lt;(n-i+1);&#125;int main()&#123; T=read(); while(T--)&#123; for(int i=1;i&lt;=n;++i)&#123; a[i].reset(); &#125; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]=read(); &#125; for(int i=1;i&lt;=n;++i)&#123; a[i][n+1]=a[i][n+1]^read(); &#125; for(int i=1;i&lt;=n;++i)&#123; a[i][i]=1; &#125; while(1)&#123; x=read();y=read(); if(x==0&amp;&amp;y==0) break; a[y][x]=1; &#125; ans=gauss(); if(ans==-1)&#123; puts(&quot;Oh,it&apos;s impossible~!!&quot;); &#125; else&#123; printf(&quot;%d\n&quot;,ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu3389 【模板】高斯消元法]]></title>
    <url>%2F2018%2F04%2F16%2Fluogu3389%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1k逆序枚举可以减少中间变量，提高精度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108;const double eps=1e-8;int n;double a[N][N];int tmp;inline bool gauss()&#123; for(int i=1;i&lt;=n;++i)&#123; tmp=i; for(int j=i+1;j&lt;=n;++j)&#123; if(fabs(a[j][i])&gt;fabs(a[tmp][i]))&#123; tmp=j; &#125; &#125; if(tmp!=i)&#123; for(int j=i;j&lt;=n+1;++j)&#123; swap(a[tmp][j],a[i][j]); &#125; &#125; if(fabs(a[i][i])&lt;eps) return 0; for(int j=i+1;j&lt;=n;++j)&#123; for(int k=n+1;k&gt;=i;--k)&#123; a[j][k]-=a[j][i]/a[i][i]*a[i][k]; &#125; &#125; &#125; for(int i=n;i;--i)&#123; for(int j=i+1;j&lt;=n;++j)&#123; a[i][n+1]-=a[i][j]*a[j][n+1]; &#125; a[i][n+1]/=a[i][i]; &#125; return 1;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; a[i][j]=read(); &#125; a[i][n+1]=read(); &#125; if(gauss())&#123; for(int i=1;i&lt;=n;++i)&#123; printf(&quot;%.2lf\n&quot;,a[i][n+1]); &#125; &#125; else&#123; puts(&quot;No Solution&quot;); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2577 [ZJOI2005]午餐]]></title>
    <url>%2F2018%2F04%2F15%2Fluogu2577%20%5BZJOI2005%5D%E5%8D%88%E9%A4%90%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819套路的贪心假如只有一个窗口，可以证明按吃饭时间降序排是最优的先排序然后将人按顺序分到两个窗口这样就可以dp了f[i][j]表示安排完第i个人，第一队的排队时间为j，的最小吃饭时间sum[i]表示前i人的排队时间和f[i][j]=min(f[i][j],max(f[i-1][j],sum[i]-j+a[i].y)) (j=0 to sum[i-1])f[i][j]=min(f[i][j],max(f[i-1][j-a[i].x],j+a[i].x+a[i].y)) (j=a[i].x to sum[i])观察到上下两个方程的范围正好差一个a[i].x可以像01背包一样减一维将j降序遍历还有一个更厉害的做法随机化。。既然是随机化就有风险随机化数组用到n+1就能a了（不管用不用srand(time(0)))开到n+10就会出现wa了（用了70，不用80）随机有风险，考试需谨慎 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=208;int n;struct node&#123; int x,y;&#125;a[N];inline bool cmp(const node &amp;a,const node &amp;b)&#123; return a.y&gt;b.y;&#125;int f[N*N],sum[N];int ans=INT_MAX;int main()&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i].x=read();a[i].y=read(); &#125; sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;++i)&#123; sum[i]=sum[i-1]+a[i].x; &#125; memset(f,0x3f,sizeof(f)); f[0]=0; for(int i=0;i&lt;n;++i)&#123; for(int j=sum[i];j&gt;=0;--j)&#123; if(f[j]==0x3f3f3f3f) continue; f[j+a[i+1].x]=min(f[j+a[i+1].x],max(f[j],j+a[i+1].x+a[i+1].y)); f[j]=max(f[j],sum[i+1]-j+a[i+1].y); &#125; &#125; for(int j=0;j&lt;=sum[n];++j)&#123; ans=min(ans,f[j]); &#125; printf(&quot;%d&quot;,ans); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=208,lim=1e5;int n;int f[N];struct node&#123; int x,y;&#125;a[N];int s1,s2,t1,t2,ans=INT_MAX;inline bool cmp(const node &amp;a,const node &amp;b)&#123; return a.y&gt;b.y;&#125;int main()&#123; //srand(time(0)); n=read(); for(int i=1;i&lt;=n;++i)&#123; a[i].x=read();a[i].y=read(); &#125; sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n+1;++i)&#123; f[i]=i; &#125; for(int k=1;k&lt;=lim;++k)&#123; random_shuffle(f+1,f+n+2); s1=0;s2=0;t1=0;t2=0; for(int i=1;i&lt;=n;++i)&#123; if(f[i]&amp;1)&#123; s1+=a[i].x; t1=max(t1,s1+a[i].y); &#125; else&#123; s2+=a[i].x; t2=max(t2,s2+a[i].y); &#125; &#125; ans=min(ans,max(t1,t2)); &#125; printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1169 [ZJOI2007]棋盘制作]]></title>
    <url>%2F2018%2F04%2F14%2Fluogu1169%20%5BZJOI2007%5D%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[123整张图可以重新分为两类然后悬线法解决极大子正方形和极大子矩阵 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=2008;int n,m,tmp;bool a[N][N];int h[N][N],l[N][N],r[N][N];int ans1,ans2;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; a[i][j]=read(); if((i+j)%2==0)&#123; a[i][j]^=1; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if(a[i][j]==0)&#123; h[i][j]=0; l[i][j]=0; &#125; else&#123; h[i][j]=h[i-1][j]+1; l[i][j]=l[i][j-1]+1; &#125; &#125; for(int j=m;j;--j)&#123; if(a[i][j]==0)&#123; r[i][j]=0; &#125; else&#123; r[i][j]=r[i][j+1]+1; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if(i&gt;1&amp;&amp;a[i-1][j]==1)&#123; l[i][j]=min(l[i][j],l[i-1][j]); r[i][j]=min(r[i][j],r[i-1][j]); &#125; tmp=min(h[i][j],l[i][j]+r[i][j]-1); ans1=max(ans1,tmp*tmp); ans2=max(ans2,h[i][j]*(l[i][j]+r[i][j]-1)); &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if(a[i][j]==1)&#123; h[i][j]=0; l[i][j]=0; &#125; else&#123; h[i][j]=h[i-1][j]+1; l[i][j]=l[i][j-1]+1; &#125; &#125; for(int j=m;j;--j)&#123; if(a[i][j]==1)&#123; r[i][j]=0; &#125; else&#123; r[i][j]=r[i][j+1]+1; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if(i&gt;1&amp;&amp;a[i-1][j]==0)&#123; l[i][j]=min(l[i][j],l[i-1][j]); r[i][j]=min(r[i][j],r[i-1][j]); &#125; tmp=min(h[i][j],l[i][j]+r[i][j]-1); ans1=max(ans1,tmp*tmp); ans2=max(ans2,h[i][j]*(l[i][j]+r[i][j]-1)); &#125; &#125; printf(&quot;%d\n%d&quot;,ans1,ans2); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1273 有线电视网]]></title>
    <url>%2F2018%2F04%2F13%2Fluogu1273%20%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91%2F</url>
    <content type="text"><![CDATA[123456O(n^2)的dp有一个重要的地方每个点的循环大小是它子树中用户节点的个数不加上这个50分每两个点只会在lca产生贡献所以n^2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=3008;int n,m;int x,y,z;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int f[N][N];inline int dfs(int x,int fa)&#123; if(x&gt;n-m)&#123; return 1; &#125; int tot=0; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa)&#123; tot+=dfs(e[i].to,x); for(int j=tot;j;--j)&#123; for(int k=j;k;--k)&#123; f[x][j]=max(f[x][j],f[e[i].to][k]+f[x][j-k]-e[i].f); &#125; &#125; &#125; &#125; return tot;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; f[i][j]=-0x3f3f3f3f; &#125; &#125; for(int i=1;i&lt;=n-m;++i)&#123; z=read(); while(z--)&#123; x=read();y=read(); addedge(i,x,y); addedge(x,i,y); &#125; &#125; for(int i=n-m+1;i&lt;=n;++i)&#123; x=read(); f[i][1]=x; &#125; dfs(1,0); for(int j=n;j&gt;=0;--j)&#123; if(f[1][j]&gt;=0)&#123; printf(&quot;%d&quot;,j); break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树上dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihocoder1063 缩地]]></title>
    <url>%2F2018%2F04%2F13%2Fhihocoder1063%20%E7%BC%A9%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[1234和apple tree很像但是步数特别大，不能作为一维发现收益特别小，将收益作为一维错了一次在于数组开小了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108;int n,a,b,w;int v[N];int ub;int q,d;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int f[N][N&lt;&lt;1][2];//数组开小了！！ //f[i][j][0]表示在i的子树里产生j的收益，且回到i点的最少步数//f[i][j][1]表示在i的子树里产生j的收益的最少步数 inline void dfs(int x,int fa)&#123; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa)&#123; dfs(e[i].to,x); for(int j=ub;j&gt;=1;--j)&#123; for(int k=j;k;--k)&#123; f[x][j][0]=min(f[x][j][0],f[e[i].to][k][0]+f[x][j-k][0]+2*e[i].f); f[x][j][1]=min(f[x][j][1],f[e[i].to][k][0]+f[x][j-k][1]+2*e[i].f); f[x][j][1]=min(f[x][j][1],f[e[i].to][k][1]+f[x][j-k][0]+e[i].f); //cout&lt;&lt;x&lt;&lt;&apos; &apos;&lt;&lt;e[i].to&lt;&lt;&apos; &apos;&lt;&lt;j&lt;&lt;&apos; &apos;&lt;&lt;k&lt;&lt;&apos; &apos;&lt;&lt;f[x][j][0]&lt;&lt;&apos; &apos;&lt;&lt;f[x][j][1]&lt;&lt;&apos; &apos;&lt;&lt;f[e[i].to][k][0]&lt;&lt;&apos; &apos;&lt;&lt;f[i][j-k][0]&lt;&lt;&apos;\n&apos;; &#125; &#125; &#125; &#125;&#125;int main()&#123; memset(f,0x3f,sizeof(f)); n=read(); for(int i=1;i&lt;=n;++i)&#123; v[i]=read(); f[i][v[i]][0]=f[i][v[i]][1]=0; ub+=v[i]; &#125; for(int i=1;i&lt;n;++i)&#123; a=read();b=read();w=read(); addedge(a,b,w); addedge(b,a,w); &#125; dfs(1,0); q=read(); while(q--)&#123; d=read(); for(int j=ub;j&gt;=0;--j)&#123; if(f[1][j][1]&lt;=d)&#123; printf(&quot;%d\n&quot;,j); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树上dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2014 选课]]></title>
    <url>%2F2018%2F04%2F12%2Fluogu2014%20%E9%80%89%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[123做完apple tree以后这题就很简单啦f[i][j]表示i的子树中选j个课程的最大学分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=308;int n,m;int fa;int nume,head[N];struct node&#123; int to,nxt;&#125;e[N];inline void addedge(int x,int y)&#123; e[++nume]=(node)&#123;y,head[x]&#125;;head[x]=nume;&#125;int f[N][N];inline void dfs(int x)&#123; for(int i=head[x];i;i=e[i].nxt)&#123; dfs(e[i].to); for(int j=m;j;--j)&#123; for(int k=1;k&lt;j;++k)&#123; f[x][j]=max(f[x][j],f[e[i].to][k]+f[x][j-k]); &#125; &#125; &#125;&#125;int main()&#123; n=read();m=read();++m; for(int i=1;i&lt;=n;++i)&#123; fa=read();f[i][1]=read(); addedge(fa,i); &#125; dfs(0); printf(&quot;%d&quot;,f[0][m]); return 0;&#125;]]></content>
      <tags>
        <tag>树上dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2486 Apple Tree]]></title>
    <url>%2F2018%2F04%2F12%2Fpoj2486%20Apple%20Tree%2F</url>
    <content type="text"><![CDATA[12345678910好久没写树上dp和背包了看了好久题解每个点权都是非负的所以多余的步数走了也不会使答案变差每一步可以选择停在原地不动f[i][j][0]表示在节点i的子树中走j步，且最终回到i的最大收益f[i][j][1]表示在节点i的子树中走j步的最大收益因为一个子树重复进去是没有收益的所以相当于一个01背包j要从大到小枚举 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108,K=208;int n,k,u,v;int w[N];int nume,head[N];struct node&#123; int to,nxt;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y)&#123; e[++nume]=(node)&#123;y,head[x]&#125;;head[x]=nume;&#125;int f[N][K][2];//f[i][j][0]表示在节点i的子树中走j步，且最终回到i的最大收益//f[i][j][1]表示在节点i的子树中走j步的最大收益 //多余的步数并不影响答案，每一步可以选择停在原地不动 inline void dfs(int x,int fa)&#123; for(int j=0;j&lt;=k;++j) f[x][j][0]=f[x][j][1]=w[x]; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa)&#123; dfs(e[i].to,x); for(int j=k;j&gt;=1;--j)&#123; for(int kk=j-1;kk&gt;=0;--kk)&#123;//从小到大和从大到小是没有影响的 if(j-kk&gt;=2)&#123; f[x][j][0]=max(f[x][j][0],f[e[i].to][kk][0]+f[x][j-kk-2][0]); f[x][j][1]=max(f[x][j][1],f[e[i].to][kk][0]+f[x][j-kk-2][1]); &#125; f[x][j][1]=max(f[x][j][1],f[e[i].to][kk][1]+f[x][j-kk-1][0]); &#125; &#125; &#125; &#125;&#125;int main()&#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF)&#123; nume=1; memset(head,0,sizeof(head)); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;w[i]); &#125; for(int i=1;i&lt;n;++i)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v); addedge(v,u); &#125; dfs(1,0); printf(&quot;%d\n&quot;,f[1][k][1]);//一个优秀的答案总是不会回家的 &#125; return 0;&#125; 1234还有一种写法不合法的情况直接为0赋初值的话只有f[i][0][0]和f[i][0][1]最后在所有步数里面取max就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108,K=208;int n,k,u,v;int w[N];int ans;int nume,head[N];struct node&#123; int to,nxt;&#125;e[N&lt;&lt;1];inline void addedge(int x,int y)&#123; e[++nume]=(node)&#123;y,head[x]&#125;;head[x]=nume;&#125;int f[N][K][2];inline void dfs(int x,int fa)&#123; //for(int j=0;j&lt;=k;++j) f[x][j][0]=f[x][j][1]=w[x]; f[x][0][0]=f[x][0][1]=w[x]; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].to!=fa)&#123; dfs(e[i].to,x); for(int j=k;j&gt;=1;--j)&#123; for(int kk=j-1;kk&gt;=0;--kk)&#123; if(j-kk&gt;=2)&#123; f[x][j][0]=max(f[x][j][0],f[e[i].to][kk][0]+f[x][j-kk-2][0]); f[x][j][1]=max(f[x][j][1],f[e[i].to][kk][0]+f[x][j-kk-2][1]); &#125; f[x][j][1]=max(f[x][j][1],f[e[i].to][kk][1]+f[x][j-kk-1][0]); &#125; &#125; &#125; &#125;&#125;int main()&#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF)&#123; nume=1; memset(head,0,sizeof(head)); memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;w[i]); &#125; for(int i=1;i&lt;n;++i)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addedge(u,v); addedge(v,u); &#125; dfs(1,0); //printf(&quot;%d\n&quot;,f[1][k][1]); ans=0; for(int j=0;j&lt;=k;++j)&#123; ans=max(ans,f[1][j][1]); &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树上dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2805 [NOI2009]植物大战僵尸]]></title>
    <url>%2F2018%2F04%2F11%2Fluogu2805%20%5BNOI2009%5D%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%2F</url>
    <content type="text"><![CDATA[123456789101112131415选某个植物就要选保护它的所有植物典型的最大权闭合子图愉快的打完了一测样例225?发现出现了一个环（良心样例不多见了）怎么去掉环呢tarjan?发现环连出去的点都相当于无敌的所以哪些点是可以被攻击的呢搜索！发现奇怪的性质。。这是topsort!愉快的拓扑一遍，然后重建边再dinic跑一遍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=608;int n,m;int v[N],d[N];int x,y,z;int s,t;int ans;inline int getid(int x,int y)&#123; return (x-1)*m+y;&#125;int nume,head[N],cur[N],headx[N];struct node&#123; int to,nxt,f;&#125;e[N*N*4],ex[N*N];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;inline void insert(int x,int y)&#123; ++d[y]; ex[++nume]=(node)&#123;y,headx[x]&#125;;headx[x]=nume;&#125;bool del[N];int q[N],he,ta;inline void topsort()&#123; for(int i=1;i&lt;=n*m;++i)&#123; if(!d[i]) q[++ta]=i; else del[i]=1; &#125; while(ta)&#123; int x=q[ta];del[x]=0; --ta; for(int i=headx[x];i;i=ex[i].nxt)&#123; --d[ex[i].to]; if(!d[ex[i].to]) q[++ta]=ex[i].to; &#125; &#125;&#125;inline void rebuild()&#123; nume=1; s=0;t=n*m+1; for(int i=1;i&lt;=n*m;++i)&#123; if(!del[i])&#123; if(v[i]&gt;0)&#123; ans+=v[i]; addedge(s,i,v[i]); &#125; else&#123; addedge(i,t,-v[i]); &#125; for(int j=headx[i];j;j=ex[j].nxt)&#123; if(!del[ex[j].to])&#123; addedge(ex[j].to,i,INT_MAX); &#125; &#125; &#125; &#125;&#125;int dis[N];inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=s;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; v[getid(i,j)]=read(); z=read(); while(z--)&#123; x=read();y=read(); ++x;++y; insert(getid(i,j),getid(x,y)); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=2;j&lt;=m;++j)&#123; insert(getid(i,j),getid(i,j-1)); &#125; &#125; topsort(); rebuild(); ans-=dinic(); printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2396 yyy loves Maths VII]]></title>
    <url>%2F2018%2F04%2F11%2Fluogu2396%20yyy%20loves%20Maths%20VII%2F</url>
    <content type="text"><![CDATA[123456很明显的状压看上去挺卡时间的实际也很卡时间开了O2才过懒得优化了O(2^n*n)过24 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=25,mod=1000000007;int n,m;int b[3];int dis[1&lt;&lt;24],f[1&lt;&lt;24];int ub;int main()&#123; n=read(); for(int i=0;i&lt;n;++i)&#123; dis[1&lt;&lt;i]=read(); &#125; m=read(); for(int i=1;i&lt;=m;++i)&#123; b[i]=read(); &#125; ub=1&lt;&lt;n; f[0]=1; for(int i=1;i&lt;ub;++i)&#123; int j=i&amp;-i,k=i; dis[i]=dis[i^j]+dis[j]; if(dis[i]==b[1]||dis[i]==b[2]) continue; while(k)&#123; f[i]+=f[i^j]; if(f[i]&gt;=mod) f[i]-=mod; k^=j; j=k&amp;-k; &#125; &#125; printf(&quot;%d&quot;,f[ub-1]); return 0;&#125;]]></content>
      <tags>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2114 [NOI2014]起床困难综合症]]></title>
    <url>%2F2018%2F04%2F11%2Fluogu2114%20%5BNOI2014%5D%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87%2F</url>
    <content type="text"><![CDATA[12345贪心从高到低每一位考虑放0还是10能造成伤害就放0否则，1能造成就放1否则，不放 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=100008;int n,m,maxi,ans;char s[5];struct node&#123; int type,x; inline int calc(const int &amp;y)&#123; if(type==0)&#123; return x|y; &#125; else if(type==1)&#123; return x&amp;y; &#125; else&#123; return x^y; &#125; &#125;&#125;a[N];inline int solve(int x)&#123; for(int i=1;i&lt;=n;++i)&#123; x=a[i].calc(x); &#125; return x;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s); if(s[0]==&apos;O&apos;)&#123; a[i].type=0; &#125; else if(s[0]==&apos;A&apos;)&#123; a[i].type=1; &#125; else&#123; a[i].type=2; &#125; a[i].x=read(); &#125; for(maxi=1;maxi&lt;=m;maxi&lt;&lt;=1); for(maxi&gt;&gt;=1;maxi;maxi&gt;&gt;=1)&#123; if(solve(0)&amp;maxi)&#123; continue; &#125; if((ans^maxi)&lt;=m&amp;&amp;(solve(maxi)&amp;maxi))&#123; ans^=maxi; &#125; &#125; printf(&quot;%d&quot;,solve(ans)); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu1580 yyy loves Easter_Egg I]]></title>
    <url>%2F2018%2F04%2F11%2Fluogu1580%20yyy%20loves%20Easter_Egg%20I%2F</url>
    <content type="text"><![CDATA[1234坑在于输入windows下每行结束有两个字符，为\r和\nlinux下只有\n以及被钦点的人只要吱声就算成功油炸，不管他是不是@自己 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;int n,num,cnt;string s,name,name2;inline string get(int x)&#123; string tmp=&quot;&quot;; for(int i=x;;++i)&#123; if(s[i]==&apos;\0&apos;||s[i]==&apos; &apos;)&#123; return tmp; &#125; tmp+=s[i]; &#125;&#125;inline string get_at_name()&#123; for(int i=0;i&lt;n;++i)&#123; if(s[i]==&apos;@&apos;)&#123; return get(i+11); &#125; &#125;&#125;inline string get_his_name()&#123; return get(10);&#125;int main()&#123; getline(cin,s,&apos;\r&apos;);getchar();//getchar()处理掉&apos;\n&apos; ++num; n=s.size(); name=get_at_name(); while(1)&#123; getline(cin,s,&apos;\r&apos;);getchar(); if(s==&quot;&quot;)&#123; break; &#125; ++num; n=s.size(); cnt=0; for(int i=0;i&lt;n;++i)&#123; if(s[i]==&apos;@&apos;)&#123; ++cnt; &#125; &#125; name2=get_his_name(); if(name2==name)&#123; cout&lt;&lt;&quot;Successful @yyy loves &quot;&lt;&lt;name&lt;&lt;&quot; attempt\n&quot;; &#125; if(cnt!=1||name!=get_at_name())&#123; cout&lt;&lt;&quot;Unsuccessful @yyy loves &quot;&lt;&lt;name&lt;&lt;&quot; attempt\n&quot;; cout&lt;&lt;num&lt;&lt;&apos;\n&apos;; cout&lt;&lt;&quot;yyy loves &quot;&lt;&lt;name2&lt;&lt;&apos;\n&apos;; return 0; &#125; &#125; cout&lt;&lt;&quot;Unsuccessful @yyy loves &quot;&lt;&lt;name&lt;&lt;&quot; attempt\n&quot;; cout&lt;&lt;num&lt;&lt;&apos;\n&apos;; puts(&quot;Good Queue Shape&quot;); return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj2987 Firing]]></title>
    <url>%2F2018%2F04%2F10%2Fpoj2987%20Firing%2F</url>
    <content type="text"><![CDATA[12345最大权闭合子图最小割一定是简单割，即只割与s或t相连的边在poj交ce，&apos;LONG_LONG_MAX&apos; was not declared in this scope，不知道为什么改成INF就过了用C++编译会ce，G++才能过。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;climits&gt;#include&lt;queue&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=5008,M=60008;const LL INF=1e16;int n,m,u,v;int s,t;int b[N];int num;LL ans;int nume=1,head[N],cur[N];struct node&#123; int to,nxt; LL f;&#125;e[M*2+N*2];inline void addedge(int x,int y,LL z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[N];int q[N],he,ta;inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline LL dfs(int x,LL low)&#123; if(x==t||!low) return low; LL flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline LL dinic()&#123; LL maxflow=0; while(bfs())&#123; for(int i=s;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INF); &#125; return maxflow;&#125;bool vis[N];inline void calc(int x)&#123; vis[x]=1; ++num; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!vis[e[i].to])&#123; calc(e[i].to); &#125; &#125;&#125;int main()&#123; n=read();m=read(); s=0;t=n+1; for(int i=1;i&lt;=n;++i)&#123; b[i]=read(); if(b[i]&lt;0)&#123; addedge(i,t,-b[i]); addedge(t,i,0); &#125; else&#123; ans+=b[i]; addedge(s,i,b[i]); addedge(i,s,0); &#125; &#125; for(int i=1;i&lt;=m;++i)&#123; u=read();v=read(); addedge(u,v,INF); addedge(v,u,0); &#125; ans-=dinic(); calc(s); printf(&quot;%d %lld&quot;,num-1,ans); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uva1515 pool construction]]></title>
    <url>%2F2018%2F04%2F10%2Fuva1515%20pool%20construction%2F</url>
    <content type="text"><![CDATA[123456建图很妙啊最小割的应用注意所有相邻的格子都要连边只要相邻的格子所属的集合不同，这条边就要被割掉注意不要打错变量名（在vjudge上的两个oj交a了，还有一个oj上mle，将空间缩小到1/4就a了，很迷） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=2508;int T;int w,h,d,f,b;int s,t,x,y;int ans;char c,a[58][58];int nume,head[N],cur[N];struct node&#123; int to,nxt,f;&#125;e[N*N*4];int dx[2]=&#123;0,1&#125;,dy[2]=&#123;1,0&#125;,tx,ty;inline int getid(int x,int y)&#123; return (x-1)*w+y;&#125;inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume;&#125;int dis[N];int q[N],he,ta;inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=s;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int main()&#123; T=read(); while(T--)&#123; ans=0; nume=1; memset(head,0,sizeof(head)); w=read();h=read(); s=0;t=w*h+1; d=read();f=read();b=read(); for(int i=1;i&lt;=h;++i)&#123; for(int j=1;j&lt;=w;++j)&#123; c=getchar(); while(c!=&apos;.&apos;&amp;&amp;c!=&apos;#&apos;) c=getchar(); a[i][j]=c; if((i==1||i==h||j==1||j==w))&#123; if(a[i][j]==&apos;.&apos;)&#123; a[i][j]=&apos;#&apos;; ans+=f; &#125; x=getid(i,j); addedge(s,x,INT_MAX); addedge(x,s,0); &#125; &#125; &#125; for(int i=1;i&lt;h;++i)&#123; for(int j=1;j&lt;w;++j)&#123; x=getid(i,j); if(i!=1&amp;&amp;j!=1)&#123; if(a[i][j]==&apos;#&apos;)&#123; addedge(s,x,d); addedge(x,s,0); &#125; else&#123; addedge(x,t,f); addedge(t,x,0); &#125; &#125; for(int k=0;k&lt;2;++k)&#123; tx=i+dx[k]; ty=j+dy[k]; if(tx&lt;1||tx&gt;h||ty&lt;1||ty&gt;w) continue; y=getid(tx,ty); addedge(x,y,b); addedge(y,x,b); &#125; &#125; &#125; printf(&quot;%d\n&quot;,ans+dinic()); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2766 最长不下降子序列问题]]></title>
    <url>%2F2018%2F04%2F09%2Fluogu2766%20%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[123456789第一问lis第二问和第三问都是网络流第二问的建图：s - 1 - i (f[i]==1)i - 1 - i&apos;i&apos; - 1 - j (f[i]+1==f[j]&amp;&amp;a[i]&lt;=a[j]&amp;&amp;i&lt;j)i&apos; - 1 - t (f[i]==ans)第三问只要把(s,1),(1,1&apos;),(n,n&apos;),(n&apos;,t)的流量改成INF82分的原因是加边的时候忘记判a[i]&gt;=a[j] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=508;int n,s,t,tmp;int a[N];int f[N],lis[N],num;int ans;int nume=1,head[N*2],cur[N*2];struct node&#123; int to,nxt,f;&#125;e[N*N*2];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;int dis[N*2];int q[N*2],he,ta;inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int i=head[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=0;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;inline void init()&#123; for(int i=0;i&lt;=t;++i)&#123; for(int j=head[i];j;j=e[j].nxt)&#123; if(j%2==0)&#123; if((i==0&amp;&amp;e[j].to==1) || (i==1&amp;&amp;e[j].to==1+n) || (i==n&amp;&amp;e[j].to==n+n) || (i==n+n&amp;&amp;e[j].to==t))&#123; e[j].f=INT_MAX; e[j^1].f=0; &#125; else&#123; e[j].f+=e[j^1].f; e[j^1].f=0; &#125; &#125; &#125; &#125;&#125;int main()&#123; n=read(); s=0;t=n+n+1; for(int i=1;i&lt;=n;++i)&#123; a[i]=read(); &#125; for(int i=1;i&lt;=n;++i)&#123; if(a[i]&gt;=lis[num])&#123; lis[++num]=a[i]; f[i]=num; &#125; else&#123; tmp=upper_bound(lis+1,lis+num+1,a[i])-lis; lis[tmp]=a[i]; f[i]=tmp; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; ans=max(ans,f[i]); &#125; printf(&quot;%d\n&quot;,ans); for(int i=1;i&lt;=n;++i)&#123; addedge(i,i+n,1); if(f[i]==1) addedge(s,i,1); if(f[i]==ans) addedge(i+n,t,1); for(int j=1;j&lt;i;++j)&#123; if(f[i]==f[j]+1&amp;&amp;a[i]&gt;=a[j])&#123; addedge(j+n,i,1); &#125; &#125; &#125; printf(&quot;%d\n&quot;,dinic()); init(); printf(&quot;%d\n&quot;,dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2774 方格取数问题]]></title>
    <url>%2F2018%2F04%2F09%2Fluogu2774%20%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1234567对最小割还是不熟答案为所有的值减去掉的最小值。去掉的原因是相邻格子不能同时取。黑白染色，也就是要么不取黑，要么不取白相邻的连边 s - black&apos;s key - black - INF - white - white&apos;s key - t那最小割就是去掉的最小值64分的错误原因是用u的奇偶性判断黑白了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=108;int n,m,u,v,s,t;int a[N][N];int dx[4]=&#123;-1,0,0,1&#125;,dy[4]=&#123;0,-1,1,0&#125;,tx,ty;LL ans;inline int getid(int x,int y)&#123; return (x-1)*m+y;&#125;int nume=1,head[N*N],cur[N*N];struct node&#123; int to,nxt,f;&#125;e[N*N*4];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;int dis[N*N];int q[N*N],he,ta;inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125; inline LL dinic()&#123; LL maxflow=0; while(bfs())&#123; for(int i=0;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int main()&#123; n=read();m=read(); s=0;t=n*m+1; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; a[i][j]=read(); ans+=a[i][j]; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; u=getid(i,j); if((i+j)%2==0)&#123; addedge(s,u,a[i][j]); for(int k=0;k&lt;4;++k)&#123; tx=i+dx[k]; ty=j+dy[k]; if(tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;m) continue; v=getid(tx,ty); addedge(u,v,INT_MAX); &#125; &#125; else&#123; addedge(u,t,a[i][j]); &#125; &#125; &#125; printf(&quot;%lld&quot;,ans-dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2763 试题库问题]]></title>
    <url>%2F2018%2F04%2F09%2Fluogu2763%20%E8%AF%95%E9%A2%98%E5%BA%93%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1基础网络流，不要打错变量名！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int K=28,N=1008;int n,m,k,p,tmp;int s,t;int req[K];int ans;int nume=1,head[N+K],cur[N+K];struct node&#123; int to,nxt,f;&#125;e[N*K*2];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;int dis[N+K];int he,ta,q[N+K];inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=0;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;vector&lt;int&gt; plan[K];inline void print()&#123; for(int i=1;i&lt;=n;++i)&#123; for(int j=head[i];j;j=e[j].nxt)&#123; if(j%2==0&amp;&amp;e[j].f==0)&#123;//i/j plan[e[j].to-n].pb(i);//i/j break; &#125; &#125; &#125; for(int i=1;i&lt;=k;++i)&#123; printf(&quot;%d:&quot;,i); for(int j=0;j&lt;plan[i].size();++j)&#123; printf(&quot; %d&quot;,plan[i][j]); &#125; puts(&quot;&quot;); &#125;&#125;int main()&#123; k=read();n=read(); s=0;t=n+k+1; for(int i=1;i&lt;=k;++i)&#123; req[i]=read(); addedge(i+n,t,req[i]); m+=req[i]; &#125; for(int i=1;i&lt;=n;++i)&#123; addedge(s,i,1); p=read(); for(int j=1;j&lt;=p;++j)&#123; tmp=read(); addedge(i,tmp+n,1); &#125; &#125; ans=dinic(); if(ans!=m)&#123; puts(&quot;No Solution!&quot;); &#125; else&#123; print(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2765魔术球问题]]></title>
    <url>%2F2018%2F04%2F08%2Fluogu2765%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[12345正确的做法是网络流若i+j为平方数(i&lt;j), i - 1 - j转化成最小路径覆盖当最小路径覆盖&gt;n时，前一个为答案记得在上一次的残余网络里跑，不用清空流量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=3508;int n,s,t;int ans;int nume=1,head[N],cur[N];struct node&#123; int to,nxt,f;&#125;e[N*N];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],z&#125;;head[y]=nume;&#125;int q[N],he,ta;int dis[N];inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;e[i].f&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp; if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow;&#125;inline int dinic(int x)&#123; int maxflow=0; while(bfs())&#123; cur[0]=head[0]; cur[t]=head[t]; for(int i=1;i&lt;=x;++i)&#123; cur[i]=head[i]; cur[i+1700]=head[i+1700]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int nxt[N],d[N];inline void print(int x)&#123; for(int u=1;u&lt;=x;++u)&#123; for(int i=head[u];i;i=e[i].nxt)&#123; if(i%2==0&amp;&amp;e[i].f==0)&#123; nxt[u]=e[i].to-1700; ++d[e[i].to-1700]; break; &#125; &#125; &#125; for(int u=1;u&lt;=x;++u)&#123; if(d[u]) continue; int i=u; while(i)&#123; printf(&quot;%d &quot;,i); i=nxt[i]; &#125; puts(&quot;&quot;); &#125;&#125; bool vis[4000];int main()&#123; for(int i=1;i&lt;=60;++i)&#123; vis[i*i]=1; &#125; n=read(); s=0;t=3500; for(int i=1;;++i)&#123; addedge(s,i,1); addedge(1700+i,t,1); for(int j=i-1;j;--j)&#123; if(vis[j+i])&#123; addedge(j,1700+i,1); &#125; &#125; ans+=dinic(i); if(i-ans&gt;n)&#123; printf(&quot;%d\n&quot;,i-1); print(i-1); return 0; &#125; &#125; return 0;&#125; 123贪心不知道如何证明贪心正确个人认为当n特别大时能卡掉贪心]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu2764最小路径覆盖问题]]></title>
    <url>%2F2018%2F04%2F08%2Fluogu2764%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1234n个点就是n条路径s-1-x- [有边]*1 -y - 1 -t每次将两个点连在一起就减少1条边，增加1点流量所以最小路径数=n-最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;#define mp make_pair#define pb push_backusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;const int N=308,M=6008; int n,m,u,v,s,t,ans;int nume,head[N];struct node&#123; int to,nxt,f;&#125;e[M*2+N*4];inline void addedge(int x,int y,int z)&#123; e[++nume]=(node)&#123;y,head[x],z&#125;;head[x]=nume; e[++nume]=(node)&#123;x,head[y],0&#125;;head[y]=nume;&#125;int cur[N],dis[N];int he,ta,q[N];inline bool bfs()&#123; memset(dis,0,sizeof(dis)); he=1;ta=2; q[1]=s; dis[s]=1; while(he!=ta)&#123; int x=q[he]; ++he; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].f&amp;&amp;!dis[e[i].to])&#123; dis[e[i].to]=dis[x]+1; if(e[i].to==t) return 1; q[ta]=e[i].to; ++ta; &#125; &#125; &#125; return 0;&#125;inline int dfs(int x,int low)&#123; if(x==t||!low) return low; int flow=0,tmp; for(int &amp;i=cur[x];i;i=e[i].nxt)&#123; if(dis[e[i].to]==dis[x]+1&amp;&amp;(tmp=dfs(e[i].to,min(low,e[i].f))))&#123; flow+=tmp; low-=tmp; e[i].f-=tmp; e[i^1].f+=tmp;//´ò´í+- if(!low) return flow; &#125; &#125; if(low) dis[x]=0; return flow; &#125;inline int dinic()&#123; int maxflow=0; while(bfs())&#123; for(int i=0;i&lt;=t;++i)&#123; cur[i]=head[i]; &#125; maxflow+=dfs(s,INT_MAX); &#125; return maxflow;&#125;int nxt[N],ind[N];inline void print()&#123; /*for(u=0;u&lt;=t;++u)&#123; cout&lt;&lt;&quot;!!&quot;&lt;&lt;u&lt;&lt;&apos;\n&apos;; for(int i=head[u];i;i=e[i].nxt)&#123; cout&lt;&lt;e[i].to&lt;&lt;&apos; &apos;&lt;&lt;e[i].f&lt;&lt;&apos;\n&apos;; &#125; &#125;*/ for(u=1;u&lt;=n;++u)&#123; for(int i=head[u];i;i=e[i].nxt)&#123; if(i%2==0&amp;&amp;e[i].to&gt;n&amp;&amp;e[i].f==0)&#123; nxt[u]=e[i].to-n; ++ind[e[i].to-n]; &#125; &#125; &#125; for(u=1;u&lt;=n;++u)&#123; if(!ind[u])&#123; v=u; while(v)&#123; printf(&quot;%d &quot;,v); v=nxt[v]; &#125; puts(&quot;&quot;); &#125; &#125;&#125;int main()&#123; nume=1; n=read();m=read(); s=0;t=n+n+1; for(int i=1;i&lt;=m;++i)&#123; u=read();v=read(); addedge(u,n+v,1); &#125; for(int i=1;i&lt;=n;++i)&#123; addedge(s,i,1); addedge(n+i,t,1); &#125; ans=dinic(); print(); printf(&quot;%d&quot;,n-ans); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误]]></title>
    <url>%2F2018%2F04%2F08%2F%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[鉴于省选第一轮已经滚粗了。。我把我犯过的错误及对应的题目记下来，以警示自己。 ！！：不容易在调试时发现考试前一定要保持清醒&amp;充足睡眠平时训练一定要保证清醒&amp;充足睡眠 三明治等含有鸡蛋或火腿的食物不要吃！（沙门氏菌） 学会静态+人眼（用脑子）查错！！明明没有改它，为什么它变了？？！！越界了！！检查循环变量！！ 对拍要试试极限数据看看是否超时 交上去一个优秀的暴力（最优化剪枝 浮躁，是人生中最大的错误。 再看漫画或者打游戏就要变小狗了ww隔膜打的多，题目全tm看错！ 不能急，冲动的时候什么都做不了。去洗把脸吧！ 1) 多测没有清空应当清空的数组或变量（包括某些输入的数组）！！ luogu4382 劈配 luogu2055 [ZJOI2009]假期的宿舍 poj3691 DNA repair UVA10652 Board Wrapping hdu6328（调了两天，zyb都没有看出的错误：多测时，n不同，线段树的形态也不同。要注意赋初值和清空时的区别（指分治每层的清空）。and 多测对拍n一直取相同值也是不好的。。） hdu5396（线段树的build要注意对非叶子节点的初始化） 2) 没有去掉调试时的输出（请用cerr!） luogu4365 秘密袭击 3) 邻接表的nume出错（异或时没有成对出现或者第一个nume为0，请int nume=1;) luogu2765 魔术球问题 zkw费用流 4) 变量名/数组名打错(i/j/x,n/m,x/y)(搞错对象)！！ luogu2763 试题库问题 uva1515 pool construction poj2947 Widget Factory luogu2051 [AHOI2009]中国象棋 hdu3414 Tour Route luogu1903 [国家集训队]数颜色 poj2985The k-th Largest Group luogu3502 [POI2010]Hamsters hiho1419 后缀数组四·重复旋律4 UVA11796 Dog Distance luogu3157 [CQOI2011]动态逆序对 luogu3377 【模板】左偏树（可并堆） zroi#363. 陈太阳与乐谱 *2！！ #444. 彩虹糖 ch5103 传纸条（被wyy批判教育了一番） 5) 边界出错(n/n+1）！！ luogu2447 [SDOI2010]外星千足虫 6) 答案忘记更新或者在某处少更新！！修改操作少修改某些值！！ luogu2447 [SDOI2010]外星千足虫 bzoj1453: [Wc]Dface双面棋盘 7) 输出与题意不符（少复制了什么）！！ poj2947 Widget Factory（少输出’.’） bzoj1027 [JSOI2007]合金 （1输成-1） 8) 没有初始化或初始化出错！！(dp等) luogu1070 道路游戏 luogu3502 [POI2010]Hamsters 9) 多测没有把数据读完就输出 hdu3414 Tour Route 10) 做完一个就要break（循环忘记退出）！！ hdu3414 Tour Route 11) (空间）数组开小了（点数算少了/边数算少了）！！ luogu1341 无序字母对 luogu2055 [ZJOI2009]假期的宿舍 luogu1345 [USACO5.4]奶牛的电信Telecowmunication luogu3502 [POI2010]Hamsters luogu2463 [SDOI2008]Sandy的卡片 luogu2657 [SCOI2009]windy数 正睿2018暑期集训AB班刷题营Day2 B. 配对 #378. 【2018普转提day19专题】打架 ch5102 Mobile Service hdu5634 Rikka with Phi（zyb的教导：因为数组越界后会发生什么谁也不知道啊。。wa,tle,red都有可能。。zyf也因为数组开小t了。。） bzoj3123（主席树启发式合并，双log啊，启发式合并空间都要多一个log，因为不能回收利用） csa online xormax trie合并（动态开点至少要2logn，能开3logn更好;zyb:造极限数据输出tot） poj3171（线段树对应的范围要看好了） 12) 输入时出错（出现0之类的，读错，多度，少读）！！ luogu1346 电车 13) 爆int爆int爆int,类型出错，忘记强制类型转换,LL写成int（int×int爆int）！！ luogu1265 公路修建 bzoj4765 普通计算姬 UVA10368 Euclid’s Game（没有数据范围。） 正睿2018暑期集训AB班刷题营Day5 A. 友谊巨轮 bzoj2115 [Wc2011] Xor luogu3066 [Usaco2012 Dec]Running Away From the Barn 南外校内18-10-16 a 南外校内18-10-23 c（前面改过的LL后面相应的没改） bzoj2124: 等差子序列（所有和hash相关的量都要用ll！！） hdu4348 to the moon（要LL！） bzoj4310 hdu5306 bzoj4355 poj1180 14) 程序的顺序出错（逻辑顺序）或者逻辑错误（经常性的错误，不过没有记录，大概是认为和题目有关，实际上是思维严谨性的问题，感性理解之后要严谨的证明） luogu1484 种树 #109. 【17 提高 7】当那一天来临 bzoj2124: 等差子序列（变量名打反） bzoj4892 dna Gym 101194F bzoj3277（长代码就容易出现逻辑错误，请静下心来肉眼查错。错误会比较多，在对拍前先查明显的错误，如k&lt;&lt;=1写成++k..） gym101955B bzoj4310 15) 下标出现负数/下标越界 bzoj4765 普通计算姬 bzoj2124: 等差子序列 16) 题目分析有误 luogu2022 有趣的数 17) max/min设置的有误 luogu3369 【模板】普通平衡树 18) eps设置太小会t 19) (apio2018)使用set查找时尽量不要用pair，对双关键字排序要注意 20) 数组下标打反 bzoj1027 [JSOI2007]合金 21) 程序改一半忘了 bzoj1027 [JSOI2007]合金 22) 对拍忘记srand hiho1419 后缀数组四·重复旋律4 23) 未定义行为 UVA1342 That Nice Euler Circuit（a[i]=point(read(),read())其中读入的顺序可能会反过来） 24) 四舍五入得到-0，正确的姿势是int(x+0.5)。保留1位小数则是printf(“%.1f”,int(a10+0.5)1.0/10); 25) 没有取模！！ 正睿2018暑期集训AB班刷题营Day2 B. 配对 #108. 【17 提高 7】强军战歌 26) (a+=b)%=c 而不是 (a+=b)%c; 27) long long用%d输出 zroi #261. 萌新拆塔（cjq也是！233） 28) 模拟赛中犯的错 没有把所有复制的地方都改正。 用错了变量 dijk没改成小根堆！！好几次了啊！ 29) double写成int luogu4525 【模板】自适应辛普森法1 30) 求割边用fa #359. 【2018普转提day18专题】嘤嘤 31) 1到n的最短路上的边用ds[x]+e[i].f+dt[y]==ds[n]判断，从s或t向外延伸都是错的 #359. 【2018普转提day18专题】嘤嘤 32) memset(a,0x3f,sizeof(a))如果a是指针，sizeof(a)只有8个字节 #359. 【2018普转提day18专题】嘤嘤 33) 数组只开大1而越界了。。 34) 树上dp时sz没有和背包大小取min 南外校内18-10-16 a 35) 以为没爆int实际爆了，三个int相加爆了，以为类型转换了实际没有转。。 南外校内18-10-16 a 36) 递归变量和全局变量重复 #423. 锅锅 37) 使用stl容器前没有判是否为空（如set） #467. 数的距离 38) 涉及图的题目，要注意重边和自环！！ luoguP1850 换教室 39) 注意运输符的结合律，连等的时候要注意变量的改变！ #322. 【Jiangsu Training Contest 5】Graph 40) 输入scanf(“%d”,a+i)写成scanf(“%d”,a+1) bzoj3585╱luogu4137 mex 41) add_ans和ass_ans搞混 csa Min Max Sum 42) bzoj3123专属错误：T是数据类型不是数据组数！！ 43) 题意理解错误/题目读错 bzoj3277（本质相同的子串算多次！！） usaco2018-12ptA rounded down to the nearest integer（向下取整，不是round） 44) 预处理使用n，但n还没有读入（应该用N） gym101955B 45) 动态数据结构在多测时尽量不要用memset，容易mle（好像不用的空间就不算） hdu4348 to the moon 46) 死于未定义行为（而且很难调）（调用顺序，有符号溢出在玄学的优化下gg） gym102028 H 47) priority_queue没有改成小根堆 dijk 19-1-1 B 48) 滚动数组每层要清空！！（或者确保每个值都被重新赋值了） poj2411]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces 891C]]></title>
    <url>%2F2017%2F11%2F19%2Fcodeforces%20891C%2F</url>
    <content type="text"><![CDATA[题意：891C. Envytime limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output For a connected undirected weighted graph $G$, MST (minimum spanning tree) is a subgraph of $G$ that contains all of $G$’s vertices, is a tree, and sum of its edges is minimum possible. You are given a graph $G$. If you run a MST algorithm on graph it would give you only one MST and it causes other edges to become jealous. You are given some queries, each query contains a set of edges of graph $G$, and you should determine whether there is a MST containing all these edges or not. InputThe first line contains two integers $n$, $m$ (2≤$n$,$m$≤5·10$^5$, $n$-1≤$m$) — the number of vertices and edges in the graph and the number of queries. The $i$-th of the next $m$ lines contains three integers $ui$, $vi$, $wi$ ($ui$≠$vi$, 1≤$wi$≤5·10$^5$) — the endpoints and weight of the $i$-th edge. There can be more than one edges between two vertices. It’s guaranteed that the given graph is connected. The next line contains a single integer $q$ (1≤$q$≤5·10$^5$) — the number of queries. $q$ lines follow, the $i$-th of them contains the $i$-th query. It starts with an integer $ki$ (1≤$ki$≤$n$-1) — the size of edges subset and continues with $ki$ distinct space-separated integers from 1 to $m$ — the indices of the edges. It is guaranteed that the sum of $ki$ for 1≤$i$≤$q$ does not exceed 5·10$^5$. OutputFor each query you should print “YES” (without quotes) if there’s a MST containing these edges and “NO” (of course without quotes again) otherwise. Example input 5 7 1 2 2 1 3 2 2 3 1 2 4 1 3 4 1 3 5 2 4 5 2 4 2 3 4 3 3 4 5 2 1 7 2 1 2 output YES NO YES NO 题解：看来lz太弱了，此题被初二大佬yht水过。主要是要想到离线处理。把所有询问的边从小到大考虑，每次考虑一堆相同权值的边。假如当前边的权值为x，则小于x的所有边都已经进行过了kruskal，加进了并查集。对含有权值为x的询问，我们将其中所有权值为x的加入并查集，若出现环，则”NO”。然后要将本次操作涉及的合并还原（重要！）。在完成所有有权值为x的询问后，将这些边真正的加入并查集。复杂度$O(mlogm+\sum ki)$//函数递归的函数名不能写错啊~~ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; PII;inline LL read()&#123; LL x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();&#125; return x*f;&#125;int n,m;int u[500008],v[500008],w[500008],id[500008];int q,k,x;int p1,p2,tmp;int fa[500008];map&lt;int,vector&lt;int&gt; &gt; m1,m2[500008];int qid,l,r;bool vis[500008];int top,val[500008];int *s[500008];inline int find(int x)&#123; return x==fa[x]?x:fa[x]=find(fa[x]);&#125;inline int find2(int x)&#123; if(x==fa[x]) return x; s[++top]=fa+x; val[top]=fa[x]; fa[x]=find2(fa[x]);//调用find2，写成find错了好几次 return fa[x];&#125;inline void del()&#123; while(top)&#123; (*s[top])=val[top];--top; &#125;&#125;inline bool cmp(const int a,const int b)&#123; return w[a]&lt;w[b];&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;++i)&#123; fa[i]=i; &#125; for(int i=1;i&lt;=m;++i)&#123; u[i]=read();v[i]=read();w[i]=read(); id[i]=i; &#125; sort(id+1,id+m+1,cmp); q=read(); for(int i=1;i&lt;=q;++i)&#123; k=read(); for(int j=1;j&lt;=k;++j)&#123; x=read(); if(m1[w[x]].size()==0||m1[w[x]][m1[w[x]].size()-1]!=i) m1[w[x]].push_back(i); m2[i][w[x]].push_back(x); &#125; &#125; for(int i=1;i&lt;=m;++i)&#123; l=i;r=i; while(w[id[r+1]]==w[id[l]]&amp;&amp;r+1&lt;=m) ++r; for(int j=0;j&lt;m1[w[id[i]]].size();++j)&#123; qid=m1[w[id[i]]][j]; if(vis[qid]) continue; for(int k=0;k&lt;m2[qid][w[id[i]]].size();++k)&#123; tmp=m2[qid][w[id[i]]][k]; p1=find2(u[tmp]); p2=find2(v[tmp]); if(p1!=p2)&#123; s[++top]=fa+p1; val[top]=fa[p1]; fa[p1]=p2; &#125; else&#123; vis[qid]=1; break; &#125; &#125; del(); &#125; for(int j=l;j&lt;=r;++j)&#123; tmp=id[j]; p1=find(u[tmp]); p2=find(v[tmp]); if(p1!=p2)&#123; fa[p1]=p2; &#125; &#125; i=r; &#125; for(int i=1;i&lt;=q;++i)&#123; puts(vis[i]?&quot;NO&quot;:&quot;YES&quot;); &#125; return 0;&#125; 欢迎转载或引用，能附上lz的网址就更好啦]]></content>
  </entry>
  <entry>
    <title><![CDATA[NOIP 2017 复赛练习卷（一)game]]></title>
    <url>%2F2017%2F06%2F06%2FNOIP-2017-%E5%A4%8D%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%8D%B7%EF%BC%88%E4%B8%80%EF%BC%89-game%2F</url>
    <content type="text"><![CDATA[题意：小M在玩一个游戏。游戏有N轮，每一轮，系统给出两个数X和Y，她的任务是将当前得到的所有X和Y两两配对，将每对X、Y求和，使得最大的和最小。小M算晕了，于是找你帮忙~【输入格式】输入第一行包含一个整数N（1&lt;=N&lt;=100000）接下来N行，每行两个整数X、Y（1&lt;=X,Y&lt;=100）【输出格式】输出共N行，每行一个整数，对于当前得到的所有X和Y进行配对，输出最大和最小的值。【样例输入】32 83 11 4【样例输出】10109【数据范围】对于50%的数据，N&lt;=200；对于100%的数据，N&lt;=100000。 题解：lz也不会。。但lz有大佬（orz）。大佬的解法基于↓所有只要求{Xi,Yn-i+1}max。但是lz不会做，于是大佬告诉我，x,y小于100，用类似桶排序的方法做。。可是lz还是不会，于是大佬在两分钟内给lz打了一份精辟的代码，但lz并没有能力写得如此精辟，于是只能将就的讲一下lz的方法↓求动态的{Xi,Yn-i+1}max，一般的排序肯定不行。但是x,y的值很小，于是把它们丢到一个[100]的数组里。每次从x从1到100，y从100到1这样搜，并用tx、ty记录x用了几个，y用了几个。这样的每次求解复杂度只有100*2。 代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read()&#123; int x=0;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=x*10+ch-&apos;0&apos;;ch=getchar();&#125; return x;&#125;int n,t,ans,tx,ty;int num[2][108];int main()&#123; n=read(); while(n--)&#123; ans=0;tx=0;ty=0; for(int i=0;i&lt;=1;i++)&#123; t=read(); num[i][t]++; &#125; int j=101; for(int i=1;i&lt;=100;i++)&#123; if(num[0][i])&#123; while(tx&gt;=ty)&#123;//只用当tx&lt;ty时，当前i与当前j才会在同一位置 while(!num[1][--j]); ty+=num[1][j]; &#125; ans=max(ans,i+j); tx+=num[0][i]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;&apos;\n&apos;; &#125; return 0;&#125; 欢迎转载或引用，能附上lz的网址就更好啦]]></content>
  </entry>
  <entry>
    <title><![CDATA[NOIP 2017 复赛练习卷（一)word]]></title>
    <url>%2F2017%2F06%2F04%2FNOIP-2017-%E5%A4%8D%E8%B5%9B%E7%BB%83%E4%B9%A0%E5%8D%B7%EF%BC%88%E4%B8%80%EF%BC%89-word%2F</url>
    <content type="text"><![CDATA[题目：定义：一个 P 单词是指，这个单词不包含 3 个连续的辅音字母，且不包含 3 个连续的元音字母，且至少包含一个字母 L。现有一个由大写字母与下划线构成的单词，要求将所有下划线替换成大写字母，构成一个新的单词，求构成 P 单词的方案数。元音字母是指 A，E，I，O，U，其余字母都是辅音字。【输入】一行，一个字符串（长度不超过 100，下划线个数不超过 10）。【输出】一行，一个整数，表示构成 P 单词的方案数。【样例输入一】LV【样例输出一】5【样例输入二】V _K【样例输出二】10【样例输入三】JA_BU_K_A【样例输出三】485 题解：将元音字母用0表示，辅音字母用1表示。dp[i][j]，其中i=0/1，表示第j位选择i时的总方案数。但是写起来有点麻烦，最后决定听取大佬的建议，换用暴力做↓暴力枚举10个下滑线，再判断。第一遍做的时候没看见必须要有一个L，于是gg。。所有判断原先是否已有L,有了正常做，没有的话↓将得到的方案数减去没有一个L的方案数。记住开long long。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read()string s;int a[108],p[18];int n,num;bool suc;LL ans,tmp=1,gg;inline bool check()&#123; for(int i=1;i&lt;=n-2;i++) if(a[i]==a[i+1]&amp;&amp;a[i]==a[i+2]) return 0; return 1;&#125;void dfs(int t)&#123; if(t&gt;num)&#123; if(check())&#123; ans+=tmp; if(!suc)&#123; gg=tmp; while(gg%21==0&amp;&amp;gg&gt;0)&#123; gg=gg/21*20; &#125; ans-=gg; &#125; &#125; return; &#125; for(int i=0;i&lt;=1;i++)&#123; a[p[t]]=i; if(i==0) tmp*=5; else tmp*=21; dfs(t+1); if(i==0) tmp/=5; else tmp/=21; &#125;&#125;int main()&#123; cin&gt;&gt;s; for(int i=0;i&lt;s.size();i++)&#123; if(s[i]==&apos;L&apos;) suc=1; if(s[i]==&apos;_&apos;)&#123; p[++num]=i+1; &#125; else if(s[i]==&apos;A&apos;||s[i]==&apos;E&apos;||s[i]==&apos;I&apos;||s[i]==&apos;O&apos;||s[i]==&apos;U&apos;) a[i+1]=0; else a[i+1]=1; &#125; n=s.size(); dfs(1); cout&lt;&lt;ans; return 0;&#125; 欢迎转载或引用，能附上lz的网址就更好啦]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Usaco2015 Open Gold]Trapped in the Haybales]]></title>
    <url>%2F2017%2F06%2F03%2FUsaco2015-Open-Gold-Trapped-in-the-Haybales%2F</url>
    <content type="text"><![CDATA[题意：农民约翰已经收到了一批有N个的大型干草包（1&lt;=N&lt;=100,000），并放置在沿着通往他的谷仓的路不同位置。不幸的是，他完全忘记了Bessie牛是放牧的路上，她现在可能被困在那些干草包中！每个干草包J都有一个大小S[J]和一个位置P[J]，提供那个干草包在那个一维道路的位置。贝茜奶牛可以在路上自由走动，甚至到这个干草包所在的位置，但她无法穿越这个位置。作为一个例外，如果她在同一个方向跑D个速度单位，她就可以有足够的速度突破，并永久消除任何干草包，只要那个干草包大小严格小于D。当然，在这之后，她会打开更大的空间让她跑向别的干草包，并消除它们。如果她能突破最左边或最右边的干草包，则贝茜可以逃掉。请计算由实数的起始位置组成的道路最小需要多长，使Bessie不能逃脱。 题目链接：https://www.luogu.org/problem/show?pid=3127 题解：题目好绕啊。。大概就是求Bessie站在哪里逃不出去。。当然可以暴力。。100000，显然只能用O(nlogn)，官方的标程也是用这个复杂度的。假如Bessie从一个很低的区间一直往外冲，结果撞在了很高的一个区间的干草堆上。如果从低区间往高区间求解，不是很亏吗。。于是从高区间向低区间求解↓先把干草堆的高度排递减序，将每个高度值插入set，在set里面二分找它左右相邻的干草堆，如果这个区间正好能把Bessie拦住，就把这个区间内的干草堆标记一下，以后就不用再标记了。这里采用左闭右开，将左边的干草堆标记，右边的不标记。还有一点，数据达到1e9，要离散化。（lz用map）时间复杂度就是O(nlogn)，但由于用了map常数会大跑得慢。。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read()&#123; int x=0;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=x*10+ch-&apos;0&apos;;ch=getchar();&#125; return x;&#125;int n,pos[100008],l,r,ans;struct node&#123; int s,p;&#125;a[100008];map&lt;int,int&gt; m;set&lt;int&gt; s;set&lt;int&gt;::iterator si;bool vis[100008];inline bool cmp(const int a,const int b)&#123;return a&lt;b;&#125;inline bool cmp2(const node a,const node b)&#123;return a.s&gt;b.s;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; a[i].s=read();a[i].p=read(); pos[i]=a[i].p; &#125; sort(pos+1,pos+n+1,cmp); for(int i=1;i&lt;=n;i++) m[pos[i]]=i; sort(a+1,a+n+1,cmp2); s.insert(a[1].p); for(int i=2;i&lt;=n;i++)&#123; if(*s.begin()&lt;a[i].p)&#123; si=--s.upper_bound(a[i].p); l=m[*si];r=m[a[i].p]; if(pos[r]-pos[l]&lt;=a[i].s&amp;&amp;!vis[l])&#123; for(int j=l;j&lt;r;j++) vis[j]=1; &#125; &#125; if(*--s.end()&gt;a[i].p)&#123; si=s.upper_bound(a[i].p); l=m[a[i].p];r=m[*si]; if(pos[r]-pos[l]&lt;=a[i].s&amp;&amp;!vis[l])&#123; for(int j=l;j&lt;r;j++) vis[j]=1; &#125; &#125; s.insert(a[i].p); &#125; for(int i=1;i&lt;n;i++)&#123; if(vis[i]) ans+=pos[i+1]-pos[i]; &#125; cout&lt;&lt;ans; return 0;&#125; 欢迎转载或引用，能附上lz的网址就更好啦]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Usaco2015 Open Gold]Palindromic Paths]]></title>
    <url>%2F2017%2F06%2F02%2FUsaco2015-Open-Gold-Palindromic-Paths%2F</url>
    <content type="text"><![CDATA[题意：从 n×n 的矩阵 左上角走到右下角会有一个长度 n+n+1 的字符串，问有多少种走法使得路径字符串为回文？ 题目链接：https://www.luogu.org/problem/show?pid=3126 （支持洛谷 题解：哇哇哇本人蒟蒻做了好久其实不难。。n=500。。好像只用O(n^3)的方法可以过。。那就dp吧，从（1,1）和（n,n）同时向中间走（lz的第一反应是双向bfs，超时，改成从两头的dp）状态大概就是dp（i,j,k,l），表示走到（i,j）和（k,l）时的方案数，转移↓dp[i][j][k][l]=dp[i-1][j][k+1][l]+dp[i-1][j][k][l+1]+dp[i][j-1][k+1][l]+dp[i][j-1][k][l+1]但是好像会超时超空间。。状态得修改一下↓时间优化：既然是从两头同时走，可以记一下走的步数，再留一个i和k就可以了，这样就变成O(n^3)。dp（s,i,k）像这样就可以了。。lz在网上看到了另一种状态设计↓dp[i][j][k]表示左上结束节点是第i条副对角线上的第j个点，右下结束节点是第n*2-i条副对角线上的第k个点，构成回文的方案数。（引用地址：http://www.cnblogs.com/czllgzmzl/p/5645030.html）其实，我也是按照这位大佬的方法做的，因为k表示起来简单啊（但也有麻烦的地方）转移为dp[s][i][k]=dp[s-1][i-1][k-1]+dp[s-1][i-1][k]+dp[s-1][i][k-1]+dp[s-1][i][k]完了吗？有没有发现要开500^3的数组，爆空间了。。空间优化：dp最常见的空间优化–&gt;滚动数组（能状压的大佬请无视蒟蒻）第一维好像只需要2个（每次只跟前一次状态有关），这样就可以压了 代码：1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MOD=1000000007;int n;LL dp[2][508][508],ans;char a[508][508];bool now,pre;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]+1; if(a[1][1]!=a[n][n])&#123; cout&lt;&lt;&apos;0&apos;; return 0; &#125; now=1;pre=0; dp[now][1][1]=1; for(int step=3;step&lt;=n+1;step++)&#123;//从第二条副对角线到第n+1条，就是走的步数 swap(now,pre); for(int i=1;i&lt;step;i++)&#123; for(int k=1;k&lt;step;k++)&#123; if(a[i][step-i]==a[n-step+1+k][n-k+1])//细心地推一下右下角点的坐标，容易错 dp[now][i][k]=(dp[pre][i-1][k-1]+dp[pre][i-1][k]+dp[pre][i][k-1]+dp[pre][i][k])%MOD; else dp[now][i][k]=0;//滚动数组一定要清零，不然后面会误用前面的值 &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) ans=(ans+dp[now][i][i])%MOD; cout&lt;&lt;ans; return 0;&#125; 欢迎转载或引用，能附上lz的网址就更好啦]]></content>
  </entry>
  <entry>
    <title><![CDATA[first sight]]></title>
    <url>%2F2017%2F05%2F29%2Ffirst-sight%2F</url>
    <content type="text"><![CDATA[哈哈哈 终于建好了！……*￥Z^@!@# 1234567#include&lt;bits/stdc++.h&gt; using namespace std; int main() &#123; cout&lt;&lt;&quot;hello world&quot;; return 0; &#125; hello world 作为第一篇为什么变成传统了呢。。 友情链接：https://li-mi.github.io/]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
