<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="技巧," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="内啡肽：冷静作用促进内啡肽分泌的方式：运动，冥想，深呼吸，笑 多巴胺：预期奖励短期大量释放多巴胺，让我们更追求短期快感，更没耐心。更多的多巴胺或提高阈值，导致更难获得快乐。保持平常心，减少情绪波动，降低多巴胺分泌。">
<meta name="keywords" content="技巧">
<meta property="og:type" content="article">
<meta property="og:title" content="技巧">
<meta property="og:url" content="http://yoursite.com/2018/04/28/技巧/index.html">
<meta property="og:site_name" content="小明的阁楼">
<meta property="og:description" content="内啡肽：冷静作用促进内啡肽分泌的方式：运动，冥想，深呼吸，笑 多巴胺：预期奖励短期大量释放多巴胺，让我们更追求短期快感，更没耐心。更多的多巴胺或提高阈值，导致更难获得快乐。保持平常心，减少情绪波动，降低多巴胺分泌。">
<meta property="og:image" content="https://raw.githubusercontent.com/li-mi/Picture/master/divide%20and%20conquer.jpg">
<meta property="og:updated_time" content="2018-12-06T06:03:25.658Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="技巧">
<meta name="twitter:description" content="内啡肽：冷静作用促进内啡肽分泌的方式：运动，冥想，深呼吸，笑 多巴胺：预期奖励短期大量释放多巴胺，让我们更追求短期快感，更没耐心。更多的多巴胺或提高阈值，导致更难获得快乐。保持平常心，减少情绪波动，降低多巴胺分泌。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/li-mi/Picture/master/divide%20and%20conquer.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/28/技巧/"/>





  <title>技巧 | 小明的阁楼</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小明的阁楼</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">故事再美  结局还是再见</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/28/技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="littleming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小明的阁楼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">技巧</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-28T19:27:55+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>内啡肽：冷静作用<br>促进内啡肽分泌的方式：运动，冥想，深呼吸，笑</p>
<p>多巴胺：预期奖励<br>短期大量释放多巴胺，让我们更追求短期快感，更没耐心。<br>更多的多巴胺或提高阈值，导致更难获得快乐。<br>保持平常心，减少情绪波动，降低多巴胺分泌。</p>
<a id="more"></a>
<p>1.$n$维曼哈顿距离可以变成$2^{n-1}$维契比雪夫距离。（相当于枚举$n-1$个的符号）</p>
<p>2.三分：(2l+r)/3,(l+2r+2)/3</p>
<p>3.对时间建线段树可以代替cdq分治</p>
<p>4.二进制分组</p>
<p>5.离散化：sort+unique+lower_bound<br>sort(a+1,a+n+1);<br>n=unique(a+1,a+n+1)-a-1;<br>查值x：<br>return lower_bound(a+1,a+n+1,x)-b;<br>或者<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</div><div class="line">	a[i].x=read();a[i].id=i;</div><div class="line">&#125;</div><div class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</div><div class="line">last=<span class="number">1</span>;</div><div class="line">b[a[<span class="number">1</span>].id]=<span class="number">1</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</div><div class="line">	<span class="keyword">if</span>(a[i].x!=a[i<span class="number">-1</span>].x)	++last;</div><div class="line">	b[a[i].id]=last;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6.hash：模$2^{31}+1$，设后31位为a，前面为b，原数为$a+b*2^{31}$，模完为$a-b$</p>
<p>7.压位</p>
<p>8.区间众数<br>离线：莫队 $O(n\sqrt{n})$ 右端点递增；左端点固定，每次向左移到询问的位置，结束再撤回<br>在线：(1) 分块+vector二分 $O(n\sqrt{nlogn})$<br>     (2) 分块，对每种值在每个块末尾记录出现次数，$O(n\sqrt{n})$</p>
<p>9.dtx： 倍增替代二分</p>
<p>10.二分图中：最小点覆盖等于最大匹配（最小点覆盖$\geq$最大匹配，且每个匹配中取一个点可以成为点覆盖）<br>            最大独立集+最小点覆盖=点数（独立集是点覆盖的补集）</p>
<p>11.符号：%的值同被除数，/的值根据被除数和除数的符号，相同为正，不相同为负</p>
<p>12.[k/i]一共根号个值，下一个i=k/(k/i)+1</p>
<p>13.printf输出double是四舍五入的，保留两位向下取整就-0.005+eps再输出，向上取整就+0.005-eps再输出<br>   double有15位有效数字<br>   eps应该是小于你能算出来所有数两两之差(xy)<br>   精度误差可以认为在[-1e-13,1e-13]之间</p>
<p>   何时+/-eps凭感觉(xy)<br>   只能详细记录各种情况了：<br>   （负数的四舍五入要看题目定义，故只讨论正数）<br>   拿边界往里带<br>   正数的四舍五入要+eps，（负数可能要-eps)</p>
<p>14.尺规作图只能做加减乘除开方五种运算</p>
<p>15.隔板法要么是隔数字要么是隔位置</p>
<p>16.线性求逆元：inv[i]=(p-p/i)<em>inv[p%i]%p或者inv[i]=p-p/i</em>inv[p%i]%p;<br>   inv[1]=1是一定要写的！</p>
<p>17.最大团和最大独立集是等价的，都是npc<br>   一个图的最大团和取反的图的最大独立集等价</p>
<p>18.高维前缀和要一位一位做<br>   集合的子集和和高维前缀和一样<br>   要一位一位做<br>   否则会重复<br>   001&lt;-000<br>   010&lt;-000<br>   011&lt;-001<br>      &lt;-010<br>   然后发现000在011中出现两次、<br>   应该是<br>   001&lt;-000<br>   011&lt;-010<br>   010&lt;-000<br>   011&lt;-001</p>
<p>19.坐标范围1到n的下凸壳上有sqrt(n)个点</p>
<p>20.A坐标系中的切比雪夫距离=B坐标系中的曼哈顿距离<br>   A坐标系中的曼哈顿距离=B坐标系中的切比雪夫距离（B为A旋转45°，顺时针和逆时针是一样的，因为在互相垂直的坐标系中切比雪夫距离和曼哈顿距离是等价的）<br>   旋转45°,(x,y)-&gt;((x+y)/2,(x-y)/2)</p>
<p>   曼哈顿距离：dis=|x1−x2|+|y1−y2|<br>   切比雪夫距离：dis=max(|x1−x2|,|y1−y2|)<br>   将一个点(x,y)(x,y)的坐标变为(x+y,x−y)(x+y,x−y)后,原坐标系中的曼哈顿距离 == 新坐标系中的切比雪夫距离</p>
<p>   将一个点(x,y)(x,y)的坐标变为((x+y)/2,(x−y)/2)((x+y)/2,(x−y)/2) 后,原坐标系中的切比雪夫距离 == 新坐标系中的曼哈顿距离</p>
<p>21.无向仙人掌图判定：dfs+差分，返祖边的下端点+1，上端点-1，一条边属于&gt;2个环就不是仙人掌，否则是。<br>   有向仙人掌图判定：dfs，找到一个环就暴力的把环上每条边+1</p>
<p>22.$T(n)=2T(n/2)+O(n) =&gt; O(nlogn)$<br>   $T(n)=T(n/2)+O(n) =&gt; O(n)$<br>   $T(n)=4T(n/2)+O(n) =&gt; O(n^2)$</p>
<p>23.处理与询问无关可以用分治</p>
<p>24.打决策点看决策单调性</p>
<p>25.一定要造极限数据！！把int全换成ll再跑一遍看结果之类的。</p>
<p>26.两遍dfs找树的直径不适用于负权（证明需要每条边大于等于0，还是dp管用）<br>   例子：(1) -&gt; 1 -&gt; (2) -&gt; -2 -&gt; (3) -&gt; 2 -&gt; (4)，从2开始就爆炸了</p>
<p>27.$\sum_{i|n}n/i=O(n)*质因数个数(n)$</p>
<p>28.开根复杂度：O(loglogn)牛顿迭代复杂度</p>
<p>29.p1+p2=1则模意义下p1+p2=1(mod p)（要求：设p1=a/b（没有约分时）,(a,p)=1,(b,p)=1）</p>
<p>30.在剩下的数中等概率选，可以等价为：不减少数，在所有数中等概率选，选中不合法的无收益，重来<br>   证明：<br>   $F=\frac{1}{n-1}<em>(f(1)+…+f(n-1))$<br>   $F=\frac{1}{n}</em>(f(1)+…+f(n-1))+\frac{1}{n}F$<br>   显然两式等价</p>
<p>31.treap的删除要注意，删到不存在的节点要停住，不然tle（cjq）</p>
<p>32.rand用48271ll*seed%INT_MAX可以生产1到INT_MAX-1的所有数</p>
<p>33.结构体中的函数可以调用该结构体后面的函数，结构体中不能声明函数。<br>   正常的函数如果出现循环调用要先声明。</p>
<p>34.集合s<br>   遍历s的子集 for(int i=s;i&gt;0;i=(i-1)&amp;s)（没有枚举空集<br>   int x=s;<br>   while(1){<br>       solve();<br>       if(x==0)    break;<br>       x=(x-1)&s;//只有x是s的子集的时候是有效的<br>   }<br>   遍历s的超集 for(int i=s;i&lt;Max;i=(i+1)|s)</p>
<p>35.最短路计数（先判掉0环）<br>   spfa：每次更新后要清0<br>   dijk：不能处理0边？（无0环）</p>
<p>36.dag上dp：拓扑出来或者记忆化搜索，spfa会t啊。</p>
<p>37.可并堆的3种写法：<br>   1.左偏（dist_left&gt;=dist_right)<br>   2.无脑换<br>   3.随机换</p>
<p>38.单调上升转成单调不降通过ai -&gt; ai-i<br>   单调不降转成单调上升通过ai -&gt; ai+i</p>
<p>39.最短路：边多：不加优化的dijk<br>          边少：加堆优化的dijk</p>
<p>40.树上背包有时可以转化成dfs序做（比如必须要是连通的，对于某个点，选就继续，不选就跳过整个子树）</p>
<p>41.有时边存不下仍然是可能可以跑出来的（存边需要乘上一个常数，心中有边即可。。）</p>
<p>42.数组直接做参数会隐式转换为指针，传参的时候a[]和*a是等价的，甚至方括号里写一个长度都是等价的，不过二维或更高维数组只有第一维变成指针</p>
<p>43.手动开栈：-Wl,–stack=/<em>字节数</em>/<br>   -Wl,–stack=1000000000 //开1GB的栈</p>
<p>44.区间加等差数列：维护每个区间加的a+bi（i是第几项）<br>   线段树要求记录的值和tag可以合并</p>
<p>45.bit上的二分：<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//求min(i)，使得sum[i]&gt;=x</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> pos=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)&#123;<span class="comment">//20是logn </span></div><div class="line">		<span class="keyword">if</span>(pos+(<span class="number">1</span>&lt;&lt;i)&lt;=n&amp;&amp;bit[pos+(<span class="number">1</span>&lt;&lt;i)]&lt;=x)&#123;</div><div class="line">			pos+=(<span class="number">1</span>&lt;&lt;i);</div><div class="line">			x-=bit[pos];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> pos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>46.（二维数点）求矩形内点的个数（离线）：<br>   按x排序，在y轴上建树桩，遇到矩形的左边界作减法，遇到矩形的右边界作加法<br>   （在线或带修改）： bit套权值线段树 //<a href="https://blog.csdn.net/popoqqq/article/details/40108669?utm_source=tuicool" target="_blank" rel="external">233</a></p>
<p>47.线段树维护区间gcd：是nlog（做一次辗转相除，gcd减小一倍）</p>
<p>48.noi2016区间，按区间长度排序，左右指针，线段树维护被覆盖的最大值</p>
<p>49.BZOJ 4552 线段树合并？</p>
<p>50.组合数<br>   $(x+1)^n=\sum<em>{i=0}^n(</em>{i}^{n})*x^i$<br>   两边求导后令x=1，可以求得一阶和式<br>   再求导可得二阶和式..<br>   卢卡斯定理（p为质数）<br>   当p=2时，$(<em>{k}^{n})=0$只有n=0,k=1，$(</em>{k}^{n})=1(mod 2)&lt;=&gt;(n and k)==k$</p>
<p>   小根堆，确定树的结构，求不同树的个数：$\frac{n!}{\prod_{x=1}^n sz[x]}$</p>
<p>51.区间可减（求和）比区间合并/区间可加性（min/max）条件更强<br>   猫树只需要满足区间合并，不修改</p>
<ol>
<li>$$f\big|\bigcup_{i=1}^nA<em>i \big|=\sum</em>{i=1}^nf\big|A<em>i\big|-\sum</em>{1&lt;=i&lt;j&lt;=n}f\big|A_i\bigcap A_j\big|+…+(-1)^{n-1}f\big|A_1\bigcap…\bigcap A_n\big|$$</li>
</ol>
<p>53.随机1到i-1作为父亲的树：平均深度O(logn)，期望最大深度logn<br>   prufer编码生成树：期望最大深度O(sqrt(n))，期望平均深度O(logn)</p>
<p>54.斯特林数/卡特兰数/划分数怎么用：<br>   卡特兰数：（以下都是等价的）<br>   通项公式1：$C<em>n=\dfrac{1}{n+1}{C}</em>{2n}^n={C}<em>{2n}^n-{C}</em>{2n}^{n-1}$<br>   通项公式2：$C<em>n=\dfrac{1}{n+1}\sum\limits</em>{i=0}^n\left({C}<em>n^i\right)^2$<br>   递推公式1：$C</em>{n+1}=\dfrac{2(2n+1)}{n+2}C_n,C<em>0=1$<br>   递推公式2：$C</em>{n+1}=\sum\limits_{i=0}^nC<em>iC</em>{n-i},C<em>0=1$<br>   第二类斯特林数：<br>   通项公式：$S(n,k)=\frac{1}{k!}\sum</em>{j=0}^{k}(-1)^{k-j}(^k_j)j^n$<br>   递推公式：$S(n+1,k)=k*S(n,k)+S(n,k-1)$<br>   划分数：<br>   递推公式：$p(n,k)=p(n-k,k)+p(n-1,k-1)$</p>
<p>55.对一堆询问len[l,r]=k，区间只满足可加性，O(n)做法（在线）：在k的倍数的位置划分，向前向后维护一段，每个询问必定过一个划分位置</p>
<p>56.对一堆询问，不存在区间包含，即l1&lt;=l2&lt;=l3&lt;=l4…,r1&lt;=r2&lt;=r3&lt;=r4…，区间只满足可加性，O(n)做法（离线）：以r1为划分向前向后做，这样可以处理所有过r1的询问，当li&gt;r1的时候，每次向左扫只需要扫到上次的r，这样每个点只会从左边和右边各扫一遍</p>
<p>57.可持久化线段树的区间修改：要开2log的空间（因为每层访问最外边的两个节点），标记永久化，每次经过都加上标记即可</p>
<p>58.启发式合并复杂度O(nlognlogn)每个数只会被插入logn次<br>   splay/treap/fhq treap合并是nlogn<br>   启发式合并的空间怎么释放?没有浪费空间，只是更新指针所指的位置</p>
<p>59.线段树合并：一开始n个位置，nlogn个节点，时间复杂度nlogn（每dfs一次就减少一个点，一共就一开始的nlogn个点，合并过程中不开新点了），空间复杂度nlogn</p>
<p>60.区间加等差数列，区间求max：分块（线段树不可做）<br>   区间加等差数列，区间求：线段树</p>
<p>61.<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span>;i++)</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</div><div class="line">     &#123;</div><div class="line">         f[i+<span class="number">1</span>][j][<span class="number">0</span>]=(f[i][j][<span class="number">0</span>]+f[i][j][<span class="number">1</span>])%mo;</div><div class="line">         <span class="keyword">if</span>(lk[i+<span class="number">1</span>]) f[i+<span class="number">1</span>][j+<span class="number">1</span>][<span class="number">1</span>]=f[i][j][<span class="number">0</span>];</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>   怎么ntt？每个链用组合数算，ntt合并</p>
<p>62.S可简单图化：Havel–Hakimi algorithm/Erdős–Gallai theorem<br>   HH是贪心，复杂度O(n^2logn)<br>   EG是结论（？），复杂度O(n)，？</p>
<p>63.找一个图的所有环？tan90</p>
<p>64.点上打标记：(1)子树和 (2)到根的和</p>
<p>65.n^3/64找最短路（边权为1..）<br>   bitset lowbit？</p>
<p>66.取模，除0：记录有多少个0，每次减</p>
<p>67.答案比状态小可以用答案作为状态</p>
<p>68.决策单调性：<br>   1)dp值已知？？分段，先求前面再求后面<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">solve(l,r,opt_l,opt_r)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>&gt;=r)	<span class="keyword">return</span>;</div><div class="line">    mid=(l+r)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span>()<span class="comment">//找到opt_mid</span></div><div class="line">    solve(l,mid,opt_l,opt_mid);</div><div class="line">    solve(mid,r,opt_mid,opt_r);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   2)从1到n依次刷表<br>       栈维护每个决策点和左右端点</p>
<p>69.区间平方和满足四边形不等式（能转化成区间平方之类的大概有可能满足吧）</p>
<p>70.include<bits>要1M空间，不用的空间可能会被优化掉(O2?)</bits></p>
<p>71.子集和问题（一些数的和能否为x）<br>   sum(a)&lt;=n，共O(sqrt(n))个不同的数，O(nsqrtn)的多重背包（多重背包不能压位）<br>   或者把sqrtn个东西二进制拆分，变成01背包，变成O(sqrtnlogn)，然后bitset优化，O(nsqrtnlogn/w)</p>
<p>   对一开始的物品：<br>   2x+1个a =&gt; a，x个2a<br>   2x+2个a =&gt; a，a，x个2a<br>   这样每个物品不超过2个，变成sqrtn个不同数的01背包<br>   复杂度O(nsqrtn/w)</p>
<p>72.V 1e9 n 100<br>   体积 ai<em>2^bi (a&lt;=10,b&lt;=30)<br>   价值 ci (&lt;=1e9)<br>   bi从大到小排序<br>   dp(i,j)表示到第i个物品，实际容量还有j</em>2^bi+V%2^bi<br>   j最大到sum(ai) (记到1000)<br>   改一下dp<br>   dp(w,j)表示到第w个物品，实际容量还有j*2^w+V%2^w</p>
<p>   例题：<br>   1（梦幻岛宝珠）<br>   2体积小的，物品少，V 1e18，完全背包。完全背包的物品可以变成ai<em>2^0,ai</em>2^1…</p>
<p>73.石子合并：有决策单调性，O(n^2)  先按长度dp，每层转移是O(n)</p>
<p>74.合并同余方程：<br>   互质：中国剩余定理<br>   不互质：两两合并（就是解二元一次方程。）<a href="https://blog.csdn.net/sleepiest/article/details/81865741" target="_blank" rel="external">推导</a></p>
<p>75.二次剩余不要搞错：<br>   $x^2=n(mod p)$对每个确定的n在[0,p)上只有一个解<br>   对(p-1)/2+1个n有解</p>
<p>76.((~0)&gt;&gt;1)=-1<br>   ((~0u)&gt;&gt;1)=INT_MAX</p>
<p>   -x=2^32-x</p>
<p>   a^b&lt;=a+b<br>   a^b+2(a&amp;b)=a+b<br>   a^b=a+b &lt;=&gt; a&amp;b=0</p>
<p>   或的单调性<br>   (x|y)&gt;=x</p>
<p>77.bitset解决5维偏序（可以解决k维偏序，复杂度：预处理O(kn)，每次询问O(ksqrtn)）</p>
<p>78.动态加边，求两点路径和？nlogn，启发式合并</p>
<p>79.给定 n 个数 a[1..n]，求有几个子集满足：子集的异或和等于这个子集的AND</p>
<p>80.double的二分姿势：不能卡精度，只能卡次数<br>   while(r-l&gt;eps)是错的。。<br>   for(次数)（推荐写法）<br>   while会停不下来（因为mid=(l+r)/2==l）<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  l=<span class="number">1</span>;</div><div class="line">r=<span class="number">123456789123.123</span>;</div><div class="line"><span class="keyword">while</span>(r-l&gt;eps)&#123;</div><div class="line">	mid=(l+r)/<span class="number">2</span>;</div><div class="line">	l=mid;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%.10f %.10f %.10f\n"</span>,l,r,mid);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   [-A,A]的外接圆的半径是A^2级别的<br>   二分用sqrt(l*r)可以次数更少。(l,r&gt;0)<br>   函数对long doulbe有单独的版本</p>
<p>89.$[\frac {[\frac{a}{b}]}{c}]=[\frac{a}{bc}]$ 画画线段就能证明</p>
<p>90.knight’s tour：<br>   n<em>n中，n&gt;=5存在哈密尔顿路径，n&gt;=6且n为偶数存在哈密尔顿回路（证明见wiki）<br>   n</em>m中，只要min(n,m)&gt;=5则存在哈密尔顿路径，无证明（搜索证明。。</p>
<p>91.double的三分姿势<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意卡次数</span></div><div class="line"><span class="comment">//mid1=l+(r-l)/3;</span></div><div class="line"><span class="comment">//mid2=l+(r-l)/3*2;</span></div><div class="line">mid1=(<span class="number">2</span>*l+r)/<span class="number">3</span>,mid2=(l+<span class="number">2</span>*r)/<span class="number">3</span>;</div><div class="line"><span class="comment">//2种结果一样的三分方式，这种时间竟然是注释掉的那种的1/4，神奇</span></div></pre></td></tr></table></figure></p>
<p>   int的三分姿势<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(l+<span class="number">9</span>&lt;=r)&#123;</div><div class="line">    ll=l+(r-l)/<span class="number">3</span>;</div><div class="line">    rr=r-(r-l)/<span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(l to r)	update(ans);</div></pre></td></tr></table></figure></p>
<p>92.常见npc：</p>
<ul>
<li>哈密尔顿回路（哈密尔顿路径不是，但是依旧没有多项式算法）</li>
<li>tsp</li>
<li>图同构：图G1是否与图G2同构？<br>子图同构：图G1是否与图G2的任一子图同构？<br>子图同构问题是NPC，而图同构问题一般认为不是P也不是NPC问题，虽然它明显是一个NP问题。这是一个典型被认为很难却还不是NPC问题的例子。</li>
<li>3sat及以上</li>
<li>背包</li>
<li>一般图染色</li>
<li>子集和问题</li>
<li>全排列问题</li>
<li>n皇后问题<br>常见np-hard：</li>
<li>求图的最长路</li>
<li>一般图最大团</li>
<li>一般图最大独立集<br>常见np：</li>
<li>拓扑图计数</li>
</ul>
<p>93.(a|b)+(a&amp;b)=a+b</p>
<p>94.c++03的东西：<br>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">timeb tim;</div><div class="line">ftime(&amp;tim);</div><div class="line">srand(tim.time*<span class="number">1000</span>+tim.millitm);</div></pre></td></tr></table></figure></p>
<p>95.set<pii,cmp> s;<br>   重载方式：<br>   1.直接重载pair的比较方式<br>     在全局写bool operator &lt; (const pii &amp;a,const pii &amp;b)<br>   2.在这个set里面重载<br>     struct cmp{<br>         bool operator () (const pii &amp;a,const pii &amp;b){</pii,cmp></p>
<pre><code>   }
}
</code></pre><p>96.a&lt;b，b&lt;c，如果能推出a&lt;c</p>
<p>97.()后的const表示当前结构体，什么时候要用？库函数（不修改this）<br>   friend什么时候要用？有private，和写外面一样</p>
<p>98.模拟退火<br>   爬山（凸函数，也就是只有一座山峰）</p>
<p>99.要对10以内的c敏感 from dtx</p>
<p>100.局部到整体</p>
<p>101.全序关系才能排序，偏序关系只能拓扑排序</p>
<p>102.dijk用堆优化mlogn<br>        用桶优化O(n+m+最大权值)，用指针维护（权值递增）</p>
<ol>
<li>/：根目录<br>/home/noilinux/或~/：当前用户的目录<br>ls：显示当前列表<br>ls + 路径：显示路径下的列表<br>cd + 路径：/home（绝对路径） 或 Desktop（相对路径）或 cd ..（返回上一层）<br>/./：当前路径<br>/../：上层路径<br>mkdir：创建文件夹<br>rm -r + 目录：删除当前目录及里面所有的东西（-r 递归地删）<br>sf_sharefold和/不是同级的：在/下的某个文件夹内<br>touch + 文件名：（创建文件）修改文件的修改日期（没有就创建）<br>cat + 文件 + 文件：（显示文件内容）将几个文件的内容显示出来<br>mv + 文件 + 路径：将文件移动到路径下<br>cp + 文件 + 路径：将文件复制到路径下<br>将文件复制到文件：<br>1.cp + 文件 + 文件<br>2.cat + 文件 + &gt;文件<br>mv和cp 都要加-r才能对文件夹操作<br>;可以隔开两个命令<br>echo或printf：输出<br>\;可以输出;<br>“”可以把东西搞成字符串<br>echo + 信息 + &gt;文件：将信息覆盖到文件<br>echo + 信息 + &gt;&gt;文件：将信息追加到文件后<br>0：stdin<br>1：stdout<br>2：stderr<br>ctrl+c：退出当前命令<br>ctrl+z：将当前命令压到栈中<br>fg：将命令从栈中弹出<br>ctrl+d：EOF<br>diff + 文件 + 文件：相同为0，不同不为0<br>g++<br>  -Wall：显示所有warning<br>  -O0 -O1 -O2 -O3 -Ofast：加速<br>  -g：生成给调试器用的信息<br>  -lm：链接数学库（不加也行）<br>  -o + 文件：输出到指定文件<br>  -std=c++11<br>  -Wl,–stack=/<em>栈的大小，单位字节</em>/<br>bash + a.sh：用bash运行文件</li>
</ol>
<p>104.+-1rmq：按len=logn/2分块，对整块作st表，复杂度O(n)<br>            对块内进行预处理，本质不同的块一共O(2^len)=O(sqrt(n))个，对这些块的每个[l,r]都暴力预处理，复杂度O(sqrt<em>log</em>log)<br>            查询O(1)<br>105.dag中求：<br>    1)一个点能到的点数：O(n<em>n/32)，bitset优化暴力<br>    2)拓扑序的个数：状压，O(2^n</em>n)</p>
<p>106.<br>%d–&gt; for int</p>
<p>%u–&gt; for unsigned int</p>
<p>%ld–&gt; for long int</p>
<p>%lu–&gt; for unsigned long int</p>
<p>%lld–&gt; for long long int</p>
<p>%llu–&gt; for unsigned long long int</p>
<p>107.char[][]（一堆字符串）进行排序：新开一个位置数组，对这个数组排序</p>
<p>108.namespace是个好东西，在外面的变量还是全局的，除了可以重变量名没啥特别。</p>
<p>109.字符串hash冲突的概率：使用次数^2/模数大小（和生日悖论差不多？），要双hash</p>
<p>110.#define rep(形参，形参，…) 替换列表<br>    例如：</p>
<pre><code>#define rep(i,x,y) for(int i=(x);i&lt;=(y);++i)//记得打括号，不然传1&lt;&lt;n就挂了
</code></pre><p>111.二维数组传参(int a[x][y])或者(int a[][y])，只有第一维可以不写！</p>
<p>112.rand()是通过线性递推<br>    windows下模32768<br>    rand()%(2^x)有周期，大概1e5<br>    更好的随机数是<br>    mt19937 mt(/<em>随机数种子</em>/);<br>    设置种子的第二种方法：<br>    mt.seed(/<em>随机数种子</em>/);<br>    在<random>里面（c++11）</random></p>
<pre><code>mt19937 mt(time(0));
mt();//返回一个随机数
mt.min();//mt的最小值0
mt.max();//mt的最大值2^32-1

mt19937_64 mt(time(0));
mt();
mt.max();//最大值为2^64-1

注意u和llu输出
</code></pre><p>113.dijk不用vis每次判断和最小值是否相同即可，pq写大根堆也会得到正确的结果（但是会t）</p>
<p>114.高斯消元复杂度：n<em>m</em>min(n,m)</p>
<p>115.邻接表判重边：</p>
<p>116.k叉哈夫曼树可以O(n)构造：<br>    桶排，然后用两个队列<br>    k叉哈夫曼树的dp<br>    f[i][j]表示已经做完了前i个元素，还空出j个叶子节点的最小代价<br>    f[0][1]=0,其他为inf<br>    第二维最大为大于n的2的幂<br>    $f[i+1][j-1]=min(f[i][j]),f[i][j*k]=min(f[i][j]+\sum_{p=i+1}^{n}a[p])$<br>    $ans=min(f[n][p])(0&lt;=p&lt;n)$</p>
<pre><code>#458. 我才不是萝莉控呢
这题和哈夫曼树的dp有类似
但是有些不同
将dp的含义改成f[i][j]表示做完前i-1个元素即可
要求的答案也是f[n][1]，因为最后放完一定没有空节点
</code></pre><p>117.tr1是c++03的using namespace tr1;（在using std之后加）<br>    头文件如#include<tr1 unordered_map=""></tr1></p>
<p>118.保序回归：<br>    将数列a调整成单调不降的最小代价，a调整为b的代价为|a-b|<br>    调整为单调上升则对ai-=i<br>    原因：<br>    维护的每个点可以到达的最低距离<br>    只有当再次小于最低距离后才要继续更新答案</p>
<pre><code>做法出处：http://codeforces.com/blog/entry/47094?#comment-315161
写的好看的dp：https://blog.csdn.net/Vectorxj/article/details/78793739
仔细思考发现，考虑函数图像并不能很好的解释（或者我太弱了
本质还是维护到达的最低距离
但是原来的理解有些偏差
记f[i]表示考虑[1,i]的答案
那么f[i]是单调不降的
（注意题解中的fi[x]是下凸的，没有斜率为非负的线段）
pq中存的是不改变当前答案的情况下，能变成的最低的情况
因为fi[opt[i]]=fi-1[opt[i-1]]+opt[i-1]-a[i]
所以尽量把opt[i]变小，就是把大的往下拉（注意拉完之后并不是合法的序列，只是保证有1.满足答案2.最大值是opt[i] 的序列）
当所有opt[i]都变小以后，最大值就变小了
反正就是不太容易理解

cjq太强了
cf的做法是维护折线
维护折线一般要维护横纵坐标或者斜率什么的
这题只需要维护横坐标和斜率
一个点和下一个点的斜率为严格比这个点大的点的个数
因为斜率的变化只有+-1
可以通过加点和删点来维护
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  priority_queue&lt;int&gt; q;</div><div class="line">  q.push(a[1]);</div><div class="line">  for(int i=2;i&lt;=half_n;++i)&#123;</div><div class="line">	if(q.top()&gt;a[i])&#123;</div><div class="line">		ans+=q.top()-a[i];</div><div class="line">		q.pop();</div><div class="line">		q.push(a[i]);</div><div class="line">	&#125;</div><div class="line">	q.push(a[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>119.vector<int>()表示空vector</int></p>
<p>120.一般图四元环：n^3/32<br>    二分图四元环：msqrt(m)，分大小点</p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">	f[i] = a[i];</div><div class="line">&#125;</div><div class="line">for (int i = 1; i &lt;= n; i++) &#123;</div><div class="line">	for (int j = 2 * i; j &lt;= n; j += i) &#123;</div><div class="line">		f[j] -= f[i];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当a[i]=i时，f[i]=\phi(i)<br>猜一波结论：<br>$$when\ \varphi(i)\neq<br>0,f[i]=(\sum<em>{j|i}\mu(j)\cdot a[j])\cdot\mu(i)$$<br>$$when\ \varphi(i)=0,t=\text{product of every prime factor of i},f[i]=(\sum</em>{j|t}\mu(j)\cdot a[j\cdot\frac{i}{t}])\cdot \mu(t)$$</p>
<p>122.ctrl+m：把dev分成左右两个窗口</p>
<p>123.f[i]表示二进制下是i的超集的数的个数<br>    先枚举某一位j，再枚举i（从小到大和从大到小都可以，因为每一位只有0/1）<br>    f[i^(1&lt;<j)]+=f[i] <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   for(int j=0;j&lt;=20;j++)</div><div class="line">&#123;</div><div class="line">	for(int i=1;i&lt;=maxx;i++)</div><div class="line">	&#123;</div><div class="line">		if(((1&lt;&lt;j)&amp;i))</div><div class="line">		&#123;</div><div class="line">			dp[i^(1&lt;&lt;j)]+=dp[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></j)]+=f[i]></p>
<p>相当于高维前缀和，每一维只有2<br><a href="http://www.cnblogs.com/Miracevin/p/9778266.html" target="_blank" rel="external">好博客~！</a></p>
<p>124.对vector<int> a进行排序去重<br>    sort(a.begin(),a.end());<br>    a.resize(unique(a.begin(),a.end())-a.begin());</int></p>
<p>125.a+b=1在模意义下为a+b=1(mod p) </p>
<p>126.求本质不同的子序列个数：<br>    dp[i]表示 1-i 的方案数 ， dp[i] = 2*dp[i-1] - dp[pre[i]-1]  （pre[i]是之前一个和i颜色一样的位置） from fsr<br>    dp[0]=1;<br>    空子序列也算在里面了，O(n)</p>
<p>127.求区间mex：<br>    1)离线：<br>      有两种：<br>      一、按l从小到大排序，[l,r]-&gt;[l+1,r]就是把a[l]删掉，会对r&lt;nxt[a[l]]的询问产生影响，update(l,nxt[a[l]-1,a[l])，即用a[l]去更新最小值<br>      二、按r从小到大排序，last[x]表示x这个值最后出现的位置（到r为止），要找最小的x，使得last[x]&lt;l，线段树上二分<br>    2)在线：主席树</p>
<pre><code>3)带修改：树套树？
</code></pre><p>128.linux下scanf比较快，跟fread差不多，<del>不需要手写快读（数值大的时候还是要手写快读。）</del><br>    一定要用getchar快读！！</p>
<pre><code>scanf：
int -&gt; %d
long long -&gt; %lld
unsigned int -&gt; %u
unsigned long long -&gt; %llu
float -&gt; %f
double -&gt; %lf
long double -&gt; %Lf
char -&gt; %c
char a[] -&gt; %s

printf：
int -&gt; %d
long long -&gt; %lld
unsigned int -&gt; %u
unsigned long long -&gt; %llu
float -&gt; %f
double -&gt; %f （和scanf不一样！）
long double -&gt; %Lf
char -&gt; %c
char a[] -&gt; %s
</code></pre><p>129.小凯的疑惑：<br>    设答案为x<br>    显然存在n，使得x=na(mod b)(0&lt;=n<b) ==""> x=na+mb(m&lt;0)<br>    所以x的最大值在n=b-1,m=-1时取到</b)></p>
<p>130.涉及换根的时候，考虑一开始先把树建出来，将fa[i]等需要的信息预处理出来</p>
<p>131.前缀和的迭代：<br>    f[0]:a1,a2,a3,…<br>    f[1]:a1,a1+a2,a1+a2+a3,…<br>    f[2]:a1,2a1+a2,3a1+2a2+a3,…<br>    对于f[x][y],a[j]对其的贡献系数是从(1,j)走到(x,y)的方案数，为C(x+y-1-j,x-1)</p>
<p>132.分治时对于询问[l,r]所属的mid可以通过将区间变成(0,2^x)这样O(n)-O(1)（预处理-单词询问）<br>    也可以对mid所属的层用st表，这样是O(nlogn)-O(1)<br>    <img src="https://raw.githubusercontent.com/li-mi/Picture/master/divide%20and%20conquer.jpg" alt="某人的代码"></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/技巧/" rel="tag"># 技巧</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/28/luogu2278 [HNOI2003]操作系统/" rel="next" title="luogu2278 [HNOI2003]操作系统">
                <i class="fa fa-chevron-left"></i> luogu2278 [HNOI2003]操作系统
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/30/luogu1484 种树/" rel="prev" title="luogu1484 种树">
                luogu1484 种树 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="littleming" />
          <p class="site-author-name" itemprop="name">littleming</p>
           
              <p class="site-description motion-element" itemprop="description">爱信息 爱数学 爱吃的萌新QAQ QQ:1814291128</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">103</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">littleming</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">  Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

 <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  
  


  

  

</body>
</html>
