---
title: 树上背包
tag: 树上背包
---
在树上找k条点不相交的路径使得权值和最大（一个点算一条退化的路径） 
不能只用0/1表示（0表示不能往上，1表示能往上），有坑，合并的时候不知道上面的0有没有算一条路径！！ 

用0/1/2写，将0/1/2的max存到0中，这是错的，调用0的时候会挂（数据弱拿了50/60）
中途瞎改改对了。。（把t[1][0]赋初值-inf而不是0，选一个单点的情况认为向孩子连了2条边）（但是并没有迅速调对是因为前面把0/1/2全部取max并到0了，题解误导啊！）
$f[x][j][0/1/2]$表示在x及其子树中选了j条路径，x向它的孩子连出0/1/2条边，e[i].f是边权
y是x的一个孩子，$t[j][0/1/2]$表示当前合并的子树
$f[][][]=-inf,f[x][0][0]=f[x][1][1]=f[x][1][2]=0$
$t[][]=-inf,t[0][0]=t[1][1]=t[1][2]=0$
$t[j][0]=max(t[j][0],f[x][j-p][0]+max(f[y][p][0],f[y][p][1],f[y][p][2]))$
$t[j][1]=max(t[j][1],f[x][j-p][1]+max(f[y][p][0],f[y][p][1],f[y][p][2]),f[x][j-p][0]+f[y][p][1]+e[i].f)$
$t[j][2]=max(t[j][2],f[x][j-p][2]+max(f[y][p][0],f[y][p][1],f[y][p][2]),f[x][j-p][1]+f[y][p][1]+e[i].f)$

嘤嘤嘤嘤这题不太一样
不要求路径个数
所以只需要0/1表示跟有没有选
可以通过sum巧妙的转移到1
而确定路径数量的就不好这么做（不能控制sum选了多少，可能还需要一个背包）